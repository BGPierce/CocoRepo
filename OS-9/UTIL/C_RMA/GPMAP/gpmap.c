/* Show CC3 Get/Put Buffer Map (C version)                      *//* BASIC09 version - Copyright by Kevin Darling Sep 1987        *//* C version       - Copyright by Homer Meyer   Jan 1992        *//* A '+' in the output indicates more than one block used       *//* System Block 00, offset $1132 has last-entered Blk/BlkOffset *//* Each GPBuffer has a Header with (among other things):        *//* 00      : back block link #                                  *//* 01-02   : back block header offset                           *//* 03      : group number                                       *//* 04      : buffer number                                      *//* 05-06   : buffer size (not including header)                 *//* 07-08   : X size                                             *//* 09-0A   : Y size                                             *//* 0E      : internal screen type marker                        *//* 0F      : number of consecutive blocks used                  *//* includes and constants (i.e. defines)                        */#include <stdio.h>#define F_CPYMEM  0x1b/* define global variables and initilize                        */unsigned count,offset = 0x1132;unsigned bdat = 0,flag = 0;int stype;struct {  char bbl;  unsigned bbhoff;  char grp,buf;  unsigned bufsize, xsize, ysize;  char reserved[3],st,bu;}  bhdr;/* Function to copy external memory to a given destination     */              /* --returns a -1 on error or a 0 on success                   */   /* Arguments are:/*   int    -- the DAT to copy from     int    -- the number of bytes to copy     int    -- the offset of the data     char * -- the address to copy to                           */int fcpymem( dat, count, offset, dest )unsigned dat, count, offset;char *dest;{  struct {    char rg_cc;    unsigned rg_d;    char rg_dp;    unsigned rg_x,rg_y,rg_u; }  reg;  reg.rg_d = &dat;  reg.rg_y = count;  reg.rg_x = offset;  reg.rg_u = dest;  return( _os9( F_CPYMEM, &reg ) );}/* the main program                                            */main(){  printf("\nBk Offsets    GP BN Use     STY    Size");  printf("\n-- ---------  -- -- -------------------\n");  /* Get Block & Offset to Each One Previous in Chain:        */  while(1)  {    count = 16;    if( fcpymem( bdat, count, offset, &bhdr ) == -1 )      exit(errno);    if( flag != 0 )    {      bhdr.bufsize += 0x1f;      printf("%02.2X%c%04X-%04X  %02.2X %02.2X ",bdat,              (bhdr.bufsize > 0x1fff) ? '+' : '.',              offset,bhdr.bufsize+offset,((unsigned)bhdr.grp << 8) >> 8,              ((unsigned)bhdr.buf << 8) >> 8 );      if( bhdr.grp >= 0 )        printf("program");      else        switch( ((unsigned)bhdr.grp << 8) >> 8 )        {          case 0xff:            printf("overlay");            break;          case 0xc8:            printf("stdfont");            break;          case 0xc9:            printf("clipbrd");            break;          case 0xca:            printf("stdptrs");            break;          case 0xcb:            printf("stdpat2");            break;          case 0xcc:            printf("stdpat4");            break;          case 0xcd:            printf("stdpt16");            break;          default:            printf("  ???  ");        }      stype = (((unsigned)bhdr.st << 8) >> 8) + 4;      if( stype > 8 )        stype = 0x008b - stype;      printf("%2u%4u x %u\n",stype,bhdr.xsize,bhdr.ysize );    }    if( bhdr.bbl == 0 ) break;        offset = bhdr.bbhoff - 0x2000;    bdat = bhdr.bbl;    flag = 1;  }}