/*** Arc**  archival utility**   accepts directories as arguments**   copies files from one to the other if they already exist**    and the from file is newer or if the user gives permission.****     options are:**          -a  copy all files regardless**          -c  confirm the copy of non existent files**          -d  confirm the processing of non-existant directories**          -e  confirm the processing of existing directories**          -f  prevent copy of any files for making structure builder**          -ln stop after 'n' levels (0 <= n <= 9)**          -m  make any necessary directories and process**          -u  use uppercase for all comparisons**          -v  verify the copy****** 06/16/84  returns memory****  copyright 1984 by Carl R. Kreider**   released to the public domain for non-commercial use*//****** WARNING ******//* requires non standard "creat" or modification to copy function *//* may require more stack that the default if trees are deep *//*   I suggest at least an extra page and four is better     *//*  i.e.  cc2 arc.c access1.a -m=2 -f=Arc                    */#include <stdio.h>#include <ctype.h>#include <sgstat.h>#include <os9.h>#include <errno.h>#define  LCOLWID  26#define  RCOLWID  29#define  FNSIZ    80#define  BUFSIZ   16384#define  DPERM    0x0b#define  STDIN    0#define  STDOUT   1#define  STDERR   2#define  TRUE     1#define  S_READ   0x01#define  S_WRITE  0x02#define  S_UPDATE 0x03#define  S_DIR    0x80struct dirent {     char dir_name[29];     char dir_addr[3];     } ;struct fildes {     char      fd_att;     unsigned  fd_own;     char      fd_date[5];     char      fd_link;     long      fd_fsize;     char      fd_dcr[3];     } ;extern int memend, _mtop, _stbot;int   aflag = 0,                                      /* 'all' flag */      cflag = 0,                              /* confirm files flag */      dflag = 0,                  /* confirm non-existent dirs flag */      eflag = 0,                      /* confirm existing dirs flag */      fflag = 1,                     /* clear to suppress file copy */      mflag = 0,                    /* auto process all directories */      uflag = 0,                             /* upcase for compares */      vflag = 0;                                      /* 1 = verify */int   level = 15;int   inp, outp,                   /* input and output device paths */      intrupt();char  pause_save;char  indev[8], outdev[8];              /* input and output devices */struct sgbuf   optbuf;               /* terminal path option buffer */struct dirent     dirbuf;                /* single dir ent read buf */char  cpbuf[BUFSIZ];                             /* the copy buffer *//*page*/main(argc,argv)int   argc;char  **argv;   {   int strcmp(), strucmp();   char *p;   if (*(p = *++argv) == '-')         {         procopt(p);         --argc;                         /* adjust count for option */         ++argv;                                        /* next arg */         }   write(STDOUT, "\l", 1);   if (argc != 3)         help();   pause_off();   intercept(intrupt);   opendev(argv);   process(argv[0], argv[1], level);   pause_on();   }/*page*//*** process command line options*/procopt(p)char  *p;   {   char  c;   while (c = *++p)      {      switch (c)         {         case 'a' :                                   /* 'all' flag */               aflag = TRUE;               break;         case 'c' :                                /* confirm files */               cflag = TRUE;               break;         case 'd' :                            /* confirm directory */               dflag = TRUE;               break;         case 'e' :                 /* confirm existing directories */               eflag = TRUE;               break;         case 'f' :                                   /* copy files */               fflag = FALSE;               break;         case 'l' :                                   /* nest level */               level = (*++p - '0' -1);               if (level >= 0 && level < 9)                     break;         case 'm' :                           /* do all directories */               mflag = TRUE;               break;         case 'u' :               uflag = TRUE;               break;         case 'v' :                                       /* verify */               vflag = TRUE;               break;         default  :               help();               break;         }      }   }/*page*//*** open the devices for the two dir names*/opendev(p)char  **p;                               /* pointer to two pointers */   {   get_dev(*p, indev);   get_dev(*++p, outdev);   if ((inp = open(indev, S_READ)) == -1)         excant(indev);   if ((outp = open(outdev, S_READ + S_WRITE)) == -1)         excant(outdev);   }/*** process the two passed trees*/process(from, to, depth)char  *from, *to;int   depth;   {   char  fmstr[FNSIZ],                     /* place for from string */         tostr[FNSIZ];                       /* place for to string */   struct fildes  ifdes, ofdes;   struct dirent  *ibuf, *obuf, *ibp, *obp, *newp, *ibufe,  *obufe;   if ((ibp = ibuf = readdir(from, &ibufe)) == -1)         return (0);   if ((obp = obuf = readdir(to, &obufe)) == -1)         return (0);   while (ibp < ibufe)      {      buildstr(fmstr, from, ibp);      buildstr(tostr, to, ibp);      get_fd(inp, &ifdes, ibp->dir_addr);   /* get 'from' file desc */      newp = search(ibp, obp, obufe);      if ((ifdes.fd_att & S_DIR) == S_DIR)            procdir(fmstr, tostr, depth, newp, ifdes.fd_att);         else            if (fflag)                  procfile(fmstr, tostr, &ifdes, &ofdes, &obp, &newp);      ibp += 1;      }   free(obuf);   free(ibuf);   }/*page*//*** process a directory if possible or permissable.**  create as needed.*/procdir(fmstr, tostr, depth, newp, attr)char  *fmstr,  *tostr;int   depth,   newp;char  attr;   {   int   doit = 0;                /* assume we will process the dir */   telopr(fmstr, tostr);   if (depth <= 0)         doit = 1;                                 /* don't process */      else         if (newp == 0)                           /* does not exist */               {               if (!mflag)                         /* m is all dirs */                     if (!dflag)       /* d is only with permission */                           doit = 1;               /* no permission */                        else                           if (!(askhim("process? ")))                                 doit = 2;            /* he said no */               }            else               if (eflag && (!askhim("process? ")))                     doit = 2;   switch (doit)                                /* now take atction */      {      case 0 : writeln(STDOUT, "processing\n", 80);               if (newp == 0)                     if (mknod(tostr, attr) == -1)                           excant(tostr);               process(fmstr, tostr, depth - 1);               break;      case 1 : writeln(STDOUT, "not processed\n", 80);               break;      case 2 : writeln(STDOUT, "\n", 1);               break;      }   }/*page*//*** take care of proper action and messages for case of file.*/procfile(fmstr, tostr, ifbuf, ofbuf, obp, newp)char  *fmstr,  *tostr;struct fildes  *ifbuf,  *ofbuf;struct dirent  **obp,   **newp;   {   int   doit;   telopr(fmstr, tostr);   if (*newp)         {                                /* file is there */         doit = 3;                     /* assume no update */         get_fd(outp, ofbuf, (*newp)->dir_addr);  /* to desc */         *obp = ++(*newp);              /* set for next search */         if (newer(ifbuf->fd_date, ofbuf->fd_date))               doit = 1;                   /* so update it */         }      else         {                           /* file not there now */         doit = 0;                          /* assume copy */         if (!(aflag))                   /* a is all files */               if (!(cflag))                     doit = 2;   /* no check with operator */                  else                     if (!(confirm()))                           doit = 4;         /* he said no */         }   if (doit <= 1)         copy(fmstr, tostr, ifbuf);   switch (doit)      {      case 0 : writeln(STDOUT, "copied\n", 80);               break;      case 1 : writeln(STDOUT, "updated\n", 80);               break;      case 2 : writeln(STDOUT, "not copied\n", 80);               break;      case 3 : writeln(STDOUT, "not updated\n", 80);               break;      case 4 : writeln(STDOUT, "\n", 1);               break;      }   }/*page*//*** snatch memory from the system and read in directory,**  saving only good files.  Then sort into order.**** returns the size of block and the end via reference**  parameters, but only valid if operation was successful.**** returns  -1 on any error**         pnt on success*/readdir(s, end, size)char  *s;int   *end;   {   char  *buf;   struct fildes  fdbuf;   struct dirent  *bufp;   int   mem;   int   fd, j;   int   count = 0;   if ((fd = open(s, S_DIR+S_READ)) == -1)         return (-1);                                    /* not dir */   readfd(fd, &fdbuf);                          /* 'from' file desc */   mem = (int)(fdbuf.fd_fsize);   if ((buf = bufp = malloc(mem)) == -1)    /* get mem for name buf */         {         error("out of memory", 0);         return(-1);         }   while(read(fd, &dirbuf, sizeof(dirbuf)))       /* now copy names */      {      if (isalpha(dirbuf.dir_name[0] & 0x7f))            {            strhcpy(bufp, &dirbuf);            bufp->dir_name[28] = '\0';            for (j = 0; j < 3; j++)               bufp->dir_addr[j] = dirbuf.dir_addr[j];            ++bufp;                           /* point to next spot */            ++count;            }      }   close(fd);   qsort(buf, count, sizeof(dirbuf), (uflag ? strucmp : strcmp));   *end = bufp;   return (buf);   }/*page*//*** copies 'from' to 'to' overwriting if there**  or creating if not*/copy(from, to, fdbuf)char  *from, *to;struct fildes  *fdbuf;   {   struct rbfopt  options;   int   n;   int   ifd, ofd;   if ((ifd = open(from, S_READ)) == -1)         {         cant(from);         return;         }   if ((ofd = creat(to, S_WRITE, fdbuf->fd_att)) == -1)         {         cant(to);         close(ifd);         return;         }   getstat(SS_OPT, ofd, &options);   options.sg_verify = 1;                             /* verify off */   setstat(SS_OPT, ofd, &options);   setstat(SS_SIZE, ofd, fdbuf->fd_fsize);        /* pre-extend now */   writefd(ofd, fdbuf);                             /* use old date */   while ((n = read(ifd, cpbuf, BUFSIZ)) >0 )      {      if (write(ofd, cpbuf, n) != n)            {            if (errno == E_FULL)                  {                  writeln(STDOUT, "disk full\n", 80);                  arc_exit (0);                  }               else                  {                  error("write error on ", to);                  prerr(STDERR, errno);                  break;                  }            }      }   if (n)         {         error(" read error on ", to);         prerr(STDERR, errno);         }   close(ifd);   close(ofd);   if (vflag)         verify(to);   }/*page*//*** verify that we can read the new file*/verify(to)char  *to;   {   int   ofd, n;   if ((ofd = open(to, S_READ)) == -1)         cant(to);      else         {         while ((n = read(ofd, cpbuf, BUFSIZ)) > 0)            ;         close(ofd);         if ((n == -1) && (errno != E_EOF))               error(" write verify error on ", to);         }   }/*** returns pnt if there or 0 if not*/search(from, to, end)struct dirent  *from,   *to,  *end;   {   int   flag = 1;                                /* preset to fail */   while (to < end)      {      if (uflag)            flag = strucmp(from, to);            /* until s2 >= s1 */         else            flag = strcmp(from, to);              /* until s2 >= s1 */      if (flag <= 0)            break;      to += 1;      }   return (flag ? 0 : to);   }/*page*//*** returns true if 'frdate' is newer than 'todate'*/newer(frdate, todate)register char  *frdate, *todate;   {   int   n;   int   delta;   for (n = 5; n; n--)      {      if ((delta = ((*frdate++ & 0xff) - (*todate++ & 0xff))) < 0)            return(0);      if (delta > 0)            return(1);      }   return(0);   }/*** special exit location to allow cleanup*/arc_exit(code)int   code;   {   pause_on();   exit (code);   }/*page*//****/confirm()   {   return (askhim("copy? "));   }/*** return true if response to prompt 's' is Y or y*/askhim(s)char  *s;   {   char  c;   writeln(STDOUT, s, strlen(s));   read(STDIN, &c, 1);   writeln(STDOUT, " ", 1);   return ((c & 0x5f) == 'Y');   }/****/excant(s1)char  *s1;   {   cant(s1);   arc_exit (0);   }/*** say that we cant open a file*/cant(s1)char  *s1;   {   error("can't open ",s1);   prerr(STDERR, errno);   }/*** write the two strings passed and then a <cr>*/error(s1, s2)char  *s1, *s2;   {   if (s1)         write(STDOUT, s1, strlen(s1));   if (s2)         write(STDOUT, s2, strlen(s2));   writeln(STDOUT, "\n", 1);   }/*page*//*** provide usage info for this command*/help()   {   writeln(STDOUT, "Usage: arc [-acdeflmuv] from_dir to_dir\n", 80);   writeln(STDOUT, "     a = all files\n", 80);   writeln(STDOUT, "     c = confirm file if not there\n", 80);   writeln(STDOUT, "     d = confirm non-existant directory\n", 80);   writeln(STDOUT, "     e = confirm existing directory\n", 80);   writeln(STDOUT, "     f = prevent copy of files\n", 80);   writeln(STDOUT, "    ln = only n levels of the tree (1..9)\n", 80);   writeln(STDOUT, "     m = do multilple (all) directories\n", 80);   writeln(STDOUT, "     v = verify the copy\n", 80);   writeln(STDOUT, "     u = force uppercase for comparisons\n", 80);   exit (0);   }telopr(s1, s2)char  *s1, *s2;   {   int   n;   n = strlen(s1);   writeln(STDOUT, s1, n);   space(LCOLWID - n);   writeln(STDOUT, "-> ", 3);   n = strlen(s2);   writeln(STDOUT, s2, n);   space(RCOLWID - n);   }/*** write 1 to n spaces*/space(n)int   n;   {   do      write(STDOUT, " ", 1);   while (--n > 0);   }/*** concat s2,'/',s3 into s1*/buildstr(s1, s2, s3)char  *s1,  *s2,  *s3;   {   register char  *p = s1;   while (*p++ = *s2++)         ;   --p;   *p++ = '/';   while (*p++ = *s3++)         ;   }/*page*//***  return in 'buf' the device name where**   file 's' resides.*/get_dev(s, buf)char  *s,   *buf;   {   char  temp[32];   int   pn;   if ((pn = open(s, S_DIR+S_READ)) == -1)         excant(s);   lgetstat(pn, SS_DEVNM, temp, 0, 0);   *buf++ = '/';   strhcpy(buf, temp);                       /* now copy first item */   strcat(buf, "@");                                 /* and set raw */   close(pn);   }/*** seek to 'pos' on device 'pn' and read**  'fildes' bytes into 'buf'*/get_fd(pn, buf, pos)int   pn;struct fildes  *buf;char  *pos;   {   l3seek(pn, pos);   if ((read(pn, buf, sizeof(struct fildes))) == -1)         excant("Can't read file desc.\n");   }/*** read the file desc for file 'fd' into 'fdbuf'*/readfd(fd, fdbuf)char  fd;struct fildes *fdbuf;   {   lgetstat(fd, SS_FD, fdbuf, 16, 0);   }/*** read the file desc for file 'fd' into 'fdbuf'*/writefd(fd, fdbuf)char  fd;struct fildes *fdbuf;   {   lsetstat(fd, SS_FD, fdbuf, 16, 0);   }/*page*//*** local getstat**  r_a = path number       r_b = code**  r_x = parameter         r_y = parameter          r_u = parameter*/lgetstat(r_a, r_b, r_x, r_y, r_u)char r_a, r_b;int  r_x, r_y, r_u;   {   struct registers  reg;   reg.rg_a = r_a;   reg.rg_b = r_b;   reg.rg_x = r_x;   reg.rg_y = r_y;   reg.rg_u = r_u;   if (_os9(I_GETSTT, &reg) == -1)         arc_exit (reg.rg_b);   return (reg.rg_b);   }/*** local setstat**  r_a = path number       r_b = code**  r_x = parameter         r_y = parameter          r_u = parameter*/lsetstat(r_a, r_b, r_x, r_y, r_u)char r_a, r_b;int  r_x, r_y, r_u;   {   struct registers  reg;   reg.rg_a = r_a;   reg.rg_b = r_b;   reg.rg_x = r_x;   reg.rg_y = r_y;   reg.rg_u = r_u;   if (_os9(I_SETSTT, &reg) == -1)         arc_exit (reg.rg_b);   return (reg.rg_b);   }/*page*//*** seek to the LSN specified by the 3 char string 'pos'*/l3seek(pn, pos)int   pn;char  *pos;   {   long  lpos;   int   j;   register char *p = &lpos;   for (j = 3; j ; j--)      *p++ = *pos++;   *p = 0;                                          /* zero ls byte */   lseek(pn, lpos, 0);   }/*** save the current status of the pause flag**  and then turn off*/pause_off()   {   getstat(SS_OPT, STDOUT, &optbuf);              /* shut pause off */   pause_save = optbuf.sg_pause;   optbuf.sg_pause = 0;   setstat(SS_OPT, STDOUT, &optbuf);   }/*** restore pause to it's prior status*/pause_on()   {   optbuf.sg_pause = pause_save;                   /* restore pause */   setstat(SS_OPT, STDOUT, &optbuf);   }intrupt(sig)int   sig;   {   arc_exit (sig);   }/*** special strcmp to ignore case*/strucmp(s1, s2)char          *s1;register char *s2;   {   while (toupper(*s1) == toupper(*s2))      {      if (*s2++ == 0)            return (0);      s1++;      }   return (toupper(*s1) - toupper(*s2));   }