/*** kutil.c**** Copyright 1989, 1990 Bruce Isted** All Rights Reserved**** This program may be freely distributed as long as the copyright notice** remains intact and the source, binary, and documentation files are** distributed together.**** This program may not be sold for profit, individually or as part of a** package without the prior written permission of the copyright holder.*//*** IMPORTANT NOTE:  This program depends heavily on Carl Kreider's replacement**                  C library (clib.l).**** Usage:  kutil -<options> <source> <destination>**** Purpose:  To extract/modify/install the OS-9 Kernel.**** Options:  g = Get a Kernel track (to Kernel file).**           p = Put a Kernel track (from Kernel file).**           r = Replace the Boot module in a Kernel file.**           s = Single drive operation.**** Examples:  kutil -g /d0 /d1/oldkernel**                Reads the /D0 Kernel track and writes it to a Kernel**                file called /D1/oldkernel.**            kutil -rs /d0/modules/boot.wd /d0/oldkernel**                Replaces the Boot module in the Kernel file called**                /D0/oldkernel on one disk with the Boot module**                from the /D0/MODULES/Boot.wd file on another disk.**            kutil -p /d1/oldkernel /h00**                Reads the Kernel file called /D1/oldkernel, and**                writes it to the /H00 Kernel track.**** Note:  The Kernel track will be written to floppy disk or one cylinder hard**        disk partition without regard for existing data.  That is to say,**        any previous data on the Kernel track will be overwritten.  If the**        Kernel track is written to floppy disk the allocation map will be**        updated to show the Kernel track is allocated.**** History:**   Version 1.0  89/06/13  BRI**   Version 1.1  90/05/30  Added CoCo OS-9 Level 1 support.  BRI**   Version 1.2  91/06/25  Added code to put kernal on track 128**                          of hard drive (Burke & Burke)     DST**** Comments to:  Bruce Isted**                 CIS:  76625,2273**                 Delphi:  BRUCEISTED**** Burke & Burke modifications by: Don Thrash**                                 Delphi: DONTHRASH*/#include <ctype.h>#include <direct.h>#include <modes.h>#include <stdio.h>#include <string.h>#define fda1ofst 332l#define fda2ofst 409l#define fdk_ofst 156672l#define fdk2ofst 313344l#define hdk_ofst 256l/* Added by DST */#define FLOPPY      34   /* Floppy disk kernal track */#define HARD       128   /* Hard Disk kernal track (Burke & Burke) */#define TRUE         1#define FALSE        0main( argc, argv )int argc;char **argv;{    extern char *optarg;    extern int optind,               opterr;    char all_data[3],         all_mask[3],         *buff,         dev_name[34],         *dst_name,         *malloc(),         message[30],         modstart[1],         *src_name,         temp[1];    int c,        bootpath,        dev_path,        errflag = 0,        gflag = 0,        krnlpath,        pflag = 0,        rflag = 0,        sflag = 0;    int is_even = 0;     /* DST */    unsigned bootsize,             buffsize = 0x1200,             isboot(),             readsize;    long all_addr,         getofst(),         lseek(),         offset = 0l;    while(( c = getopt( argc, argv, "gprsa" )) != EOF )        switch( c ) {        case 'g' :       /* get the kernal */            if( pflag || rflag )   /* can't use put or replace with get */                errflag++;            else                gflag++;            break;        case 'p' :       /* put the kernal */            if( gflag || rflag )   /* can't use get or replace with put */                errflag++;            else                pflag++;            break;        case 'r' :       /* replace the kernal */            if(gflag || pflag )    /* can't use get or put with replace */                errflag++;            else                rflag++;            break;        case 's' :       /* single disk mode */            sflag++;            break;        case '?' :       /* display usage message */                errflag++;        }    if( errflag || ( argc < 4 ) || ( optind < 2 ) || ( optind > ( argc-2 )))        usage();    src_name = argv[optind];  /* source device name */    optind++;    dst_name = argv[optind];  /* destination device name */    if( gflag ) {        if( sflag )            prompt( "kernel track source" );        /* get devicename+@ for source file */        if( ! getname( &dev_name[0], src_name ))            exit( _errmsg( 1, " Can't get device name for '%s'.\n",              src_name ));        /* open devicename+@ for read */        if(( dev_path = open( &dev_name[0], S_IREAD )) == -1 )            exit( errno );        /* determine kernel location on devicename+@ */        if(( offset = getofst( dev_path )) == 0)            exit( _errmsg( 1, " '%s' isn't bootable.\n",              &dev_name[0] ));        /* get memory for kernel */        if(( buff = malloc( buffsize )) == NULL )            exit( errno );        /* read kernel from devicename+@ */        lseek( dev_path, offset, 0 );        if(( readsize = read( dev_path, buff, buffsize )) == -1 )            exit( errno );        if( readsize != buffsize )            exit( _errmsg( 1, " EOF encountered in '%s'.\n", &dev_name[0] ));        /* close devicename+@ */        close( dev_path );        /* check kernel flag bytes */        if(( *buff != 'O' ) || ( *( buff + 1 ) != 'S' ))            exit( _errmsg( 1, " No kernel in '%s'.\n", &dev_name[0] ));        if( sflag )            prompt( "kernel file destination" );        /* check to ensure destination file doesn't already exist */        if( access( dst_name, 0x00 ) == 0 )            exit( 218 );        /* create destination file in update mode */        if(( krnlpath = creat( dst_name, S_IREAD+S_IWRITE )) == -1 )            exit( errno );        /* write kernel to destination file */        if( write( krnlpath, buff, buffsize ) == -1 )            exit( errno );        /* close destination file */        close( krnlpath );        /* return memory */        free( buff );    }    if( pflag ) {        if( sflag )            prompt( "kernel file source" );        /* open source file for read */        if(( krnlpath = open( src_name, S_IREAD )) == -1 )            exit( errno );        /* get memory for kernel */        if(( buff = malloc( buffsize )) == NULL )            exit( errno );        /* read kernel from source file */        if(( readsize = read( krnlpath, buff, buffsize )) == -1 )            exit( errno );        if( readsize != buffsize )            exit( _errmsg( 1, " EOF encountered in '%s'.\n", krnlpath ));        /* close source file */        close( krnlpath );        /* check kernel flag bytes */        if(( *buff != 'O' ) || ( *( buff + 1 ) != 'S' ))            exit( _errmsg( 1, " '%s' isn't a kernel file.\n", src_name ));        if( sflag )            prompt( "kernel track destination" );        /* get devicename+@ for destination file */        if( ! getname( &dev_name[0], dst_name ))            exit( _errmsg( 1, " Can't get device name for '%s'.\n",              dst_name ));        /* open devicename+@ for update */        if(( dev_path = open( &dev_name[0], S_IREAD+S_IWRITE )) == -1 )            exit( errno );        /* determine kernel location on devicename+@ */        if(( offset = getofst( dev_path )) == 0)            exit( _errmsg( 1, " '%s' isn't bootable.\n",              &dev_name[0] ));        /* write kernel to devicename+@ */        lseek( dev_path, offset, 0 );        if( write( dev_path, buff, buffsize ) == -1 )            exit( errno );        /* Calculate the offset into the FAT rather than use fixed numbers.      Here we divide the offset by 256 to get sector #, divide the sector by      8 to get the offset into the alloc map then add 256 to allow       for sector 0.  DST */        all_addr = (( offset / 256) / 8) + 256;   /* is_even checks to see if the alloc table bit starts on a byte      boundry. */        is_even =  (( offset /256) % 8);        /* if( offset == fdk_ofst ) {            all_addr = fda1ofst; */        if ( is_even == 4) {       /* starts in middle of byte */            all_mask[0] = '\017';            all_mask[1] = '\377';            all_mask[2] = '\374';        }        /* if( offset == fdk2ofst ) {            all_addr = fda2ofst; */         if ( is_even == 0) {      /* even byte boundry */            all_mask[0] = '\377';            all_mask[1] = '\377';            all_mask[2] = '\300';        }        /* if floppy drive OR NON PARTITIONED HARD DRIVE,           update allocation map contents */        /* The following is just a real quick error preventing check           If is_even is not an expected number ( 0 or 4 ) don't do           the alloc map write     DST */        if( is_even == 0 || is_even == 4)            ;        else           offset = hdk_ofst;        if( offset != hdk_ofst ) {            /* get current allocation map data */            lseek( dev_path, all_addr, 0 );            if( read( dev_path, &all_data[0], 3 ) == -1 )                exit( _errmsg( errno, " Allocation map read error.\n" ));            /* mark kernel area used in allocation map */            all_data[0] |= all_mask[0];            all_data[1] |= all_mask[1];            all_data[2] |= all_mask[2];            /* write updated area in allocation map */            lseek( dev_path, all_addr, 0 );            if( write( dev_path, &all_data[0], 3 ) == -1 )                exit( _errmsg( errno, " Allocation map write error.\n" ));        }        /* close devicename+@ */        close( dev_path );        /* return memory */        free( buff );    }    if( rflag ) {        if( sflag )            prompt( "boot module file source" );        /* open source file for read */        if(( bootpath = open( src_name, S_IREAD )) == -1 )            exit( errno );        /* determine that source file contains boot module */        if(( buffsize = isboot( bootpath, 0l )) == 0 )            exit( _errmsg( 1, " No Boot module in '%s'.\n", src_name ));        /* get memory for boot module */        if(( buff = malloc( buffsize )) == NULL )            exit( errno );        /* read boot module */        lseek( bootpath, 0l, 0 );        if(( readsize = read( bootpath, buff, buffsize )) == -1 )            exit( errno );        if( readsize != buffsize )            exit( _errmsg( 1, " EOF encountered in '%s'.\n", src_name ));        /* close source file */        close( bootpath );        if( sflag )            prompt( "kernel file destination" );        /* open destination file for update */        if(( krnlpath = open( dst_name, S_IREAD+S_IWRITE )) == -1 )            exit( errno );        /* locate boot module in destination file */        while(( readsize = read( krnlpath, &temp[0], 1 )) == 1 ) {            /* look for initial module sync byte ($87) */            if( temp[0] == '\207' ) {                /* if Boot module get size */                if(( bootsize = isboot( krnlpath, offset )) != 0 ) {                    /* if size mismatch print warning message */                    if( bootsize != buffsize ) {                        printf( "WARNING:  Boot module sizes do\n" );                        printf( "          not match.\n\n" );                        printf( "If not using CoCo OS-9 Level 1\n" );                        printf( "Version 01.00.00, 01.01.00, or\n" );                        printf( "02.00.00 this may result in an\n" );                        printf( "unuseable kernel file.\n" );                    }                    /* replace boot module in destination file */                    lseek( krnlpath, offset, 0 );                    if(( write( krnlpath, buff, buffsize )) == -1 )                        exit( errno );                    break;                }            }            offset++;            lseek( krnlpath, offset, 0 );        }        if( readsize == -1 )            exit( errno );        if( readsize != 1 )            exit( _errmsg( 1, " No matching boot module in '%s'.\n",              dst_name ));        /* close destination file */        close( krnlpath );        /* return memory */        free( buff );    }}/*** return kernel start offset, zero if not a bootable disk*/long getofst( dev_path )int dev_path;{    char disk_sid[1],         disk_typ[1];    int  disk_sect;    unsigned disk_cyl;    long krnlofst = 0l,         lseek();   /* get LSN0 disk info */   /* Find out how many sides on media, save until later as a floppy is      either single or double sided but a hard disk may have several sides.             DST    */   lseek( dev_path, 16l, 0 );   if( read( dev_path, &disk_sid[0], 1 ) == -1 )      exit( errno );   /* get the media type */   lseek( dev_path, 66l, 0 );   if( read( dev_path, &disk_typ[0], 1 ) == -1 )      exit( errno );   lseek( dev_path, 68l, 0 );   if( read( dev_path, &disk_cyl, 2 ) == -1 )      exit( errno );   /* get sectors per track DST */   lseek( dev_path, 72l, 0 );   if( read( dev_path, &disk_sect, 2 ) == -1 )      exit( errno );   /* Is it a hard drive ? */   /* Code added and modified here DST */   /* The disk partition part should still work. I took care not to modify      it as I am not familar with it. DST */   if(( disk_typ[0] & '\200' ) == '\200' ) {      /* hard drive partition ? */      if ( disk_cyl == 1 ) {         krnlofst = hdk_ofst;      }      /* Multiple head drive */       else {         disk_sid[0] -= 1;   /* correction adjustment to sides */         krnlofst = ((long)disk_sid[0] * (long)disk_sect) *             ((long)HARD * (long)256);      }        }            /* floppy boot disk? */   if( disk_typ[0] == '\040' ) {      /* Now do the side calculations (moved here from above) DST */      disk_sid[0] = ( disk_sid[0] & '\001' ) + '\001';      krnlofst = ((long)disk_sid[0] * (long)disk_sect) *          ((long)FLOPPY * (long)256);   }   /* return kernel start offset */   return( krnlofst );}/*** return entire device name for pathlist*/getname( dev_name, pathlist )char *dev_name,     *pathlist;{    char buff[32];    int pathnmbr;    if(( pathnmbr = open( pathlist, S_IREAD )) == -1 )        if(( pathnmbr = open( pathlist, S_IREAD+S_IFDIR )) == -1 )            return( FALSE );    if( _gs_devn( pathnmbr, &buff[0] ) == -1 )        return( FALSE );    close( pathnmbr );    strcpy( dev_name, "/" );    strcat( dev_name, &buff[0] );    strhcpy( dev_name, dev_name );  /* strip high bit at end of name */    strcat( dev_name, "@" );    return( TRUE );}/*** return boot module size, or 0 if not boot module*/unsigned isboot( pathnmbr, offset )int pathnmbr;long offset;{    char modname[4];    int modsync;    unsigned modsize,             nameofst;    /* check module sync bytes */    lseek( pathnmbr, offset, 0 );    if( read( pathnmbr, &modsync, 2 ) != 2 )        return( 0 );    if( modsync != 0x87CD )        return( 0 );    /* get module size */    if( read( pathnmbr, &modsize, 2 ) != 2 )        return( 0 );    /* get module name offset */    if( read( pathnmbr, &nameofst, 2 ) != 2 )        return( 0 );    /* get module name */    lseek( pathnmbr, ( offset + nameofst ), 0 );    if( read( pathnmbr, &modname[0], 4 ) != 4 )        return( 0 );    /* if module name is 'BOOT', return module size */    if(( modname[3] & '\200' ) != '\200' )        return( 0 );    strhcpy( &modname[0], &modname[0] ); /* strip high bit at end of name */    if( patmatch( "boot", &modname[0], TRUE ))        return( modsize );    else        return( 0 );}prompt( message )char *message;{    char *fgets(),         inp_line[201];    /* prompt for new disk and wait for [ENTER] */    printf( "Insert the %s disk, ", message );    printf( "then press [ENTER] to continue.\n" );    fgets( &inp_line[0], sizeof( inp_line ), stderr );}usage(){    fprintf( stderr,      "Usage:  kutil -<options> <source> <destination>\n\n" );    fprintf( stderr,      "Purpose:  To extract/modify/install the OS-9 Kernel.\n\n" );    fprintf( stderr,      "Options:  g = Get a Kernel track (to Kernel file).\n" );    fprintf( stderr,      "          p = Put a Kernel track (from Kernel file).\n" );    fprintf( stderr,      "          r = Replace the Boot module in a Kernel file.\n" );    fprintf( stderr,      "          s = Single drive operation.\n\n" );    fprintf( stderr,      "Examples:  kutil -g /d0 /d1/oldkernel\n" );    fprintf( stderr,      "               Reads the /D0 Kernel track and writes it to a\n" );    fprintf( stderr,      "               Kernel file called /D1/oldkernel.\n" );    fprintf( stderr,      "           kutil -rs /d0/modules/boot.wd /d0/oldkernel\n" );    fprintf( stderr,      "               Replaces the Boot module in the Kernel file called\n" );    fprintf( stderr,      "               /D0/oldkernel on one disk with the Boot module\n" );    fprintf( stderr,      "               from the /D0/MODULES/Boot.wd file on another disk.\n" );    fprintf( stderr,      "           kutil -p /d1/oldkernel /h00\n" );    fprintf( stderr,      "               Reads the Kernel file called /D1/oldkernel, and\n" );    fprintf( stderr,      "               writes it to the /H00 Kernel track.\n" );    exit( 0 );}