.m1 5.m2 3.m3 3.m4 5.po 5.rm 65.ce 4GUILIB version 1.0Copyright (c) 1992by  James DelaneyandDaniel HauckGUI.L, the Graphical User Interface C library, wasdesigned with a few simple goals in mind.  These goalsinclude the ability to present a sharp-appearing deviceon a graphics screen that will present the illusion ofbeing a three- dimentional piece of [virtual] hardware. Another of these goals is so that a programmer mayeasily manage an manipulate these "objects" as both aform of output and as input to the application utilizingthis library.  And finally, GUI.L was designed as ameans to ease mouse-driven applications to the pointthat calculating mouse coordinates and other suchtedious actions will no longer be required.  In fact, adevice may actually be "moved" from one place on theworking area to another without ANY modification to theworking program except the reassignment of certaindevice statistics.  One might go so far as to say thatthis is a form of "virtual hardware user-interfacecoding."The inspiration for this project is the responsibilityof Shawn Driscoll who developed "GUIB" which is ofsimilar design to GUI.L.  His goal was a little morerobust than ours (Delaney and Hauck) in that a furthergoal in his designing of GUIB was to inspire otherprogrammers to use his function interface to ease and"fancy-up" software by other programmers.  He didaccomomplish this goal and GUI.L is a direct reflectionof his very successful effort.  However, our goal is notnearly so noble, as we would like (but do not require)some form of compensation for our efforts.  Further, anycommercial software developed using GUI.L wouldcertainly REQUIRE a form of compensation to thedevelopers.Program functions range in level from low to high wherelow-level functions will display buttons, windows,slide-bars and buttons without any form of managementother than that which the programmer invents. High-levelfunctions will be those that require the use of complexdata structures to manage and check the status ofdevices placed and manipulated on the screen.  Thesehigh- level functions, will add great managability andsimplicity to program code and applications that even aprogrammer new to C can use easily and functionally withminimal time spent debugging..pg.pg 1.fo //- % -//.he /GUI.L(1)/The Graphical User Interface C Library/GUI.L(1)/NAME.ti +5SetGui - GUI setup function to set palettes and scalemodeSYNOPSIS.in +5.nf#include <gui.h>SetGui(wpath,type,scale)int wpath,type,scale.fi.in -5DESCRIPTION.in +5SetGui() sets up the working palettes (12-15 on a type 8 and 0-3 on a type 7) to optimalviewing colors (shades of grey)The variable _TYPE is defined in gui.h and will reflect thevalue passed in type.   This tells gui what kind of screen it is working on.  If you change window types after calling setguiyou must change _TYPE to reflect the screen type. Gui supportstype 7 and type 8 screens.The variable _SCALE is defined in gui.h and will reflect the value passed in scale.  Gui will set the scale switch eiter off 0or on 1 depending on what you sent in scale.  Scaling may be used in either ON or OFF modes solong as the GUI variable "_SCALE" is also set to theappropriate and coresponsing value along with the scaleswitch function.  This is important so that the GUIlibrary functions will know how to respond in certaincircumstances.Gui works best on a non scaled window of either type.  If you changescale after calling SetGui make sure you change the variable _SCALEto reflect that change.   If you run GUI in a scaled screen itwill run very slowly.   So if possible run it on a non scaled window..in -5.pgNAME.in +5.nfButton - Draws a button in the ON, OFF and INIZ positions.in -5SYNOPSIS.in +5#include <gui.h>Button(wpath,name,x,y,len,size,act)int wpathchar *nameint x,y,len,size,act.fi.in -5DESCRIPTION.in +5Button() creates a button figure with the label definedby "name" at CHARACTER coordinates "x" and "y".  Notethat these are character coordinates.  This is primarilydue to the fact that text printed inside the buttonfigures are, in fact, real text printed using the writefunction as opposed to treating the characters in a GPbuffer fashion.  As a result of this, the actualcharacters are printed at the position specified by Xand Y.  The rest of the button drawn is one-half acharacter space (or 4 pixels) above, below, right and left of theregion specified by x,y,len,size.  Consequently, buttonsmay be grouped together by allowing for one characterspace between calculated widths.This function uses the GUI functions Box_Dropped() andBox_Raised() to create the "button in" and "button out"appearance.  The type of button drawn is dictated by thevariable "act".  The following is a list of definitionsfor the various action (act) modes:.in +10.nf          _INIZ_    -1          _ON_       1          _OFF_      0.fi.in -10The function variable "size" determines the verticalsize of the button drawn. A size defined as "BT_REG" isa regular sized button and "BT_BIG" is a double heightbutton where an extra line is allocated to create alarger (more important!) button.Button() is considered somewhere between low level andhigh.  This is because it uses the more primativefunctions Box_Dropped, Box_Raised and Square alsocontained within this library..in -5.pgCAVEATS.in +5Do not specify a value of zero to either "x", "y" or"len" parameters.  This will not return an error, but itwill create unfavorable results on the display.The size of the character array reserved for buttonlabels is limited to 32 characters..in -5.pgNAME.ti +5Window - Draws a variety of fancy window types on screenSYNOPSIS.in +5.nf#include <gui.h>Window(wpath,act,x1,y1,x2,y2)int wpath,act,x1,y1,x2,y2.fi.in -5DESCRIPTION.in +5Window() is a complex and versatile function that willdraw many forms of elaborate frames, borders andwindows.  The various types are defined by the variable"act".  The following is a list of definitions for the"act" parameter:.nf.in +10#define   W_FRAMED   0#define   W_RAISED   1#define   W_DROPPED  2#define   W_SHADOWED 3#define   W_ETCHED   4.in -10.fiSince these various styles are virtually impossible todescribe in text form, the best way to illustrate thevarious types is by example.The Window() coordinates are defined by x1,y1 (expectedupper-left corner) and x2,y2 (expected lower-rightcorner) where these coordinates are graphically oriented(i.e. 0-639 across and 0-191 vertically)..in -5CAVEATS.in +5There is no checking to see if the x1-y1 coordinates arethe most upper and left in comparison to x2-y2coordinates.  This is left to the programmer so thatGUI.L may be as small and tight as possible..in -5.pgNAME.in +5.nfBox_Pushed - Draws a 3-D box giving a "pushed in" effectBox_Popped -  ''  ''  ''   ''        "popped out" effectBox_Dropped-  ''  ''  ''   '' deeper "pushed  in" effectBox_Raised -  ''  ''  ''   '' higher "popped out" effect.in -5SYNOPSIS.in +5Box_Pushed(wpath,x1,y1,x2,y2)Box_Popped(wpath,x1,y1,x2,y2)Box_Dropped(wpath,x1,y1,x2,y2)Box_Raised(wpath,x1,y1,x2,y2)int wpath,x1,y1,x2,y2.fi.in -5DESCRIPTION.in +5The following four functions all share the same basicformat where "wpath" is an integer indicating the pathnumber to the window device being written to. Theworking coordinates x1 and y1 are representative of theupper-left corner of the rectangular box to be createdon the display.  Likewise, the working coordinates x2and y2 are representative of the lower-right corner ofthe box to be displayed.Box_Pushed() is a simple low-level routine that willcreate a box that will create the illusion that itscontents are "lower" or more "pushed in" than thesurrounding background.  With this function, things maybe made to have the appearance of being "sunken" intothe display when surrounded by such a box.This effect is created by a two-colored box typefunction where a one-pixel border is created all the wayaround the subject.Box_Popped() is a simple low-level routine that willcreate a box that creates the illusion that its contentsare "higher" or "popped up" from the surrounding areabackground.  With this function things may be made tohave the apprearance of being "popped up" slightly fromthe display when surrounded by such a box.This effect, just as Box_Pushed(), is created by using aone-pixel rectangular border around the subject.Box_Dropped() is an seemingly extended function overBox_Pushed() in that a "deeper" effect is created byusing Box_Dropped() rather than Box_Pushed(). Thisdeeper effect is created by using a two-pixelrectangular border surrounding the subject.Box_Raised() is an seemingly extended function over Box_Popped() in that a"higher" effect is created by using Box_Raised() rather than Box_Popped().This higher effect is created by using a two-pixel rectangular bordersurrounding the subject..in -5CAVEATS.in +5These functions (Box_Pushed, Box_Popped, Box_Dropped andBox_Raised) do not have checking to see that x1-y2coordinates are more upper and left than the x2-y2coordinates.  Therefore, the programmer using thesefunctions must make certain of this him/herself..in -5.pgNAME.ti +5Square - Draws a rectangular box in one of four modesSYNOPSIS.in +5.nf#include <gui.h>Square(wpath,act,color,x1,y1,x2,y2)int wpath,act,color,x1,y1,x2,y2.fi.in -5DESCRIPTION.in +5Square() is a slightly redundant function in that manyof the operations that it performs can be just as easilyaccomplished with one or two already existing functionseither in GUI.L or CGFX.L (which is not required to runGUI.L functions).The parameter "act" defines one of four actions to beperformed by Square(). Below is a list of options forthat act parameter:.in +10.nf| Option   | Value | Color ||----------+-------+-------|| S_FILLED |   0   |  Yes  || S_RAISED |   1   |  Yes  || S_PUSHED |   2   |  No   || S_POPPED |   3   |  No   |.fi.in -10The integer coordinates x1-y1 represent the upper-leftcorner of the figure and coordinates x2-y2 are thelower-right.  In in table above, note the columnlabelled "color".  This column indicates whether theparameter "color" has any effect on the outcome of thefunction..in -5CAVEATS.in +5There is no checking to see if the x1-y1 coordinates arethe most upper and left in comparison to x2-y2coordinates.  This is left to the programmer so thatGUI.L may be as small and tight as possible..in -5.pgNAME.ti +5Title - Draws a title "plaque" on screenSYNOPSIS.in +5.nf#include <gui.h>Title(wpath,name,x,y,len,act)int wpathchar *nameint x,y,len,act.fi.in -5DESCRIPTION.in +5Title() creates a "button figure" with the label definedby "name" at CHARACTER coordinates "x" and "y".  Notethat these are character coordinates. This is primarilydue to the fact that text printed inside the buttonfigures are, in fact, real text printed using the writefunction as opposed to treating the characters in a GPbuffer fashion.  As a result of this, the actualcharacters are printed at the position specified by Xand Y.  The rest of the title drawn is one-half acharacter space above, below, right and left of theregion specified by x,y,len.The Title() function generates figures similarappearance to "buttons" with a few exceptions.  The mostobvious difference is the change in background colorsused.  If the parameter "act" is set to a non-zero,black is the color of the characters in thie titlefigure, else white is used.  Also, if "act" is anon-zero, then the title is drawn in a "dropped"position, else the raised position is used.Even though the apparent structure format is similar tothat of "Button()", there is no handler support in thesame way as for button.  This is primarily since a"title" is not essentially an "object" where a buttonis.  This does not prevent a clever programmer fromdoing this himself, however..in -5CAVEATS.in +5Do not specify a value of zero to either "x", "y" or"len" parameters.  This will not return an error, but itwill create unfavorable results on the display..in -5.pgNAME.ti +5Arrow - Generates an "arrow" type buttonSYNOPSIS.in +5.nf#include <gui.h>Arrow(wpath,face,x,y)int wpath,face,x,y.fi.in -5DESCRIPTION.in +5Arrow() is a function generally used in conjunction withslide bars, though they are also easily used alone.  Xand Y coordinates passed to this function are expectedto be "character oriented" coordinates and as with ALLother character oriented coordinates, it's NOTrecommended that a value of 0 (zero) be used as either Xor Y.  The value "face" tells Arrow() to draw an arrowfigure pointing in one of four directions..in +10.nf#define   A_UP       0#define   A_DOWN     1#define   A_RIGHT    2#define   A_LEFT     3.fi.in -10Since the coordinates are "character oriented" it'simportant to note that an arrow button takes half acharacter space above, below, left and right thecharacter coordinates passed to the Arrow() function. This helps in creating a tight appearance when objectsare prented to the screen.  Just make certain that thereis a one-character space between any two characteroriented objects..in -5.pgNAME.in +5.nfMakeBar - Creates a slide-bar device on screenMoveBar - Updates a slide-bar device on screen.in -5SYNOPSIS.in +5#include <gui.h>MakeBar(wpath,dir,x,y,len)int wpath, dir,x,y,lenMoveBar(wpath,dir,x,y,len,percent)int wpath, dir,x,y,len,percent.fi.in -5DESCRIPTION.in +5MakeBar() will create a slide-bar device on the screenusing the information passed to it as a parameter.  Theparameter "dir" indicates the direction of the barwhether it's horizontal or vertical..in +10.nf#define   B_HORIZ    0#define   B_VERT     1.fi.in -10The character coordinates X and Y indicate where on thescreen the bar is to start and "len" indicates how long(in character sized increments) the bar is supposed tobe.All the same information applies to MoveBar() as inMakeBar().  In addition, the "percent" parameter (0-99)indicates to MoveBar where the button-indicator is to beplaced on the bar.A bar must first be initialized using MakeBar() beforecalling MoveBar()..in -5CAVEATS.in +5As with all other character-coordinated GUI devices, anX or Y coordinate value of ZERO will yield unfavorableresults on the screen.  In addition, the programmer musttake care with the value of length that it does notextend to the far edge of the screen (character position39 on a 40 column screen for example).  Unfavorableresults will occur.  This is all due to the fact that aswith ALL character coordinated GUI devices have aone-half character size border around all dimensions ofthe parameter coordinates given..in -5.pgNAME.in +5.nfDef_BT - A high-level button data structure loaderDef_BR - A high-level slide-bar data structure loaderDef_A  - A high-level arrow data structure loaderDef_TL - A high-level title data structure loader.in -5SYNOPSIS.in +5#include <gui.h>Def_BT(but,name,x,y,size)BUTTON *butchar *nameint x,y,sizeDef_BR(bar,dir,x,y,len)BAR *barint dir,x,y,lenDef_A(arw,dir,x,y)ARROW *arwint dir,x,yDef_TL(ttl,name,x,y)TITLE *ttlchar *nameint x,y.fi.in -5DESCRIPTION.in +5The Def_BT() function will copy the parameters passedto it into the data structure indicated by theparameter "but".  The structure for "but" should be of type BUTTON as definedin gui.h.This function was designed with thepurpose of programming ease in mind.  It also provides aconvenient interface for defining and changing buttonattributes as well as allowing for more readable code.The button length parameter is determined by the lengthof the string passed to this function as "name".  If alonger button is needed using this function, the stringmust be padded with SPACE characters so that thestring's length is equal to the button length needed.A "size" defined as "BT_REG" is a regular sized buttonand "BT_BIG" is a double height button where an extraline is allocated to create a larger (more important!)button..ne 2The data structure passed to this function ("but") willbe modified to suit the criteria specified by theparameters of this function.  This data structure may beused by other high-level button functions such asMan_BT() and Check_BT().Def_BR() is a function designed to load "BAR" data structuresfrom a single command line function.  The "bar" pointer parameterdefines which structure is to be loaded.  The "bar" structureshould be of type BAR as defined in gui.h.The parameters "dir","x", "y" and "len" are all the data information to be copiedinto the indicated data structure segment.The "dir" parameter defines the type of slide-bar this will bewhere the following is true..in +10.nf#define   B_HORIZ    0#define   B_VERT     1.fi.in -10The parameters x and y define the bar's beginning coordinates andlen will become the bar's length value.  The coordinates andlength values are all in terms of character type coordinates.Def_A() is a function designed as an easy loader for data inan ARROW type data structure as defined in gui.h.The parameter arw is a pointerto the data structure to be loaded.  The values in "dir", "x" and"y" are the values to be copied into the target data structure.The "dir" parameter defines the direction the arrow device is topoint where the following is true..in +10.nf#define   A_UP       0#define   A_DOWN     1#define   A_RIGHT    2#define   A_LEFT     3.fi.in -10The coordinate values of the arrow device defined are found inthe values "x" and "y".  These values are character type coordinates.The Def_TL() function's purpose is to copy data passed to it asa parameter set, into a TITLE type data structure as defined in gui.h and indicated by thepointer value "ttl" also passed to Def_TL() as a parameter..ne 10The pointer parameter "name" is a pointer to a string (or characterarray).  This string is copied into the name portion of the TITLEdata structure pointed to by "ttl".  In addition, the "length"information to be copied into the data packet is derived from thelength of the "name" string.  (Therefore, if a title of a longersize than the "name" is needed, the string must be padded withSPACE characters.)  And finally, the "x" and "y" values are alsocopied into the "x" and "y" coordinate information of the TITLEdata packet.  It's also important to note these coordinates arecharacter coordinates..in -5.pgNAME.in +5.nfMan_BR - Creates/Updates a bar from bar structureMan_BT - Creates/Updates a button from button structureMan_A  - Creates an arrow button from arrow structureMan_WN - Creates a filled window of specified color.in -5SYNOPSIS.in +5#include <gui.h>Man_BR(wpath,bar,act)int wpathBAR *barint actMan_BT(wpath,but,act)int wpathBUTTON *butint actMan_A(wpath,arw)int wpathARROW *arwMan_WN(wpath,x1,y1,x2,y2,act,color)int wpath,x1,y1,x2,y2,act,colorMan_TL(wpath,ttl,act)int wpathTITLE *ttlint act.fi.in -5DESCRIPTION.in +5The Man_BR() function is designed as a high-levelslide-bar handler that will create and update a menu barin accordance with the information given in the bar'sdata structure passed to it as a parameter ("bar").  Theparameter "act" specifies either to initialize the barwith a value of -1 ("_INIZ_") or a percentage value(0-99%) at which to place the indicator button.Man_BT() is a function designed for easy manipulationof a button on screen. With this, button statistics canbe updated and the button on-screen can becreated/updated all at one time with one simple command.One typical implementation of this function is:.ti +10Man_BT(wpath,but,Toggle(but))The result of this function is that Man_BT() willupdate the button specified by "but" (pointer to thebutton structure).  The update is accomplished when thefunction (actually, a macro) Toggle() returns theopposite of the button's current state (OFF or ON). Then the new value is stored and a new button state isdrawn.Man_A() is, perhaps, the most simple of the high-levelfunctions.  This function, after accepting anarrow-button's data structure, will draw the arrow inits appropriate position and pointing in the appropriatedirection.Man_WN() is the "window" helper function.  Thisfunction, for convenience's sake, is also acharacter-oriented function unlike its low-levelcounter-part, Window(), whose coordinates are notcharacter oriented.  This serves to assist theprogrammer by keeping figures in even increments so thattext character alignment will easily match up with otherscreen-layout plans.  It also serves (without gettingtoo technical) to make the various drawing operationsrun much faster than those not executed on "even"coordinates.The coordinates x1 and y1 are character coordinates andare expected to be the upper-left corner coordinates ofthe figure to be drawn.  The character coordinates x2and y2 are likewise expected to be the lower-rightcorner of the figure.  No checking to assure this istrue is performed in this function so that leaves thistask to the programmer.  The parameter "color" can be avalue of 0-15 to be one of sixteen palettes availableunder a type 8 window. If any other type of window is inuse, OS9 will use the appropriate color within its ownlimits.  And finally, the parameter "act" represents oneof eight possible actions for Man_WN() to perform. They are outlined as follows:.in +10.nf 0    W_FRAMED 1    W_RAISED 2    W_DROPPED 3    W_SHADOWED10    EW_FRAMED      ETCHED & framed11    EW_RAISED      ETCHED & raised12    EW_DROPPED     ETCHED & droppeded13    EW_SHADOWED    ETCHED & shadowed.fi.in -10.ne 10Man_TL() is a function designed to use the data packetprovided to it in the form of a TITLE *pointer and aparameter "act" to draw and update a "title" device onthe window specified by wpath.  The parameter "act" isalso updated into the TITLE data structure.The following are valid "act" arguments..in +10.nf#define   _INIZ_    -1#define   _ON_       1#define   _OFF_      0.fi.in -15.pgNAME.in +5.nfCheck_BT - Check to see if mouse is on buttonCheck_A  - Check to see if mouse is on arrowCheck_BR - Check to see if mouse is on bar.in -5SYNOPSIS.in +5#include <gui.h>int Check_BT(wpath,but,mox,moy)int wpathBUTTON *butint mox,moyint Check_A(wpath,arw,mox,moy)int wpathARROW *arwint mox,moyint Check_BR(wpath,bar,mox,moy)int wpathBAR *barint mox,moy.in -5.fiDESCRIPTION.in +5The Check_BT() function is a simple function (especiallydesigned for the programmer's ease in mind) that willcheck to see if the mouse is pointing on the buttonspecified by the parameter "but".  The mouse's X and Ycoordinates are passed to this function via theparameters "mox" and "moy".  This route was taken ratherthan automatically knowing where the mouse is so thatother forms of input will be allowed easily.  Thisroutine, by comparing the button's location [informationin the button data structure] with the X and Ycoordinates supplied by "mox" and "moy" simplydetermines if the mouse is there or not and returns a 1(one) if true and a 0 (zero) if false.Check_A() is an identical function to Check_BT() in alloperations.  It's only essential difference is that itexpects to see an ARROW ("arw") data structure passed toit.Finally, the Check_BR() function accepts the same inputparameters as both Check_BT() and Check_A(), but returnsinformation differently than the two previouslymentioned functions.  Check_BR() returns a -1 if themouse is not on the slide bar.  If it is, it will returna value of 0-99 to represent the percentage portion ofthe bar the mouse was on..in -5.pgNAME.in +5.nfCkButn - Returns status of button from data structureToggle - Returns opposite status of button from data structure.in -5SYNOPSIS.in +5#include <gui.h>CkButn(but)BUTTON *butToggle(but)BUTTON *but.in -5.fiDESCRIPTION.in +5The function CkButn() (actually a macro definition ingui.h) will return the "bt_act" status information fromthe button data structure specified by the parameter*but.  This is accomplished in the following manner:.in +10#define CkButn(a) (a)->bt_act.in -10The function Toggle() (also a macro) is an extensionover the CkButn() macro. This macro will return theopposite status of the button specified by the parameter*but.  This macro reads as follows:.in +10#define Toggle(a) (CkButn(a))?0:1.in -15.pgNAME.ti +5WallPaper - covers the screen with specified iconSYNOPSIS.in +5.nfWallPaper(wpath,filename)int wpathchar *filename.in -5.fiDESCRIPTION.in +5WallPaper() is a function that will "cover" the screen with a specifiedgraphics icon.  This icon is specified by the filename which is pointedto by *filename.This function can be very useful, for example, when you wish to create atextured background.  Commonly, a "fill-pattern" would be used, but thisis a very slow way to do this.  Using a "pattern icon" the screen can befilled at many times the normal rate.The variable filename is the filename or path pointing to where the iconfile to be used is located.   If the filename specified is not found then WallPaper() will look in the current working directory for a file called "wall.ike" this is the default filename for gui's wallpaper.  Ifneither of the files are not present then WallPaper() will use a defaulticon that is imbedded in it's self which is a cross hatch type patter.This pattern will always be available to WallPaper().The icon file's format is as follows:.nf.in +10Offset | Bytes | Purpose_______|_______|______________ 00    | 01    | Screen type 01    | 02    | Pixels Across 03    | 02    | Pixels Down 05    | 02    | Size of Data 07    | xxxxx | Icon Data.in -10.fiIf this format looks familiar, it's because it's the same format as usedby MVCanvas' CLP and is the proposed standard for graphics "clipboard"format.  This format was chosen because it is more standard and easier toload..pg.cePUTTING IT ALL TOGETHERNow that you have the tools, let's talk about how to use them more.  Thissection will focus on how you may put these tools together in such a way thatit yields tight, efficient code with eye-pleasing results.SPEEDTo help increase the speed at which gui writes to the screen you can make sure that you are using a non scaled type window.  Be sure that GuiSet()  was with an option of 0 for SCALE.  Also if you turn off the graphics cursor during times of heavy screenupdating it will help to speed up gui.l and also any other graphics..ceGROUPINGAfter looking at a few examples and already existing programs utilizing theGUI library you will develop an idea about how you want your programs to lookas well.  With a few simple techniques, you can create and update really sharplooking GUIs for your software.One technique that I use, I call "grouping."  When you plan to have a group ofdevices "packed" together in a group or block, it often helps to "link" themtogether by making thier X-Y locations "relative" to a given set of X-Yvariables.  By utilizing this method, entire blocks of devices can berelocated on your GUI screen by changing only as few as two or three variableswithin your program!  The following code fragments are examples of thistechnique..in +3/* The variable array arw[] is assumed to be defined already previously inthis program as type "ARROW".  The same applies to the array bmp[] which isdefined as type "BAR". */.nfmx=5; my=8;  /* The "main" X Y coordinate values */length=8;arw[1].ar_dir=A_LEFT;/* arw[1] represents left arrow  */arw[1].ar_x=mx;      /* in the common arrow-bar-arrow */arw[1].ar_y=my;      /* setup.  Note the use of "mx"  */                     /* and "my"!                     */bmp[0].br_dir=B_HORIZ;/* This segment sets values to  */bmp[0].br_x=mx+2;     /* bar data struct for bmp[0].  */bmp[0].br_y=my;       /* Note how bar's X and Y loca- */bmp[0].br_len=length; /* tion info is made relative   */bmp[0].br_act=_INIZ_; /* to a common reference point  */                      /* (mx/my) but LENgth is left   */                      /* to its own value.            */arw[0].ar_dir=A_RIGHT;  /* In the right arrow's setup */arw[0].ar_x=mx+length+3;/* the X coordinate is made   */arw[0].ar_y=my;         /* relative to both "mx" and  */                        /* "length" so it is always   */                        /* placed at the bar's end.   */.fi.in -5In the example above, you should notice how the X and Y coordinate informationis all made relative to the variables "mx", "my" and "length".  If, for somereason I wish this "arrow-bar-arrow" configuration to be relocated on thescreen, this is very easily accomplished by altering the values of mx, my andlength.  It is important to note that by changing the length of the bar to belonger or shorter does NOT change the functionality of the program alreadywritten!  This exciting fact is due to the fact that values on the bar aremanipulated in terms of "percent" rather than an absolute value.In the example below, a group of buttons are defined, using the high-levelbutton definition function Def_BT(), with thier X and Y coordinates relativeto the values "mx" and "my"..in +5.nfmx=7; my=12; /* main point of reference */Def_BT(&b[0],"1",mx,my,BT_REG);Def_BT(&b[1],"2",mx+2,my,BT_REG);Def_BT(&b[2],"3",mx+4,my,BT_REG);Def_BT(&b[3],"Lock ",mx,my+2,BT_REG);.in -5.fiOnce displayed, you would see how useful this technique could be when you wantto update the appearance of your GUI.  An keep in mind that this will notchange the way your program runs at ALL!  With a little trial, I think youwill agree that this is exactly the kind of mouse-driven programming interfacethat many people have been looking for; an *EASY* way to draw buttons, boxes,bars and other devices without complex program code to utilize them.  Andwhere ease of program maintainence is concerned, this technique is eveneasier..ceARRAYSWhile it's possible to handle all buttons individually and with moredescriptive names (for example: BUTTON quit_button;), processing input fromnumerous buttons can create large object code and much tedium when writing thecode to handle these.  This is not to mention the tedium and extra programspace wasted drawing the numerous buttons individually.  The following exampleshould serve to illustrate my point..nf.in +10.ne 13Man_BT(wpath,&quit,_INIZ_);Man_BT(wpath,&pause,_INIZ_);Man_BT(wpath,&speed,_INIZ_);Man_BT(wpath,&level,_INIZ_);Man_BT(wpath,&load,_INIZ_);Man_BT(wpath,&save,_INIZ_);Man_BT(wpath,&restart,_INIZ_);Man_BT(wpath,&help,_INIZ_);.ti -5The above could be replaced by the following:for(idx=0; idx<8; idx++)   Man_BT(wpath,&butn[idx],_INIZ_);.in -10.fiA similar loop structure could be implemented for checking an array of buttonson the screen.While admittedly, using these arrays in this manner make code less readableand harder to remember a week from now what array element went to what button,using this method of handling will pay off by allowing you to fit more intoyour limited 64k workspace..cePLANNINGThere is no programming aid available in the world on any computer yetavailable that will compensate for poor planning.  As computers have sincethier introduction, they only do what they are told.Although gui.l helps to create a display that may appear three-dimentional,it does not manage an environment of more than one layer.  This means, thatthe programmer must ensure that things drawn in the background are drawnfirst and those in the foreground last.Additionally, all dimensions of an object must be taken into account whenassigning them locations on the display.  This is mainly to avoid deviceoverlapping, but will also avoid program function errors that may likelyoccur as a result.Traditionally, when a graphical environment such as the type supported bygui.l is generated, there are generally two areas on the screen.  First shouldbe the "working area" and second should be the "control area."  Using thistype of display formatting will assist in keeping the environment clear andintuitive for the user.  Additionally, if controls (ie buttons, gadgets etc)are scattered throughout the screen, your display will appear overly complexand confusing which is the exact opposite of what a GUI is supposed toaccomplish.Finally, since gui.l supplies the functionality to move devices on the screenwithout affecting the program's operability, you should try many possiblescreen layouts before settling on one.  The possibilities are almost endlesswhere the look and feel of a display is concerned.