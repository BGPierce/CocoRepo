PROCEDURE GuiBREM *REM *    GuiB: GUI 1.1 for Basic09 01.00.01.REM *REM *    To be run under OS-9 Level II 02.00.01 and REM *    GShell+ 1.24.REM *REM *REM *    Designed by Shawn Driscoll, (C) 1991.REM *REM *REM *    PURPOSE:REM *    This module makes the programmer's life a littleREM *    easier when it comes to designing layouts forREM *    new applications.  This KISSable (Keep It Simple,REM *    Stupid!) GUI has a more modern look to it when REM *    compared to Multi-Vue's interface.REM *REM *REM *    USAGE:REM *    GuiB was designed to be a seperate executionREM *    module in a programmer's CMDS directory.  TheREM *    module should not be merged with any programs.REM *REM *REM *    The Basic09 execution format for GuiB is:REM *REM *      RUN GuiB(string1,string2,integer1,integer2,REM *               integer3,integer4)REM *REM *    Both string1 and string2 have a length of 60REM *    characters.REM *REM *REM *    This version of GuiB is designed to run on type 8,REM *    non-scaled windows only.REM *REM *REM *    A little history:REM *REM *    1.0 -- GuiB was released to the programming public.REM *REM *    1.1 -- The commands: TITLE, SQUARE, ARROW, MAKEBAR, REM *           and MOVEBAR were added to the interface.  REM *           The flags "DROPPED" and "ETCHED" were addedREM *           to the window commands.REM *           REM *           MINOR CHANGES:REM *           The buttons are now 16 pixels wide insteadREM *           of 15.REM *           The buttons and windows have borders thatREM *           are 2 pixels wide instead of 1.REM *    REM *REM *    It is recommended that Syscall and Gfx2 be mergedREM *    with RunB for this module to work properly.REM *    StdPats_16 should be merged into memory beforeREM *    using GuiB.REM *REM *    This code can be given away to other programmersREM *    to use.  Programmers may modify the code to theirREM *    liking.  There is still room for improving GuiB.REM *    Please pass on any change ideas to the authorREM *    at DELPHI, username: EARTHER.  Or at home:REM *    (619)589-9496REM *                            Thank you.REM * REM *PARAM string1,string2:STRING[60]PARAM integer1,integer2,integer3,integer4:INTEGERTYPE registers=cc,a,b,dp:BYTE; x,y,u:INTEGERTYPE mouse_packet=valid,actv:BYTE; reserved1(3):INTEGER; cbsa,cbsb
:BYTE; reserved2(4),bdx,bdy:INTEGER; stat,res:BYTE; acx,acy,wrx,wry
:INTEGERDIM regs:registersDIM mouse:mouse_packetDIM code,width:BYTEDIM x1,x2,x3,y1,y2,y3:INTEGERREM Mouse status.IF string1="MOUSE" THEN IF string2="CLICK" THEN regs.a=1regs.b=$89regs.x=ADDR(mouse)regs.y=0code=$8DRUN syscall(code,regs)IF mouse.valid=0 THEN REM Mouse sleeps for awhile.regs.x=20code=$0ARUN syscall(code,regs)integer1=0integer2=0END ELSE integer1=mouse.cbsainteger2=mouse.cbsbREM integer3=mouse.bdx/2REM integer4=mouse.bdyinteger3=mouse.wrxinteger4=mouse.wryEND ENDIF ENDIF IF string2="ON" THEN regs.a=1regs.b=$89regs.x=$030Aregs.y=1code=$8ERUN syscall(code,regs)END ENDIF IF string2="OFF" THEN regs.a=1regs.b=$89regs.x=$030Aregs.y=0code=$8ERUN syscall(code,regs)END ENDIF ENDIF REM Move bar.IF string1="MOVEBAR" THEN x1=integer1+4 \y1=integer2+4IF string2="HORIZ" THEN x2=integer1+integer3-5y2=y1+7x3=integer4*(x2-7-x1)/100.+x1y3=y1ELSE IF string2="VERT" THEN x2=x1+7y2=integer2+integer3-5y3=integer4*(y2-7-y1)/100.+y1x3=x1ENDIF ENDIF RUN gfx2("color",12)RUN gfx2("bar",x1,y1,x2,y2)RUN gfx2("color",13,12)RUN gfx2("pattern",205,1)RUN gfx2("bar",x1,y1,x2,y2)RUN gfx2("pattern",0,0)x1=x3 \y1=y3x2=x1+7y2=y1+7RUN gfx2("color",12)RUN gfx2("bar",x1,y1,x2,y2)GOSUB 100END ENDIF REM Display button.IF string1="BUTTON" THEN RUN gfx2("curxy",integer1,integer2)x1=integer1*8-4 \y1=integer2*8-4x2=x1+integer4*8+7 \y2=y1+15IF integer3=0 THEN RUN gfx2("color",15,12)PRINT string2; GOSUB 100END ELSE RUN gfx2("color",14,12)PRINT string2; GOSUB 110END ENDIF ENDIF REM Set up bar.IF string1="MAKEBAR" THEN x1=integer1y1=integer2IF string2="HORIZ" THEN x2=x1+integer3-1y2=y1+15ELSE IF string2="VERT" THEN x2=x1+15y2=y1+integer3-1ENDIF ENDIF GOSUB 100x1=integer1+2y1=integer2+2IF string2="HORIZ" THEN x2=x1+integer3-5y2=y1+11ELSE IF string2="VERT" THEN x2=x1+11y2=y1+integer3-5ENDIF ENDIF GOSUB 110END ENDIF REM Display an arrow.IF string1="ARROW" THEN x1=integer1 \y1=integer2x2=integer1+15 \y2=integer2+15GOSUB 100x1=integer1 \y1=integer2x2=integer1+15 \y2=integer2+15IF string2="UP" THEN RUN gfx2("color",14)RUN gfx2("line",x1+8,y1+5,x1+11,y1+10)RUN gfx2("line",x1+4,y1+10)RUN gfx2("color",15)RUN gfx2("line",x1+7,y1+5)GOSUB 140END ENDIF IF string2="DOWN" THEN RUN gfx2("color",14)RUN gfx2("line",x1+8,y1+10,x1+11,y1+5)RUN gfx2("color",15)RUN gfx2("line",x1+4,y1+5)RUN gfx2("line",x1+7,y1+10)GOSUB 140END ENDIF IF string2="RIGHT" THEN RUN gfx2("color",14)RUN gfx2("line",x1+10,y1+8,x1+5,y1+11)RUN gfx2("color",15)RUN gfx2("line",x1+5,y1+4)RUN gfx2("line",x1+10,y1+7)GOSUB 140END ENDIF IF string2="LEFT" THEN RUN gfx2("color",14)RUN gfx2("line",x1+5,y1+8,x1+10,y1+11)RUN gfx2("line",x1+10,y1+4)RUN gfx2("color",15)RUN gfx2("line",x1+5,y1+7)GOSUB 140END ENDIF ENDIF REM Beautify a window.IF string1="WINDOW" THEN x1=integer1y1=integer2x2=integer1+integer3-1y2=integer2+integer4-1IF string2="FRAMED" THEN width=4GOSUB 100x1=integer1+width \y1=integer2+widthx2=integer1+integer3-1-width \y2=integer2+integer4-1-widthGOSUB 110END ENDIF IF string2="OUTLINED" OR string2="RAISED" THEN GOSUB 100END ENDIF IF string2="DROPPED" THEN GOSUB 110END ENDIF IF string2="SHADOWED" THEN RUN gfx2("color",15)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",14)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)x1=x1+1y1=y1+1x2=x2-1y2=y2-1GOSUB 100END ENDIF IF string2="ETCHED" THEN GOSUB 130x1=x1+1y1=y1+1x2=x2-1y2=y2-1GOSUB 120END ENDIF ENDIF REM Draw a square.IF string1="SQUARE" THEN x1=integer1y1=integer2x2=integer1+integer3-1y2=integer2+integer4-1IF string2="POPPED" THEN GOSUB 120END ENDIF IF string2="PUSHED" THEN GOSUB 130END ENDIF IF string2="FILLED" THEN RUN gfx2("bar",x1,y1,x2,y2)END ENDIF IF string2="OUTLINED" THEN RUN gfx2("box",x1,y1,x2,y2)END ENDIF ENDIF REM Display window title.IF string1="TITLE" THEN RUN gfx2("curxy",integer1,integer2)x1=integer1*8-4 \y1=integer2*8-4x2=x1+integer4*8+7 \y2=y1+15RUN gfx2("color",13)RUN gfx2("bar",x1,y1,x2,y2)RUN gfx2("color",14,13)PRINT string2; IF integer3=0 THEN GOSUB 100ELSE GOSUB 110ENDIF END ENDIF REM Verify version 1.1REM NOTE: Programs needing 1.0REM will work with 1.1IF string1="VERSION" THEN integer3=1integer4=1IF integer1=1 AND integer2<=1 THEN string2="GOOD"ELSE string2="BAD"ENDIF END ENDIF RUN gfx2("bell")RUN gfx2("color",14,15)PRINT PRINT "Command error in GuiB module!"STOP END REM Draw a raised box.100 RUN gfx2("color",15)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",14)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)x1=x1+1y1=y1+1x2=x2-1y2=y2-1RUN gfx2("color",13)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",12)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)RETURN REM Draw a dropped box.110 RUN gfx2("color",14)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",13)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)x1=x1+1y1=y1+1x2=x2-1y2=y2-1RUN gfx2("color",12)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",15)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)RETURN REM Draw a popped box.120 RUN gfx2("color",13)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",14)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)RETURN REM Draw a pushed box.130 RUN gfx2("color",14)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",13)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)RETURN REM Fill in arrow.140 RUN gfx2("pattern",205,1)RUN gfx2("color",13,12)RUN gfx2("fill",x1+8,y1+8)RUN gfx2("pattern",0,0)RETURN END 