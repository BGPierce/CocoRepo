PROCEDURE guibREM *REM *    GuiB: GUI Tools 3.0 for Basic09.REM *REM *    To be run under OS-9 Level II and Multi-Vue. REM *REM *REM *    Designed by Shawn Driscoll, (c) 1992.REM *    Additional Code by Br. Jeremy, CSJW (c)1993REM *REM *    PURPOSE:REM *    This module allows programmers to design GUI'sREM *    for OS-9.  This KISSable (Keep It Simple,REM *    Stupid!) code makes use of modern lookingREM *    tools that outshine WindInt's abilities.REM *REM *REM *    USAGE:REM *    GuiB was designed to be merged with applicationREM *    modules (such as IconMan) that will make callsREM *    to it during their execution.REM *REM *REM *    The Basic09 execution format for GuiB is:REM *REM *      RUN GuiB(string1,string2,integer1,integer2,REM *               integer3,integer4)REM *REM *    Both string1 and string2 have a length of 60REM *    characters.REM *REM *REM *    This version of GuiB is designed to run on type 6,REM *    7, and 8 non-scaled windows only.REM *REM *REM *    A little history:REM *REM *    1.0 -- GuiB was released to the programming public.REM *REM *    1.1 -- The commands: TITLE, SQUARE, ARROW, MAKEBAR, REM *           and MOVEBAR were added to the interface.  REM *           The flags "DROPPED" and "ETCHED" were addedREM *           to the window commands.REM *           REM *           MINOR CHANGES:REM *           The buttons are now 16 pixels wide insteadREM *           of 15.REM *           The buttons and windows have borders thatREM *           are 2 pixels wide instead of 1.REM *REM *    2.0 -- The pattern routine was refined a bit.REM *           The "GADGET" command was added.REM *           Error trapping was added.REM *           Licensed to MV Systems.REM *REM *    2.1 -- GuiB was put back into the public domain.REM *REM *    3.0 -- Additions by Br. Jeremy, CSJWREM *           Additional Gadgets: BULLET and CLICKBOXREM *           were added to the "GADGET" command.REM *           The "ELINE" command was added.REM *           Additional Windows: "CARVED" and REM *           "PICFRAME" were addedREM *REM *    It is recommended that GFX2, SYSCALL, and INKEY be REM *    merged with RunB for this module to work properly.REM *REM *    StdPats_4 & 16 should be merged into memory  REM *    at startup before using GuiB.REM *REM * PARAM string1,string2:STRING[60]PARAM integer1,integer2,integer3,integer4:INTEGERTYPE registers=cc,a,b,dp:BYTE; x,y,u:INTEGERTYPE mouse_packet=valid,actv:BYTE; reserved1(3):INTEGER; cbsa,cbsb:BYTE; reserved2(4),bdx,bdy:INTEGER; stat,res:BYTE; acx,acy,wrx,wry:INTEGERDIM regs:registersDIM mouse:mouse_packetDIM x1,x2,x3,y1,y2,y3:INTEGERDIM radius,xcor,ycor,xrad,yrad,xrad1,yrad1,mx,my,mx1,my1,xcor1,ycor1,xcor2,ycor2:INTEGERREM Mouse status.IF string1="MOUSE" THEN IF string2="CLICK" THEN regs.a=1regs.b=$89regs.x=ADDR(mouse)regs.y=0RUN syscall($8D,regs)IF mouse.valid=0 THEN REM Mouse sleeps for awhile.regs.x=20RUN syscall($0A,regs)integer1=0integer2=0END ELSE integer1=mouse.cbsainteger2=mouse.cbsbinteger3=mouse.wrxinteger4=mouse.wryEND ENDIF ENDIF IF string2="ON" THEN regs.a=1regs.b=$89regs.x=$030Aregs.y=1RUN syscall($8E,regs)END ENDIF IF string2="OFF" THEN regs.a=1regs.b=$89regs.x=$030Aregs.y=0RUN syscall($8E,regs)END ENDIF ENDIF ON ERROR GOTO 180REM Update scroll bar.IF string1="MOVEBAR" THEN x1=integer1+4 \y1=integer2+4IF string2="HORIZ" THEN x2=integer1+integer3-5y2=y1+7x3=integer4*(x2-7-x1)/100.+x1y3=y1ELSE IF string2="VERT" THEN x2=x1+7y2=integer2+integer3-5y3=integer4*(y2-7-y1)/100.+y1x3=x1ENDIF ENDIF RUN gfx2("color",12)RUN gfx2("bar",x1,y1,x2,y2)GOSUB 170RUN gfx2("color",13)RUN gfx2("bar",x1,y1,x2,y2)RUN gfx2("pattern",0,0)x1=x3 \y1=y3x2=x1+7y2=y1+7RUN gfx2("color",12)RUN gfx2("bar",x1,y1,x2,y2)GOSUB 100END ENDIF REM Display button.IF string1="BUTTON" THEN RUN gfx2("curxy",integer1,integer2)x1=integer1*8-4 \y1=integer2*8-4x2=x1+integer4*8+7 \y2=y1+15IF integer3=0 THEN RUN gfx2("color",15,12)PRINT string2; GOSUB 100END ELSE RUN gfx2("color",14,12)PRINT string2; GOSUB 110END ENDIF ENDIF REM Display a gadget.IF string1="GADGET" THEN IF string2="DIAMOND" THEN RUN gfx2("color",13)RUN gfx2("line",integer1,integer2-5,integer1+6,integer2)RUN gfx2("line",integer1,integer2+5)RUN gfx2("line",integer1-5,integer2)RUN gfx2("color",14)RUN gfx2("line",integer1,integer2-5)IF integer3=1 THEN RUN gfx2("color",15)RUN gfx2("line",integer1,integer2-2,integer1+3,integer2)RUN gfx2("line",integer1,integer2+2)RUN gfx2("line",integer1-2,integer2)RUN gfx2("line",integer1,integer2-2)RUN gfx2("fill",integer1,integer2)ELSE RUN gfx2("color",12)RUN gfx2("fill",integer1,integer2)ENDIF END ENDIF ENDIF IF string2="BULLET" THEN IF integer3=1 THEN REM Clicked BulletRUN gfx2("color",15) \radius=8RUN gfx2("circle",integer1,integer2,radius)RUN gfx2("color",13)RUN gfx2("circle",integer1,integer2,radius-1)RUN gfx2("Fill",integer1,integer2)mx1=integer1+2 \my1=integer2xrad1=radius \yrad1=radius/2RUN gfx2("COLOR",14)RUN gfx2("arc",mx1,my1,xrad1,yrad1,3,0,0,3)RUN gfx2("color",14) \radius=radius-2RUN gfx2("circle",integer1,integer2,radius)RUN gfx2("Color",14)RUN gfx2("circle",integer1,integer2,radius)RUN gfx2("Color",15)RUN gfx2("fill",integer1,integer2)ELSE REM Raised BulletRUN gfx2("color",15) \radius=8RUN gfx2("circle",integer1,integer2,radius)RUN gfx2("color",13)RUN gfx2("circle",integer1,integer2,radius-2)RUN gfx2("Fill",integer1,integer2)mx1=integer1+2 \my1=integer2xrad1=radius \yrad1=radius/2RUN gfx2("COLOR",14)RUN gfx2("arc",mx1,my1,xrad1,yrad1,3,0,0,3)RUN gfx2("color",15) \radius=radius-2RUN gfx2("circle",integer1,integer2,radius)RUN gfx2("Color",15)RUN gfx2("circle",integer1,integer2,radius)RUN gfx2("Color",14)RUN gfx2("fill",integer1,integer2)RUN gfx2("color",15)ENDIF END ENDIF REM Display a clickboxIF string2="CLICKBOX" THEN x1=integer1-2y1=integer2-2x2=x1+8y2=y1+8RUN gfx2("color",14)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",15)RUN gfx2("line",x1,y1,x1,y2-1)RUN gfx2("line",x1,y1,x2-1,y1)RUN gfx2("color",13)RUN gfx2("line",x2-1,y1+1,x2-1,y2-1)RUN gfx2("line",x1+1,y2-1)IF integer3=1 THEN RUN gfx2("color",15)RUN gfx2("fill",x1+1,y1+1)ELSE RUN gfx2("color",14)RUN gfx2("fill",x1+1,y1+1)RUN gfx2("color",15)RUN gfx2("line",x1,y1,x1,y2-1)RUN gfx2("line",x1,y1,x2-1,y1)ENDIF END ENDIF REM Etched LinesIF string1="ELINE" THEN x1=integer1y1=integer2IF string2="HORIZ" THEN x2=x1+integer3y2=y1GOSUB 140END ENDIF IF string2="VERT" THEN x2=x1y2=y1+integer3GOSUB 150END ENDIF ENDIF REM Set up bar.IF string1="MAKEBAR" THEN x1=integer1y1=integer2IF string2="HORIZ" THEN x2=x1+integer3-1y2=y1+15ELSE IF string2="VERT" THEN x2=x1+15y2=y1+integer3-1ENDIF ENDIF GOSUB 100x1=integer1+2y1=integer2+2IF string2="HORIZ" THEN x2=x1+integer3-5y2=y1+11ELSE IF string2="VERT" THEN x2=x1+11y2=y1+integer3-5ENDIF ENDIF GOSUB 110END ENDIF REM Display an arrow.IF string1="ARROW" THEN x1=integer1 \y1=integer2x2=integer1+15 \y2=integer2+15GOSUB 100x1=integer1 \y1=integer2x2=integer1+15 \y2=integer2+15IF string2="UP" THEN RUN gfx2("color",14)RUN gfx2("line",x1+8,y1+5,x1+11,y1+10)RUN gfx2("line",x1+4,y1+10)RUN gfx2("color",15)RUN gfx2("line",x1+7,y1+5)GOSUB 160END ENDIF IF string2="DOWN" THEN RUN gfx2("color",14)RUN gfx2("line",x1+8,y1+10,x1+11,y1+5)RUN gfx2("color",15)RUN gfx2("line",x1+4,y1+5)RUN gfx2("line",x1+7,y1+10)GOSUB 160END ENDIF IF string2="RIGHT" THEN RUN gfx2("color",14)RUN gfx2("line",x1+10,y1+8,x1+5,y1+11)RUN gfx2("color",15)RUN gfx2("line",x1+5,y1+4)RUN gfx2("line",x1+10,y1+7)GOSUB 160END ENDIF IF string2="LEFT" THEN RUN gfx2("color",14)RUN gfx2("line",x1+5,y1+8,x1+10,y1+11)RUN gfx2("line",x1+10,y1+4)RUN gfx2("color",15)RUN gfx2("line",x1+5,y1+7)GOSUB 160END ENDIF ENDIF REM Beautify a window.IF string1="WINDOW" THEN x1=integer1y1=integer2x2=integer1+integer3-1y2=integer2+integer4-1IF string2="FRAMED" THEN GOSUB 100x1=integer1+4 \y1=integer2+4x2=integer1+integer3-5 \y2=integer2+integer4-5GOSUB 110END ENDIF IF string2="RAISED" OR string2="OUTLINED" THEN GOSUB 100END ENDIF IF string2="DROPPED" THEN GOSUB 110END ENDIF IF string2="SHADOWED" THEN RUN gfx2("color",15)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",14)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)x1=x1+1y1=y1+1x2=x2-1y2=y2-1GOSUB 100END ENDIF IF string2="ETCHED" THEN GOSUB 130x1=x1+1y1=y1+1x2=x2-1y2=y2-1GOSUB 120END ENDIF IF string2="CARVED" THEN GOSUB 120x1=x1+1y1=y1+1x2=x2-1y2=y2-1GOSUB 130END ENDIF IF string2="PICFRAME" THEN GOSUB 110x1=integer1+4 \y1=integer2+4x2=integer1+integer3-5 \y2=integer2+integer4-5GOSUB 120END ENDIF ENDIF REM Draw a square.IF string1="SQUARE" THEN x1=integer1y1=integer2x2=integer1+integer3-1y2=integer2+integer4-1IF string2="POPPED" THEN GOSUB 120END ENDIF IF string2="PUSHED" THEN GOSUB 130END ENDIF IF string2="FILLED" THEN RUN gfx2("bar",x1,y1,x2,y2)END ENDIF IF string2="OUTLINED" THEN RUN gfx2("box",x1,y1,x2,y2)END ENDIF ENDIF REM Display window title.IF string1="TITLE" THEN RUN gfx2("curxy",integer1,integer2)x1=integer1*8-4 \y1=integer2*8-4x2=x1+integer4*8+7 \y2=y1+15RUN gfx2("color",13)RUN gfx2("bar",x1,y1,x2,y2)RUN gfx2("color",14,13)PRINT string2; IF integer3=0 THEN GOSUB 100ELSE GOSUB 110ENDIF END ENDIF REM Verify version 3.0IF string1="VERSION" THEN integer3=3integer4=0IF (integer1=1 OR integer1=2 OR integer1=3) AND integer2<=1 THENstring2="GOOD"ELSE string2="BAD"ENDIF END ENDIF RUN gfx2("bell")RUN gfx2("color",14,15)PRINT PRINT "Command error in GuiB module!"STOP END REM Draw a raised box.100 RUN gfx2("color",15)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",14)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)x1=x1+1y1=y1+1x2=x2-1y2=y2-1RUN gfx2("color",13)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",14)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)RETURN REM Draw a dropped box.110 RUN gfx2("color",14)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",13)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)x1=x1+1y1=y1+1x2=x2-1y2=y2-1RUN gfx2("color",14)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",15)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)RETURN REM Draw a popped box.120 RUN gfx2("color",13)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",14)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)RETURN REM Draw a pushed box.130 RUN gfx2("color",14)RUN gfx2("line",x2,y1,x2,y2)RUN gfx2("line",x1,y2)RUN gfx2("color",13)RUN gfx2("line",x1,y1)RUN gfx2("line",x2,y1)RETURN REM Horizontal Etched Lines140 RUN gfx2("color",15)RUN gfx2("line",x1,y1,x2,y1)y1=y1+1RUN gfx2("color",14)RUN gfx2("line",x1,y1,x2,y1)RETURN REM Vertical Etched Lines150 RUN gfx2("color",15)RUN gfx2("line",x1,y1,x1,y2)RUN gfx2("color",14) \x1=x1+1RUN gfx2("line",x1,y1,x1,y2)RETURN REM Fill in arrow.160 GOSUB 150RUN gfx2("color",13)RUN gfx2("fill",x1+8,y1+8)RUN gfx2("pattern",0,0)RETURN REM Find out the window type.170 regs.a=1regs.b=$93RUN syscall($8D,regs)IF regs.a=8 THEN RUN gfx2("pattern",205,1)ELSE RUN gfx2("pattern",204,1)ENDIF RETURN string1="GUIB 3.0  (c) 1993, Shawn Driscoll."REM Error trap!180 x1=ERRRUN gfx2("color",14,15)PRINT "Error #"; x1; " in GuiB!"END 