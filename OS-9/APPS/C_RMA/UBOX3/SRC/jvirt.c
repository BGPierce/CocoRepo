/* JVIRT.C  (BVIRT) Buffer Virtual-score-memory subrs      89/08/23 ** 89/08/20 code for Grafix Buffers steda Data Modules.** NOTE: Pages are numbered from 1, not 0.* Not clear whether you can assume that every grafix buffer will* map into the same 8K block (if subrs are swapping too),* nor that every buffer will have the same offset.* Would be a hell of a big help -- database and curptop wud be constants.*/#include <stdio.h>#include <os9.h>#include "jmuse.h"#include "buffpage.h"extern direct Index     nevents;direct EVENT     *curevp,       /* current event pointer */     *database,     /* Bottom of current page (1st byte's addr) */     *curptop;      /* highest event ptr possible on current page */direct int     buffsize; /* size of current buffer (for testing only) */direct Index     curind;     /* current index */     direct sexy     bwchan,   /* Buffer window I/O channel */     group,    /* buffer group, usually our PID */     curpage = 0,  /* current page no. */     nmpages = 0;  /* how many pages are in memory */ubyte *mapbuff();bool pswap(), makepage();/********* Functions ********//* New Buffer for old.  Cheaper than DataMod pages.... */bool pswap(page)  sexy    page;{/* Swap out old, if any */     if(curpage)          mapbuff(curpage, FALSE);/* Swap in new */     if((curpage = page) <= 0)  /* Means don't map anything new in */          return(FALSE);     database = (EVENT *) mapbuff(curpage, TRUE);     if(!database)          return(FALSE);     curptop = database + (PNEVENTS - 1);     return(TRUE);}/* Given a good-old-style index, *  swap in the page and compute the pointer.*  Slowest thing you can do, if page swaps. */EVENT *i2p(ind)  register int ind;{     int  page;/*     if(ind >= nevents)          ind = nevents;*/     curind = ind;/* Repeated subtraction to get quotient and remainder */     for(page = 1; (ind -= PNEVENTS) >= 0; page++)          ;     ind += PNEVENTS;    /* restore after last subtract *//* Swap data pages if needed */     if(page != curpage)          pswap(page);        /* assume OK; jio made pages */     return(curevp = database + ind);}/* Increment current pointer by one Event.*  Let if go off the end of nevents, so caller can (must!) check. */EVENT *plusplus(){     if(++curind < nevents) {          if(++curevp > curptop) {               pswap(curpage + 1);                curevp = database;          }     }     return(curevp);}/* Decrement by one.  Let curind go <0 but hold page=1 and curevp=0. */EVENT *decdec(){     if( --curind >= 0) {          if(--curevp < database) {               pswap(curpage - 1);               curevp = curptop;          }     }     return(curevp);}/*************** Grafix Buffer routines *//* Create (allocate) a grafix buffer */bool makepage(num)  sexy    num;{     char args[6];     args[0] = 0x1b;     args[1] = 0x29;     args[2] = group;     args[3] = num;     *((int *)(args + 4)) = PAGESIZE;     if(write(bwchan, args, 6) == 6)          return(TRUE);     killpage(num);     return(write(bwchan, args, 6) == 6);}/* Kill (de-allocate) a grafix buffer.  Num==0 kills whole group. */void killpage(num)  sexy    num;{     char args[4];     args[0] = 0x1B;     args[1] = 0x2A;     args[2] = group;     args[3] = num;     write(bwchan, args, 4);}/* Kill off all pages above given number.  Adjust globals to fit. */void killem(page)  sexy    page;{     if(curpage > page)          pswap(page);   /* if page==0, then no page is mapped */     for( ; nmpages > page; nmpages--)          killpage(nmpages);}/* Map a buffer into or out of our address space.*  Update global 'buffsize' if mapping in. */ubyte *mapbuff(num, in)  int     num;  bool    in;       /* TRUE in, FALSE out */{     struct registers    regs;     *((char *) &num) = group;/* high byte */     regs.rg_a = bwchan;      /* Path */     regs.rg_b = 0x84;        /* SS.MpGPB, p.8-122 */     regs.rg_y = in;     regs.rg_x = num;         /* group << 8 | num */     if(_os9(0x8E, &regs)) {  /* 8E=SetStat, NOT 8D=GetStat! */          /* printf("***MapBuff error %d.\n", regs.rg_b & 255); */          return(NULL);     }     if(in && (regs.rg_y != PAGESIZE)) {          /* printf("\007***Buffer %d has Size %d!\n", num & 255, regs.rg_y);*/          return(NULL);     }     return(regs.rg_x);}/************* End of grafix buffer routines *//* eof jvirt.c */