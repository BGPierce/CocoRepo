/* file ~Juke/JPLAY.C   --11--  MIDI synther driver for UltiMuse* 90/9/20 started Cresc/Dim, Accel/Rit* 90/6/11:  Structurized* 90/5/27-6/27  Articulations*/#include <stdio.h>#include "jmuse.h"#include "keys.h"#include "vmem.h"#define BADIX  (-1)#define Alert  alert#define Mflush fflush(fmidi);#define MIDICLKS    2    /* Our_ticks per MIDI Clock period *//* New TEMPCON * 60 == previous 1200 */#define TEMPCON     20    /* Human <--> Machine tempos */#define MIDIUART    0xFF6E   /* Speech Systems C/S reg */#define NOTEOFF     0x80#define NOTEON      0x90#define PARAM       0xA0#define CHMODE      0xB0 /* ANO and OMNI on/off */#define PATCH       0xC0#define AFTERTCH    0xD0#define BENDER      0xE0#define TIMCLK      0xF8 /* Drive drum machines, PSS-480, etc. */#define MSTART      0xFA /* start & stop drum machines */#define MSTOP       0xFCextern short getclock();/* For repeats, Ith endings, DC/DS, Coda, etc */#define RS_SIZE 8typedef struct {    Index lefty;    sexy  repcnt;} REPSTACK;typedef struct {    /* size 16 from old 13  92/5/21. */  int     pchans;   /* Part's MIDI channel */  sexy    notes;    /* now playing MIDI no. */  int     remtimes; /* ticks remaining */  sexy    prtbots,  /* Botnote cache, must match playstaff(&bn) */          midlvls;  /* current MIDI level */  int     trannies, /* transpose semis */          itrans;   /* Instrs' +-12 contribution */  byte    plarts,   /* previous artic, for defaults */          oldslots; /* previous slot playing, tie tester */ } PLAYPART;extern direct FILE     *fmidi;extern ubyte   chans[NPARTS + 1];  /* Part --> MIDI_channel assgnmts */extern byte    levels[];           /* volumes per parts */extern sexy    instvals[];         /* inst #s ==> MIDI patch #s */extern char    filename[],               instnams[][INAMEL];extern ubyte   percmids[17];extern direct Index     gind;extern direct bool     tripper, rfr_scr, midipak, midiser, mididev, instren,     clocken, scrclock;extern direct sexy     notemin, notemax,     broke,         /* BREAK interrupt flag */     nparts, keysig, velo,     numer, denom, xgoal,     secmin, transp;  /* secmin == seconds per minute */extern direct short     scorelvl;extern direct ubyte     midinnmin, midinnmax,     mydat0;/* Direct-Page stuff for speed */extern direct char     *midics;extern direct int     contemp;        /* secmin * TEMPCON */extern direct bool     inending,     senzarep;      /* turns repeats off */extern direct REPSTACK *rsptr;     /* pointer to 1st empty stack slot */extern direct sexy     plpart, plslot, white, midnote, oldmid, chrind, fix,     plart, midchan;extern direct unsigned     tempo,    /* Human (score) tempo */     machtemp,     midicnt;extern direct Index     sign, dcds,  /* Sign and DC/DS */     nthendx,     /* Next Ith ending's loca */     coda;extern direct short      /* probly "unsigned" in bdp.c */     residue;extern direct Etime     now, lastime;extern direct Deltime     delt, dendur, zonedur;/* 90/9/29 */extern direct Deltime     takeoff,  /* ticks to clear min of remtimes[] */     tilloff,  /* ticks till next note turnoff */     ttemp;    /* time temporary */extern direct int     towait;   /* ticks to wait in sleep60() *//* Cresc & Accel vars */extern direct Deltime     crdelt, acdelt;   /* runtime so far */extern direct short     crbeglvl, acbegmt, /* init vol & machtemp*/     crmult, acmult, acscale;/* End of cresc & accel */void play(){     REPSTACK repstack[RS_SIZE + 1];     PLAYPART parties[NPARTS+1];     ubyte          bigkeyc[50],    /* Seven white Key of C octaves */          chroma[50],     /* Seven White octaves blackened for KeySig */          thiskey[7];     /* One-octave intermediary *//* Cresc vars (move up later) */     Deltime   crnticks; /* how long to go for */     bool crescon;     sexy crendlvl; /* target vol 1-127 *//* End of cresc *//* Accel vars (move up later) */     Deltime   acnticks; /* how long to go for */     bool accelon;     int  acendmt;/* End of accel */     sexy      hilo;     int       avgvol;     Index     evx;     int       oldtick;     bool      doclock;     int       clocks;   /* ticks remaining before next MIDI Clock */     int       basevol;     sexy      runstat;     PLAYPART  *pptr;    /* on top of stack */     register EVENT  *evp;/* Execute some code already! */     getmydat();     if( !mydat0)          return;     if(mididev) {          if( !(fmidi = fopen("/MIDI", "w"))) {               Alert("\007**Can't open /MIDI", 0);               return;          }          fmidi->_flag |= _RBF;     }     setpr(group, 254);     /* Set up MIDI UART (Speech Systems 6850) */     if(midipak) {          midics = (char *) MIDIUART;          *midics = 0x17;     /* Master Reset */          *midics = 0x15;     /* working modes */     }     broke = 0;/* Init your own mind */     notemin = midinnmin;     notemax = midinnmax;     avgvol = (levels[3] + levels[4]) >>1;   /* average(mp, mf) */     basevol = velo;     contemp = TEMPCON * secmin;     for(plpart = 1, pptr = parties+1; plpart <= nparts;  pptr++, plpart++)     {          pptr->plarts = LEGATO;          pptr->remtimes = pptr->notes = 0;          pptr->midlvls = levels[4];      /* mf */          pptr->oldslots = REST;          pptr->pchans = chans[plpart];          playstaff(plpart, &(pptr->prtbots), &hilo);     /* Don't transpose drum parts */          pptr->trannies = ((hilo & PERC) != 0) ? 0 : transp;          pptr->itrans = 0;     }     nthendx = sign = dcds = coda = BADIX; /* illegal index */     accelon = crescon = senzarep = FALSE;/* Prepare for THE MAIN LOOP */    inending = FALSE;    tilloff = takeoff = 32767;    keysig = runstat = 0;    tempo = 120;    /* (TimeSig defaults to globals) */    lastime = 0;/* Always make beginning a left repeat for stack's sake */    rsptr = repstack;    rsptr->lefty =  0;    (rsptr++)->repcnt = 0;/* Init (just once) full-keyboard Key of C reference */     newkey7(thiskey, 0);     spread50(thiskey, bigkeyc);/* Re-init chroma[] in two stages: *//* Use KeySig to form one octave into thiskey[];*  must re-do only if new KeySig is encountered */     newkey7(thiskey, keysig);/* Replicate thiskey[] thru 7 octaves of chroma[].*  Must re-do after each BarLine to clear Accidentals. */     spread50(thiskey, chroma);     tempcon();     /* convert tempo domain */     residue = 0;     clocks = MIDICLKS;     if(doclock = (scrclock && clocken) )         midiwr(MSTART);      /* turn on the bubble machine */     sleep60(2);    /* may make getclock() safer */     oldtick = getclock();/* ------------ THE MAIN LOOP ----------- */     for(evp = i2p(evx = 0); evx < nevents; evp = plusplus(), evx = curind)     {        if(broke)            break;/* Kill time iff present "chord" is all turned on */          now = evp->startime;          if( (delt = now - lastime) > 0) {   /* new chord */               if(mididev)                    Mflush;               lastime = now;               crdelt += delt;               acdelt += delt;               fix = keysense();/* Entry conditions:  delt > 0 == time from old lastime till now (next event);*  clocks == 1 or 2;  takeoff = ticks till next note turnoff. */do {/* Which of 3 things will happen next? */     towait = (delt > tilloff) ? tilloff : delt;     if(doclock) {          if(towait < clocks)      /* ie, towait == 1 */               clocks -= towait;          else {               towait = clocks;               midiwr(TIMCLK);               if(mididev)                    Mflush;               clocks = MIDICLKS;  /* = 2 */          }     }/* Sleep */     ttemp = towait;     if(fix & SHIFT) {     /* Fast Forward */          if(ttemp & 1)      /* if odd, */               residue += 32; /* credit half a tick */          ttemp >>= 1;     }     else if(fix & CTRL)              /* Half Speed */          ttemp += ttemp;/*** How long to wait? ***/     residue += ttemp * machtemp;/* Deduct time spent on SERIAL MIDI bytes from residue,*  5/4 residue_point per byte, unless Parallel also on*  (nobody knows why parallel "fixes" the clock interrupts) */     if(midiser && !mididev)          residue -= (midicnt + (midicnt >> 2));     midicnt = 0;/* Miss any ticks?  Check 60 Hz countdown clock's current value*  against when we woke up.  91/9/17 */     if((oldtick -= getclock()) < 0)   /* normally positive */          oldtick += 60;      /* rollover */     residue -= (oldtick << 6);    /* The Fix! */     if( (ttemp = residue >>6) > 0) {          residue &= 63;      /* delete its integer part */          sleep60(ttemp);     /* THE ONLY sleep() in play() */     }     oldtick = getclock();    /* Exact time we woke up *//* Reduce each part's time by sliver 'towait',*  iff at least one part should turn off. */     if( (tilloff -= towait) <= 0) {   /* shud never be < */          tilloff = 32767;             /* to find new takeoff */          for(plpart=nparts, pptr=parties+1; --plpart >= 0; pptr++) {               if((ttemp = pptr->remtimes) <= 0)                    continue;      /* part wasn't playing *//* Still playing, deduct and test for turnoff */               if( (pptr->remtimes = (ttemp -= takeoff)) > 0) {                    if(ttemp < tilloff)      /* Still on, update min */                         tilloff = ttemp;               }/* Tied notes get turned off in PlayNote section, unless dangling */               else {  /* Turn note off -- no rests here */                    if( (oldmid = NOTEON + pptr->pchans) != runstat)                         midiwr(runstat = oldmid);    /* Abuse oldmid */                    midiwr(pptr->notes);                    midiwr(0);     /* OFF */               } /* turnoff */          } /* for plpart */          if(mididev)               Mflush;          takeoff = tilloff;     } /* if reduce */} while( (delt -= towait) > 0); /* Crescendo update */               if(crescon) {                    if(crdelt >= crnticks) {                         crescon = FALSE;                         basevol = crendlvl;                    }                    else                         basevol = crbeglvl + ((crmult * crdelt) >> 8);               }/* Accel update */               if(accelon) {                    if(acdelt >= acnticks) {                         accelon = FALSE;                         machtemp = acendmt;                    }                    else                         machtemp = acbegmt + ((acmult * acdelt) >> acscale);               }         } /* if(delt) *//* Time's up, analyze this event */        plslot = evp->show.slot;     /* assumed INCTYPE */        if( !evp->part) { /* Inclusion processing *//* If any barline, reset accidentals to keysig. */            if(plslot <= FINE)  {    /* any barline */                spread50(thiskey, chroma);            }            switch(plslot) {            case CLOCKON:                if(evp->show.PARAM1) {  /* ON */                     if(doclock = clocken)                         midiwr(MSTART);                }                else if(doclock) {      /* OFF */                    doclock = FALSE;                    midiwr(MSTOP);                }                break;            case FINE:                if(dcds != BADIX)      /* if a DC or DS is on */                    evx = nevents; /* This exits Main Loop */                break;            case BEGREPEAT:                if(rsptr > repstack + RS_SIZE)                    Alert("**Stack Full!\n", 0);                else {                    rsptr->lefty = evx;                    (rsptr++)->repcnt = 0;                    nthendx = BADIX;   /* Nth ends */                }                break;            case ENDREPEAT:                if(rsptr == repstack)                    Alert("**Stack MT!\n", 0);                else if((--rsptr)->repcnt ==0) { /* pop */                    rsptr->repcnt++;        /* count use */                    evx = (rsptr++)->lefty; /* push back */                }                /* else leave stack popped, go on */                break;            case NTHENDING:        /* Still needs senzarep mode */                inending = TRUE;                if(evp->show.REPENDN == 1) {                    if(nthendx != BADIX) {  /* already played 1st */                        evx = nthendx; /* skip to next */                    }                   /* else play 1st ending by default */                }                else {  /* not 1st ending, repeat back */                    nthendx = evx;  /* for next time */                    if(rsptr == repstack) {                        Alert("**Stack MT!\n, 0");                        break;                    }                    inending = FALSE;                    evx = (rsptr - 1)->lefty;                }                break;            case DOUBLEBAR:     /* stops Nth endings */                if(inending && (nthendx !=BADIX)) {  /* were we doing Nth's? */                    nthendx = BADIX;                    rsptr--;    /* Pop stack */                }                break;/***** End BarLine types, do other Inclusions *****/          case TIMESIG:                numer = evp->show.TSNUMER;                denom = evp->show.TSDENOM;                tripper = (denom >= 8) && (numer >= 6) && !(numer % 3);                dendur = 192 / denom;                zonedur = tripper ? (dendur+dendur+dendur) : dendur;                tempcon();   /* keep wrt denom */                break;          case KEYSIG:        /* build new keysig */                newkey7(thiskey, keysig = evp->show.KSN);                spread50(thiskey, chroma);                break;          case NUTEMPO:               accelon = FALSE;               tempo = evp->show.TEMPONO & 255;               tempcon();               break;          case GENVOL:               crescon = FALSE;               basevol = velo + levels[evp->show.LEVELNO] - avgvol;               break;          case CRESC:               crescon = TRUE;               crdelt = 0;               crbeglvl = basevol; /* capture current level */               crendlvl = velo + levels[evp->show.LEVELNO] - avgvol;               crnticks = zonedur * evp->show.pitmod;  /* nbeats */               crmult = ((crendlvl - crbeglvl) <<8) / crnticks;               break;          case ACCEL:               accelon = TRUE;               acdelt = 0;               acbegmt = machtemp;               acendmt = hum2mach(evp->show.PARAM1 & 255);               acnticks = zonedur * evp->show.pitmod;  /* nbeats */               acscale = 0;               if( !(acmult = acendmt - acbegmt))                    accelon = FALSE;    /* just forget it */               else if(acmult < 0) {    /* Accel */                    while((acmult += acmult) < 0)                         acscale++;                    acmult = (acmult >> 1) | 0x8000;               }               else {    /* Rit. */                    while((acmult += acmult) > 0)                         acscale++;                    acmult = (unsigned)acmult >> 1;               }               acmult /= acnticks;                              break;          case INSTR:    /* Warning -- redefines 'pptr' */               if( !instren)  /* Loses any +-8va stuff too */                    break;               pptr = parties + evp->show.PARTNO;               midiwr(runstat = PATCH + pptr->pchans);               midiwr(instvals[fix = evp->show.INSTRNO] & 127);               fix = instnams[fix][0];         /* 16' and 4' feature */               pptr->trannies -= pptr->itrans;  /* Undo previous shift */               pptr->trannies +=                 (pptr->itrans = ((fix=='+') ? 12 : ((fix=='-') ? -12 : 0) ));               break;          case LEVEL:               (parties + evp->show.PARTNO) ->midlvls                 = levels[evp->show.LEVELNO];               break;          case MCHOP:    /* First kill note on old channel */               pptr = parties + evp->show.PARTNO;               if(pptr->remtimes > 0) {                    pptr->remtimes = 0;                    midiwr(runstat = NOTEON + pptr->pchans);                    midiwr(pptr->notes);                    midiwr(pptr->notes = 0);               }               pptr->pchans = evp->show.INSTRNO;  /* really CHANNEL */               break; /* Go-to items, a la standard musical notation;*  Handles multiple Sign+Coda sections! */          case SIGN:                sign = evx;     /* remember where */                break;          case CODA:  /* both goto and label */                if(dcds != BADIX) {    /* assume coda_come follows */                    evx = dcds;                     dcds = BADIX; /* no lOOp on label! */                     if(nthendx != BADIX) {   /* were we doing Nth's? */                         nthendx = BADIX;                         rsptr--;    /* Pop stack */                     }               }               break;           case DCSENZAREP:    /* from the top, no reps */                senzarep = TRUE;           case DACAPO:        /* from top, do repeats */                dcds = evx;     /* save your loca */                evx = 0;                break;           case DSSENZAREP:    /* from Sign, no reps */                senzarep = TRUE;           case DALSEGNO:      /* from Sign, do repeats */                if(sign == BADIX)                    Alert("**No Sign!\n", 0);                else {                    dcds = evx;     /* save your loca */                    evx = sign;                }                break;            } /* switch */        /* In case evx got moved: */            if(evx != curind) {    /* yes, it got moved */                 evp = i2p(evx);   /* sets  curind = evx */                 lastime = evp->startime;            }            continue;   /* Skip Note/Rests */        } /* end inclusions *//*************** Play note or rest ********//* Changes for Artics:* Old note is already off unless Tied.* Compute new sounding duration for remtimes[] even if old was Tied.*/          pptr = parties + (plpart = evp->part);          oldmid = pptr->notes;          midchan = pptr->pchans;     /* 00-15 chan */          plart = evp->show.artic;          if(plslot == REST) {               midnote = 0;    /* Rest in this context */          }          else { /* Note */               if( !(midnote = pptr->prtbots)) { /* Perc part */                    midnote = percmids[plslot + 4];               }               else { /* Music, not drums :-) */                    chrind = midnote + plslot;                    if( !(fix = evp->show.pitmod) ) { /* no accidental */                         midnote = chroma[chrind];                    }                    else {   /* keep accidental thru bar */                         chroma[chrind] = midnote = bigkeyc[chrind]                           + "\x00\x00\x01\x02\x00\x00\xFE\xFF"[fix];                    }                    midnote += pptr->trannies;               }     /* Professional-grade MIDI-range folding; needs int, not byte */               while(midnote > notemax)                    midnote -= 12;               while(midnote < notemin)                    midnote += 12;          } /* note vs rest *//* Before playing, update partwise Artic history */          if(plart == NORMAL)  /* i.e., none; use history */               plart = pptr->plarts;          else if(plart != TIED)               pptr->plarts = plart;          if(plslot==REST)               ttemp = 0;          else {/* LAST USE of evp */               ttemp = cod2raw(evp->show.dur, evp->show.durmod);               switch(plart) {               case TIED:                    ttemp += 2;                    break;               case MARCATO:                    ttemp -= (zonedur >> 3);  /* 32nd note in N/4 */                    break;#ifdef PIZZICATO               case PIZZICATO:                    ttemp = dendur >> 3;                    break;#endif               case STACCATO:                    ttemp >>= 1;                    break;/* default: LEGATO: NORMAL:  just leave full-length as-is! */               } /* switch *//* Avoid "slivering" or neg */               if(ttemp < 2)                    ttemp = 2;          } /* note vs rest *//* Was previous note tied?  If so, valid for this new note? */          if(pptr->remtimes > 0) {   /* still kickin', assume Tied */               if( (midnote == oldmid)                  || ( !fix && (plslot == pptr->oldslots)) )                    goto validtie;               else {    /* Invalid Tie, MUST turn off */                    if( (fix = NOTEON + midchan) != runstat)                         midiwr(runstat = fix);    /* OFF */                    midiwr(oldmid);                    midiwr(0);               }          }/* At last, record and play it! */          if(pptr->notes = midnote) {    /* '=', don't play new Rest */               if((fix = NOTEON + midchan) != runstat)                    midiwr(runstat = fix);               midiwr(midnote);     /* Re-use fix */               fix = pptr->midlvls + basevol;               if(fix > 127)      fix = 127;               else if(fix < 1)   fix = 1;               midiwr(fix);          }validtie:          if(ttemp) {    /* if Note */               if(ttemp < tilloff) {                    takeoff = ttemp + (takeoff - tilloff);                    tilloff = ttemp;               }     /* Boost ttemp to match bloated array entries;     *  sets ttemp = takeoff if above block fired */               ttemp += (takeoff - tilloff);          }          pptr->remtimes = ttemp;          pptr->oldslots = plslot;    /* for Tie validations */     } /* Main Loop *//* F.I.N.E. --  Only way out!* Turn off any still playing.  Don't trust ANO. */     if(doclock)          midiwr(MSTOP); /* shoot the drummer */     for(pptr = parties + nparts; pptr > parties; pptr--) {          if(pptr->remtimes) {               midiwr(NOTEON + pptr->pchans);               midiwr(pptr->notes);               midiwr(0);          }     }     if(mididev)          fclose(fmidi);     setpr(group, 128);} /* play() *//* eof jplay.c */