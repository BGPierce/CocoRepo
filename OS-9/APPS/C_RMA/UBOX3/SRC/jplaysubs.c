/* ~JUKE/JPLAYSUBS.C   Subrs for JPlay() */#include <stdio.h>#include <os9.h>#include "jmuse.h"extern direct FILE     *fmidi;extern direct short     scorelvl;extern direct int     nparts, nstaves, nevents;extern direct unsigned     contemp;        /* secmin * TEMPCON */extern direct unsigned     tempo, machtemp, midicnt;extern direct sexy     denom;extern direct bool     mididev, tripper;/* None of these arrays is R/O: */extern STAFF staves[NSTAVES];extern PART  parts[NPARTS + 1]; /* Parts are ORG 1, not 0! *//* Botnotes are White keys above 16' C==01.  Mid C ==22. *//* This IS Read-Only! */extern CLEF  clefs[];extern short durtable[4];/* Convert dur & durmod codes to raw durations, using small table. */Deltime cod2raw(cdur, cdurmod)  sexy    cdur, cdurmod;      /* cdur==0-7, cdurmod==0-3 */{     return(durtable[cdurmod] >> cdur);}/************* Sleep given no. of 1/60ths of a second.* Used for note/rest playing, this timing is critical!*/void sleep60(ticks)  int     ticks;{     struct registers regs;/* OS9 can't handle over 255 ticks, nor 0, and 1 is no-op */     if(++ticks <= 0)         /* sleep(N) is really only N-1 ticks */          return;     do {          regs.rg_x = (ticks > 254) ? 255 : ticks;          _os9(F_SLEEP, &regs);          ticks -= 254;       /* sleep(255) is only 254 ticks */     } while( ticks > 0);}/************ Key-Sensing for "shifting" keys */ubyte keysense() {     struct registers regs;     regs.rg_a = 0;           /* stdin */     regs.rg_b = 0x27;        /* SS_KeySns */     _os9(I_GETSTT, &regs);     return(regs.rg_a);}/* Parnasian interface; given Part No., returns the other items *//* This is a Stripped-down version of partstaff() for Play() only! */void playstaff(part, lownote, hilo)  sexy  part;       /* INput; rest are OUTputs: */  sexy  *lownote;   /* clef.bnote */  sexy  *hilo;      /* indicators */{     Reg PART  *ptptr;     if((part < 1) || (part > nparts))          part = nparts;      *hilo = (ptptr = parts + part) -> philo;     *lownote = clefs[(staves + (ptptr->pstaff)) ->clef_no] . bnote;}/************ Fcns originally in play.c itself ****//* All MIDI byte output goes thru here */void midiwr(b)  sexy    b;   /* really ubyte */{     midicnt++;     /* for residue compensation */     midiout(b);    /* assy subr does own mode testing */     if(mididev)          putc(b, fmidi);}/* Customize a one-octave white keyboard for given key */newkey7(new, key)  ubyte   *new;  sexy    key;      /* no. of sharps or flats */{     ubyte     start;     Reg ubyte *rnew;     rnew = new;/* Former global keyc[7] */     strdn(new, "\x00\x02\x04\x05\x07\x09\x0B", 7);    /* Init all whites */     if( !key )          /* Key of C, done */          return;     if(key > 0) {       /* Sharps */          start = 3;     /* 1st one is F */          for( ; key; key--) {               (*(rnew + start)) ++;   /* sharpen that note */               if((start += 4) > 6)   /* up by 5ths */                    start -= 7;          }     }     else {              /* Negative, Flats */          start = 6;     /* 1st one is B */          for( ; key; key++) {               (*(rnew + start)) --;   /* flatten that note */               if((start += 3) > 6)   /* up by 4ths */                    start -= 7;          }     }} /* newkey7() *//* Copy single white key-sig octave to full 7 octaves. *  Note that MIDI "ORG" assigns 0, not 1, to 64' C. */spread50(single, seven)  register ubyte    *single;  ubyte   *seven;{     sexy      chroff;     ubyte     *whoff;     whoff = seven + 49;     seven += 1;    /* I forget why */     for(chroff = 24 + 24*256;       seven < whoff;  seven += 7, chroff += (12+12*256) )     {          *((short *)seven)       = *((short *)single)       + chroff;          *((short *)(seven + 2)) = *((short *)(single + 2)) + chroff;          *((short *)(seven + 4)) = *((short *)(single + 4)) + chroff;          *          (seven + 6) = *           (single + 6)  + chroff;     }}/* Convert Human to Machine tempos, in # of DENOM-notes per minute.* Tempos from 30 to 240, tripled to 720, denoms 2-16, secmins 20-180,* machtemps 3-1920 (some dynamic range, eh?!?)*/void tempcon(){     unsigned  human;     human = (tripper && (scorelvl >= 7)) ? (tempo + tempo + tempo) : tempo;     machtemp = ((unsigned)contemp * (unsigned)denom) / human;}/* As above, but with human tempo given as arg, and returns value*  without touching machtemp.  Slower but general. */unsigned hum2mach(human)  unsigned  human;{     if(tripper)    /* know scorelvl >= 7 */          human += (human + human);     return( ((unsigned)contemp * (unsigned)denom) / human);}/* eof ~juke/jplaysubs.c */