/* file JIO.C   -13-    Disk I/O.** Version = 2-bits Level, 3-bits Score, 3-bits Revision* Level -- radical, like 640 screen.* Score -- older scores are invalid, tho probably compatible.* Revision -- new features, cleaned up code, etc.*/#include <stdio.h>#include <modes.h>#include "jmuse.h"#include "buffpage.h"#include "version.h"#define BARNOLO dur      /* Unforch, these are backwards of Motorola */#define BARNOHI durmod#define BARNO   dur     /* Cast to short to represent internal value */ /* None of these arrays is R/O: */extern STAFF staves[NSTAVES];extern PART  parts[NPARTS + 1]; /* Parts are ORG 1, not 0! *//* This IS Read-Only! */extern CLEF  clefs[];extern Record  records[];extern sexy    instvals[NINSTRS];extern char    instnams[NINSTRS][10];extern char    filename[SFILENAME],               dirname[SFILENAME];extern ubyte   chans[NPARTS + 1],               genvols[NLEVELS],               percmids[17],               levels[NLEVELS];extern char    percsynth[24];extern direct EVENT     *curevp,     /* current event pointer */     *database,     /* Bottom of current page (1st byte's addr) */     *curptop;  /* highest event ptr possible on current page */extern direct int     bwchan,   /* Buffer window I/O channel */     group,    /* buffer group, usually our PID */     buffsize, /* size of current buffer (for testing only) */     curind;     /* current index */extern direct sexy     curpage,  /* current page no. */     nmpages;  /* how many pages are in memory */extern direct short    nparts, nstaves, nrecords,    nbars, nzones, scorelvl;extern direct Index     nevents;extern direct sexy    broke, numer, denom, keysig, secmin, transp;extern direct Time    length;extern direct bool     midiser, midipak, shuffle, repeat, scrclock;extern bool     pswap();bool      diskio();      /* pre-dec */char      *index();bool isume(str)  char    *str;{     return(       (*str == '.')       && ( (*(str+1)=='u') || (*(str+1)=='U') )       && ( (*(str+2)=='m') || (*(str+2)=='M') )       && ( (*(str+3)=='e') || (*(str+1)=='E') )     );}/* Read directory and save all .ume filenames in records[].*  Return count of how many were found. */int diread() {     char buff[32],          name[30];      /* 29 chars plus \0 */     extern int errno;     int  chan, count;     int  c, nread, len;     char *from;     register char *to;     chan = open(".", 0x81);  /* 80==Dir, 1==Read only */     if(chan < 3) {          alert(" Can't open Directory, Error No.", 1, errno);          return(0);     }/* Blow off header */     read(chan, buff, 32);     read(chan, buff, 32);/* Now the file entries */     count = 0;     for(;;) {          nread = read(chan, buff, 32);          if(nread < 32)               break;          if(!*buff)     /* old deleted entry */               continue;          for(from = buff, to = name, nread = 0;            nread <= 29;  nread++)               if( (*to++ = *from++) < 0)                    break;          *(to - 1) &= 127;          *to = '\0';/* Save filename iff it ends in ".ume" */          len = strlen(name) - 4;          if(len <= 0)               continue;          if( !isume(name + len))  /* not .ume, .Ume, .UME, etc. */               continue;          *(name + len) = '\0';    /* delete the .ume */          strcpy(records[count].recname, name);          records[count].order = 0;          count++;          if(count > NRECORDS)     /* no more room */               break;     }     close(chan);     return(nrecords = count);}/***** Normalize Naturals to 4, and Nothings to 0 **/sexy pmodfix(pm)  sexy    pm;{     if( (pm &= 7) == 1)          return(0);     if(pm == 5)          return(4);     return(pm);}/* "Xenophobia" should go in here *//* Read thru a score and "swab" all the BARNO fields.*  Also fix any "alternate" Null or Natural PitMods,*    and any funny Artics (90/11/24) */void barswap() {     Reg EVENT *evp;     short     swabber;     for(evp = i2p(0); curind < nevents; evp = plusplus()) {          if( !evp->part) {               if(evp->show.INCTYPE <= FINE) {                    swabber = evp->show.BARNOLO;                 /* LDB */                    *((char *)(&swabber)) = evp->show.BARNOHI;   /* LDA */                    *((short *)(&(evp->show.BARNO))) = swabber;  /* STD */               }          }     /* Note/Rest */          else {               evp->show.pitmod = pmodfix(evp->show.pitmod);               if( (evp->show.slot == REST) || (evp->show.artic >= NARTICS) )                    evp->show.artic = NORMAL;          }     } /* for */} /* barswap() */bool diskio(fname)  char    *fname;{     register int chan;     char      buff[BUFFSIZE];     long      whereto;       /* corrects for too-long scores */     short     howmany;     int       nevsleft;     ubyte     sclevel, bnparts;     bool      ok = TRUE;     /* innocent until ... *//* Assume filename has room for 4 more chars */     strcat(fname, ".ume");     chan = open(fname, 1);     if(chan < 2) {          printf("\007*** Can't open file '%s'\n\l", fname);          sleep60(200);  /* 3 sec */          return(FALSE);     }/* File is open, proceed. *//* Free any old buffers */     killem(0);  /* Version type number is packed in with nparts */     read(chan, &scorelvl, 2);     nparts = scorelvl & 31;     scorelvl = (scorelvl >>8) & 127;     read(chan, &nstaves, 2);     read(chan, &numer, 2);     read(chan, &denom, 2);     read(chan, &nevents, 2);     read(chan, parts, (nparts + 1) * sizeof(PART));     read(chan, staves, nstaves * sizeof(STAFF));/* The main events ... *//* In case memory runs out before whole score reads in: */     whereto = lseek(chan, 0l, 1) + (long)nevents * (long)SEVENT;     if(nevents > NEVENTS) {          nevents = NEVENTS;     }/* Read file into new pages, allocating one page at a time */     for(nevsleft = nevents; nevsleft > 0; ) {          if(!makepage(++nmpages) || !pswap(nmpages) ) {               nmpages--;               nevents -= (nevsleft + 2);               printf("\n\l\Out of Memory, cut Score to %d Objects\n\l",                 nevents);               sleep60(120);               if(nevents <= 0) {                    close(chan);                    return(FALSE);               }               break;          }          nevsleft -= read(chan, (ubyte *)database,            SEVENT * ((nevsleft > PNEVENTS) ? PNEVENTS : nevsleft) ) / SEVENT;     }     lseek(chan, whereto, 0); /* make sure as if all events read *//* Trailer parkies */     read(chan, &secmin, 2);/* Re-init from read-in file statistics */     length = figurst(nevents - 1);     barswap();     barenum(F);     timesig();/* Reads of older scores (lacking instrument tables) keep previous */     read(chan, instvals, sizeof(instvals) );     ok &= ( read(chan, instnams, sizeof(instnams)) == sizeof(instnams) );/* Channel Assignments Table */     ok &= ( read(chan, chans, sizeof(chans)) == sizeof(chans) );/* Shareware scores have MIDI Levels here.  SCRLVL-3 should have! *//* But some sharewares labeled "2" lack them, so give free credit for ==2.*/     if((scorelvl==2) || (scorelvl > 3)) {          ok &= ( (read(chan, levels, sizeof(levels)) == sizeof(levels))            || (scorelvl==2) );     }/* Title/Info Banner */     if(scorelvl >= 3) {          if( ! titlered(chan) )  {               titleclr();    /* don't punish 'ok' */          }     }     else          titleclr();/* Level 6 Genvol Levels and Percussion MIDI note numbers,*  plus L7 MIDI Transpose */     if(scorelvl >= 6) {          read(chan, genvols, sizeof(genvols));          read(chan, percmids, 17);          read(chan, percsynth, 24);          ok &= (read(chan, &scrclock, sizeof(scrclock))            == sizeof(scrclock));          if(scorelvl >= 7)               ok &= (read(chan, &transp, 2) == 2);          else               transp = 0;     }     close(chan);     audit();     return(ok && audit());} /* diskio() *//* Remove blanks in-place from file or path name */void trim(s)  char *s;{     char c;     register char  *fp;     fp = s;     do {          c = *fp++;          if(c != ' ')               *s++ = c;     } while(c);}/* eof ~Sw640/JIO.C */