/* file JUKE/JSUBS.C   -5-   Various routines for UltiMuse */#include "jmuse.h"#include "jcolors.h"#include <stdio.h>#include <os9.h>extern direct EVENT     *curevp,     /* current event pointer */     *curptop;  /* highest event ptr possible on current page */extern direct int     bwchan,   /* Buffer window I/O channel */     group,    /* buffer group, usually our PID */     curind;     /* current index */extern direct ubyte     *database;     /* Bottom of current page (1st byte's addr) */extern direct sexy     curpage,  /* current page no. */     nmpages;  /* how many pages are in memory */EVENT     *i2p(), *plusplus(), *decdec();/* None of these arrays is R/O: */extern STAFF staves[NSTAVES];extern PART  parts[NPARTS + 1]; /* Parts are ORG 1, not 0! *//* This IS Read-Only! */extern CLEF  clefs[];extern direct sexy  broke;extern direct Index     nevents;extern direct short     nparts, mx,my,     numer, denom, nbars, nstaves;extern STAFF   staves[];extern direct Deltime     dendur;extern short durtable[4];void flush() {     fflush(stdout);}void os9tmode() {     system("tmode pause echo");}void ourtmode() {     system("tmode -pause -echo");}/***** Palette Save & Set/Restore */ubyte *getpal(where)  ubyte   *where;{     struct registers regs;     regs.rg_a = 1;      /* stdout */     regs.rg_b = 0x91;   /* SS_Palet */     regs.rg_x = where;     _os9(I_GETSTT, &regs);     return(where);}ubyte *setpal(where)  ubyte   *where;{     struct registers regs;     regs.rg_a = 1;      /* stdout */     regs.rg_b = 0x91;   /* Or 0x97 == SS_DfPal?? */     regs.rg_x = where;     _os9(I_SETSTT, &regs);     return(where);}/* Set one Palette slot to given 6-bit RGB color */void pal(slot, color)  sexy    slot, color;{     printf("\x1b\x31%c%c", slot, color);     printf("\x1b\x31%c%c", slot + 8, color);     /* fores==backs */     flush();}/******* Window Stuff ***//* Open an OVERLAY window.  Name and args order for Umuse3 compat. *//* Note: Manual p 3-24 has Fore & Back args reversed. */void wcreate(lcol, topline, colwid, linehgt, save, fore, back)  int     lcol, topline, colwid, linehgt, fore, back;  bool    save;{     printf("\x1b\x22\%c%c%c%c%c%c%c\f",     /* must do own Clear */       save, lcol, topline, colwid, linehgt, fore, back);     flush();}/* Close an overlay window */void wkill() {     printf("\x1b\x23");     flush();}char readone(buff)  /* returns the char. */  char *buff;       /* need be only one byte long */{     flush();       /* favor to StdIO and the caller */     do {          read(0, buff, 1);          if(*buff >= '\n')               putchar(*buff);     /* Echo it yourself */          if(*buff == '\n')               putchar('\l');          flush();     } while(*buff < '\n');     return(*buff);}void bell() {     putc(7, stderr);}void hitenter() {     char buff[33];     printf("Hit ENTER to go on: ");     flush();     gets(buff);}/* Ask yes/no question. Prompt must supply own "? " if wanted. * No defaults accepted.  No newlines needed OR desired. * Ignores BREAK char already in stream.*/bool yesno(prompt)  char *prompt;{     bool ret;     char ch;     wcreate(12, 8, 58, 4, TRUE, FORE, YESNOBACK);     printf("\n\l%s ", prompt);     for(;;) {          ch = readone(&ch);          if(ch == 'n') {               ret = FALSE;               break;          }          if(ch == 'y') {               ret = TRUE;               break;          }          printf("\007\f  (Please answer y or n)\n\l%s", prompt);     }     wkill();     flush();     return(ret);}/* alert()  Error and warning alert boxes for user. */void alert(msg, nargs, n1)   /* PLUS  n2, n3, n4, ..., n7 */  char    *msg;   /* MUST be null-terminated; '\n' optional */  int     nargs, n1;  /* AND n2, ... n7 */{     register int   *sp;     /* Stack Pointer */     bell();     wcreate(6, 7, 68, 5, TRUE, BACK, ALERTBACK); /* use dark letters */     printf("\n\l%s", msg);     nargs &= 7;             /* Test your brakes ... */     for(sp = &n1; nargs; nargs--)  /* Portable?? */          printf(" %d", *sp++);     printf("\n\l");     hitenter();     wkill();/* hitenter();    /* temporary for debugging */}/* BREAK-key catching fcn.  Also does ^C for Play().*  Does RTI, not RTS, to point of BREAK.*  Puts signal type into global 'broke'.*  1st time just sets broke; 2nd time tries to quit.*  Externally clearing 'broke' resets everything.*/void breaker(sigtype)  int sigtype;{     char buff[3], ch;     if(broke)      /* not Playing */          return;   /* RTI */     broke = sigtype;/* While PLAYing, broke == 0, comes here */     if(sigtype==3) {    /* ^C */          return;        /* to Play() */     }     if(sigtype != 2) {  /* not BREAK, complain */          alert("***Odd Signal", 1, sigtype);     }/* Treat it like a BREAK anyway */     for(;;) {          wcreate(26, 2, 28, 5, TRUE, FORE, YESNOBACK); /* FORE was BACK */          printf("\n\l SPACE   End Pause\n\l");          printf(" s       Skip to next\n\l");          printf(" ENTER   Stop, Main Menu\n\l");          printf("      Choice: ");          readone(&ch);          wkill();          switch(ch) {          case ' ':               broke = 0;               return;   /* to keep Play()ing same piece */          case 's':               broke = 3;     /* like ^C */               return;          case '\n':               broke = 2;     /* like BREAK */               return;          default:               bell();          }     }     /* fall out == RTI to play() */} /* breaker() *//*******************  Figure the startime of the event that would follow the*  given event.  Use to get length of whole score.*  Works anywhere in events[] though.*//* Not used in Juke except to print length.  Can't handle >32k ticks! */Time figurst(ind)  Index   ind;{     Reg EVENT *evp;     Etime     st;     if(ind < 0)          return(0);     evp = i2p(ind);     st = evp->startime;     if(evp->part)     /* Not inclusion, Instr, or Level, so it takes time */          st += cod2raw(evp->show.dur, evp->show.durmod);     return(st);}/* Check score for validity.  All sorts of tests can be run.*  For now, just check for negative or backwards-moving startimes.*/bool audit() {     Reg EVENT *evp;     Etime     now, this;     now = 0;     for(evp = i2p(0); curind < nevents; evp = plusplus() ) {          this = evp->startime;          if(this < now) {               printf("\007Index %d has Bad Startime of %d!", curind, this);               sleep60(120);               return(FALSE);          }          else               now = this;     }     return(TRUE);} /* audit() *//* eof JSUBS.C */