* file GETCLOCK.A  Snatch a couple of Clock vars outa System DPage* Returns Tick clock in D reg. psect getclock_a,0,0,0,0,0 nam getclock_a ttl getclockTest1 equ towait    * Bytes to check for our DPTest2 equ inendingTest3 equ senzarepVal1 equ $69Val2 equ $DCVal3 equ $37Dat0addr equ $FFA8DTick equ $2EDSlice equ $2F* Subr to get, just once, our current DAT.0,* allowing for WRITE-ONLY upper bit of DISTO 1 Meg Upgrade,* or two such bits for 2 Meg.getmydat:* Write known values into test locations lda #Val1 sta <Test1 lda #Val2 sta <Test2 lda #Val3 sta <Test3 ldx #Dat0addr* Block interrupts orcc #$50* Read DAT.0 ldb ,x andb #$3F     Make sure top bits are 0 stb ,x        Re-write DAT.0* Read and compare bottom 512K lda <Test1 cmpa #Val1 bne try1 lda <Test2 cmpa #Val2 bne try1 lda <Test3 cmpa #Val3 beq good* Nope, try 2nd 512Ktry1 addb #$40 stb ,x lda <Test1 cmpa #Val1 bne try2 lda <Test2 cmpa #Val2 bne try2 lda <Test3 cmpa #Val3 beq good* Try 3rd 512Ktry2 addb #$40 stb ,x lda <Test1 cmpa #Val1 bne try3 lda <Test2 cmpa #Val2 bne try3 lda <Test3 cmpa #Val3 beq good* Try 4th 512K, then punt!try3 addb #$40 stb ,x lda <Test1 cmpa #Val1 bne punt lda <Test2 cmpa #Val2 bne punt lda <Test3 cmpa #Val3 beq good* No luck, return zeropunt clrb* Common return for good & badgood andcc #$AF clra stb <mydat0 rts* end getmydat()********************************* Subr to Read the clock* Extern byte 'mydat0' must contain DAT.0 GIME pointergetclock: lda <mydat0   our DAT.0 clrb          To clear DAT.0 ldx #Dat0addr X -> DAT0 orcc #$50     Shut down OS9 stb ,x        Wipe DAT0 to be System's ldb <DTick sta ,x        Restore your DAT0 andcc #$AF    Re-enable OS9 clra          return Short Int, not Char rtsendsect* eof getclock.a