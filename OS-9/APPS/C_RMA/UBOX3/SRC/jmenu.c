/* file Juke/JMENU.C   Menu & display stuff *//* Combines some of old jio.c with all of jtits.c */#include <stdio.h>#include <modes.h>#include "jmuse.h"#include "version.h"#include "titles.h"#include "jcolors.h"/* None of these arrays is R/O: */extern STAFF staves[NSTAVES];extern PART  parts[NPARTS + 1]; /* Parts are ORG 1, not 0! *//* This IS Read-Only! */extern CLEF  clefs[];extern Record  records[];extern EVENT   events[];   /* T.H.E. editing buffer */extern sexy    instvals[NINSTRS];extern char    instnams[NINSTRS][10];extern char    filename[SFILENAME],               dirname[SFILENAME];extern ubyte   chans[NPARTS + 1],               levels[NLEVELS];extern direct Index     nevents;extern direct short    nrecords, scorelvl,    elimit,     /* NEVENTS, size of event[] */    nbars, nzones;extern direct sexy    delay, nparts, nstaves, broke, numer, denom, keysig, secmin, transp;extern direct Time    length;extern direct bool     midiser, midipak, mididev, repeat, instren, clocken;#define TWINTOPY    5    /* text lines from top of screen */extern char     titles[TLINES][TLEN+1],     filename[];/* Clear one line, ganz zerstoert! */void tlineclr(line)  int     line;     /* Org Zero! */{     char *lintop;     register char  *cp;     cp = titles[line];     lintop = cp + TLEN;      /* final byte */     for( ; cp <= lintop; )          *cp++ = '\0';}/* Clear title array */void titleclr() {     int  i;     for(i = 0; i < TLINES; i++)          tlineclr(i);}/* Show the title lines, within an already-established window.  Free \r\l at end. */void titlinsho(nums)   bool    nums;{     int  line;     for(line = 0; line < TLINES; line++) {          if(nums)               printf("%d:", line + 1);          printf(" %s\n\l", titles[line]);     }     printf("\n\l");}/* Caller must do a wkill() afterwards (yes, sloppy...) */void report() {     int line;     wcreate(40-TLEN/2, 23-(TLINES+5), TLEN+3, TLINES + 5,       TRUE, BACK, TITLEBACK);     printf("\n\l");     titlinsho(FALSE);     printf(" '%s'", filename);     printf("  UltiBox %d.%d.%d%c\n\l  ", UMLEVEL,SCLEVEL,RVLEVEL,RVSUBLET);     printf(       " %d bars of %d/%d;   %u Ticks Long\n\l", nbars, numer, denom, length);     printf("  Score Level %d      %d Items Used.", scorelvl, nevents);     flush();  /* wkill(); */}/* Read titles, including self-doc'ing size info.*  Returns FALSE if no titles there (Shareware file) or disk error.*  Can read future versions with more/less or shorter/longer lines!*    so reads one line at a time.*/bool titlered(chan)  int     chan;     /* file number */{     byte tlines, tlenp1;     int  i;     titleclr();    /* Destroy Before Reading */     if(read(chan, &tlines, 1) != 1)          return(FALSE);     if(read(chan, &tlenp1, 1) != 1)          return(FALSE);/* Are these for real, or XMODEM garbage, or what?*  Keep limits tight to exclude such garbage.* Limits: 3--7 lines of 32--80 + NULL characters.*/     if( (tlines < 3) || (tlines > 7) )          return(FALSE);     if( (tlenp1 < 33) || (tlenp1 > 81) )          return(FALSE);/* Try to read as compatibly and smartly as possible */     if(tlines > TLINES)          tlines = TLINES;     if(tlenp1 > TLEN+1)          tlenp1 = TLEN+1;/* Must read the file's full 'tlenp1' bytes per line */     for(i = 0; i < tlines; i++) {          if( read(chan, titles[i], tlenp1) != tlenp1)               return(FALSE);          titles[i][TLEN] = '\0';  /* pay State Farm's premium */     }     return(TRUE);}/********** Menu Functions *******//* Unselected records are displayed in directory order,*    with unchanging fixed index numbers.*  Directory index numbers are internally ORG 0, ++'ed for user.*  Selected records show in order of selection,*    with index numbers so ordered and kept contiguous;*  deselecting a record decrements all higher selected index numbers.*  Selection order indices are ORG 1, period.*//* "Break" recycles loop; must "return" to get out. */void menu(really)  bool    really;   /* if false, just refresh the Selected menu */{     char buff[81], ch;     bool minus, splayeds[NRECORDS]; /* save real played status */     int  seltop, nalines, nslines, cmdsline, nsel, line, col, rec, bp,          num;     register int   *roptr;     for(;;) {/* How many unselected records are there? */    /* actually, count selected ones */          for(nsel = rec = 0; rec < nrecords; rec++)               nsel += (records[rec].order > 0);          nalines = 1 + (nrecords - nsel + NCOLS-1) / NCOLS;/* and set up for Selected window */          seltop = nalines + 2;          if(seltop == 13)   /* special case, close the gap */               seltop = 12;          nslines = 1 + (nsel + NCOLS-1) / NCOLS;          if(really) {               putchar(0xC);  /* clear screen */               printf(     "  FreeWare         <<< UltiBox-III  by  RagTimer >>>  vers %d.%d.%d%c",                 UMLEVEL, SCLEVEL, RVLEVEL, RVSUBLET);     /* First, Display Unselected records */               wcreate(1, 1, 78, nalines, FALSE, FORE, AVAILBACK);               printf("AVAILABLE:  enter Number to select:");               for(rec=0, line=1+32; rec < nrecords; line++) {                    bp = 0+32;                    for(col=0; (col < NCOLS) && (rec < nrecords); rec++) {                         if( !records[rec].order) {                              printf("\002%c%c", bp, line); /* cursor pos */                              strncpy(buff, records[rec].recname, RECSHOWL);                              *(buff + RECSHOWL) = '\0';    /* safety must! */                              printf("%2d %s", rec+1, buff);                              col++;    bp += 78/NCOLS;                         }                    }               }               wkill();       /* Pre-Elzhbyetnac window */          } /* if really *//* Now for the Chosen People "E Niymiyronza" */          wcreate(1, seltop, 78, nslines,            FALSE, BACK, SELECTBACK);   /* write dark letters */          printf("SELECTED:  enter -Number to reject:");          for(rec = 0; rec < NRECORDS; rec++)               splayeds[rec] = records[rec].played;          unplayall();          for(line = 1+32; ; line++) {               for(bp = 0+32, col=0; col < NCOLS; col++, bp += 78/NCOLS) {                    if( (rec = next()) < 0)  /* breaks both loops */                         break;                    printf("\002%c%c", bp, line); /* cursor pos */                    printf("\x1F%c", 33 - splayeds[rec]);                    strncpy(buff, records[rec].recname, RECSHOWL);                    *(buff + RECSHOWL) = '\0';    /* safety must! */                    printf("%2d %s", records[rec].order, buff);                    records[rec].played = TRUE;   /* needed for display */               }               if(rec < 0)                    break;          }          printf("\x1F\x21");      /* end inverse video */          for(rec = 0; rec < NRECORDS; rec++)               records[rec].played = splayeds[rec];          wkill();       /* Chosen window */          if( !really)   /* skip the rest */               return;     /* Position just below Selected window */          cmdsline = seltop + nslines;               if(cmdsline < 21)    /* leave a gap if room */               cmdsline++;          printf("\002%c%c", 0+32, cmdsline+32);     /* Show Menu Choices */          cmdslist();     /* Display current Modes */          printf( "Current Modes: ");          if(midiser)    printf("SERIAL  ");          if(midipak)    printf("MIDIPAK  ");          if(mididev)    printf("/MIDI.dd  ");          if(repeat)     printf("LOOP  ");          if(instren)    printf("INSTRS ");          if(clocken)    printf("TIMECLOCK");          printf("\n\l");/* Read user's typing */          printf(" Choice? ");          flush();          for(num = 0, minus = FALSE; ; ) {               ch = readone(&ch);               if(ch == '-') {                    minus = TRUE;                    continue;               }               if((ch >= '0') && (ch <= '9')) {                    num = 10 * num + (ch - '0');                    continue;               }               if(ch == '\n') {                    if(!num)                         continue;                    else                         break;               }          /* Any other character overrides number */               num = 0;               break;          }          /* printf("\x1F\x21"); flush();    /* Inverse video off */     /* Toggle a record's selection */          if(num) {               if((num < 0) || (num > nrecords)) {                    alert(" Out of Range: ", 1, num);                    continue;      /* main loop */               }               if( !minus) {  /* Add selection */                     if( !records[--num].order) {                         records[num].order = nsel + 1;                         records[num].played = FALSE;                    }               }               else {         /* Delete selection */                    for(rec = 0; rec < nrecords; rec++) {                         roptr = &records[rec].order;                         if(*roptr > num)                              (*roptr)--;                         else if(*roptr == num)                              *roptr = 0;                    }               }               continue;          } /* if(num) */     /* Not a number, try a command */          switch(ch)          {          case 'r': /* Request one record */               wcreate(20, 20, 40, 3, TRUE, FORE, YESNOBACK);               printf(" Type Number of an Available piece,\n\l");               printf("   or -Number of a Selected piece,\n\l");               printf("     followed by ENTER: ");               flush();               os9tmode();               gets(buff);               ourtmode();               wkill();               num = atoi(buff);               if(!num)  /* as in just ENTER */                    break;               if(num > 0)    /* from Availables */                    num--;    /* ORG shift */               else {         /* from the Selected window */                    num = -num;                    for(rec = 0; rec < nrecords; rec++)                         if(records[rec].order == num)                              break;                    num = rec;               }               if(num < nrecords)                    playone(num);               else                    alert(" No such number, try another.\n\l", 0);               break;          case 'w':               wcreate(11, 14, 41, 4, TRUE, FORE, YESNOBACK);               printf("\n\l Seconds to Wait between Songs\n\l");               printf(" (currently %d) ? ", delay);               os9tmode();               gets(buff);               ourtmode();               if( *buff)                    delay = atoi(buff);               if(delay < 0)    delay = 0;               if(delay > 60)   delay = 60;               wkill();               break;          case 'm': /* Coco-MIDI Pak */               if(midipak = !midipak)                    mididev = FALSE;               break;          case 's': /* bit-banger Serial port */               midiser = !midiser;               break;          case '/': /* /midi device driver */               if(mididev = !mididev)                    midipak = FALSE;               break;          case 'i': /* Instr (Patch) change enable */               instren = !instren;               break;          case 't': /* Timing MIDI Clock enable */               clocken = !clocken;               break;          case 'p': /* play */               unplayall();   /* fall thru... */               menu(FALSE);   /* reeeeecursion! */          case 'c': /* Continue play where left off */               return;          case 'l': /* Loop mode toggle */               repeat = !repeat;               break;          case 'a': /* select All*/               for(rec = 0; rec < nrecords; rec++)                    if( !records[rec].order) {                         records[rec].order = ++nsel;                         records[rec].played = FALSE;                    }               break;          case 'n': /* leave None selected */               for(rec = 0; rec < nrecords; rec++)                    records[rec].order = 0;               nsel = 0;               break;          case 'f': /* Flip selections */               for(rec = nsel = 0; rec < nrecords; rec++) {                    if( !records[rec].order) {                         records[rec].order = ++nsel;                         records[rec].played = FALSE;                    }                    else                         records[rec].order = 0;               }               break;          case 'q': /* Quit */               if( yesno(" Sure you want to Quit? ") ) {                    os9tmode();                    exit(0);               }               break;          case 'o': /* OS-9 command */               os9tmode();               printf("\014 OS-9 Cmd: ");               flush();               gets(buff);               rec = system(buff);               if(rec)                     printf("Error #%d.\n\l", rec & 255);               ourtmode();               hitenter();               break;          case 'd':      /* DIR to help user find sub-dirs, etc. */               os9tmode();               putchar(0xC);               flush();               system("ex dir");               printf("\n\lCurrent Dir is: ");               flush();               system("ex pwd");               for(;;) {                    printf("\n\lType New: \n\l");                    gets(buff);                    trim(buff);               /* Abort ENTER or succeed */                    if(!*buff)                         break;    /* never mind */                    if( !chdir(buff) ) {                         nrecords = diread();                         for(rec = 0; rec < nrecords; rec++)                              records[rec].order = 0;                         unplayall();                         break;                    }                    bell();                    alert("**Can't get to that directory.\n\l");               }               ourtmode();               break;          case ' ': /* SPACE */          case 5:   /* BREAK key */          case 3:   /* Ctrl-C */               break;    /* just go round again */          default:               bell();          } /* switch(chr) */     } /* while */}char *cmds[] = {     "MidiPak", "Ser", "/dev", "Inst", "Time", "Loop",     "Play", "Cont", "Req",     "All", "None", "Flip", "Wait",      "DIR", "OS9", "Quit",      ""};void cmdslist() {     register char  *cp;     char ch, **s;     s = cmds;     /* printf("Cmds: "); */     while( *(cp = *s++)) {          printf(" \x1f\x20%c\x1f\x21%s", *cp, cp+1); /* Invert initial */     }     printf("\n\l");}/* eof jmenu.c */