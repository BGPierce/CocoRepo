/* file JUKE.C  -2-*  Main prog for UltiBox MIDI Score Player*/#include <stdio.h>#include "jmuse.h"#include "jcolors.h"#define PREFFILE     "/dd/SYS/UM3.Init"extern Record  records[];extern STAFF     staves[];extern direct sexy     forergb,     uptime, dntime,     /* mouse click timers */     curcurse,           /* current cursor type */     nstaves,     broke;              /* BREAK intercept control */int  breaker();          /*   and interceptor fcn */char barmice();extern direct sexy     delay;extern direct Index     nevents;extern direct int     nrecords,     nbars, numer, nzones, denom;extern direct bool     repeat, midiser, midipak;extern char     filename[], dirname[],     *bulk1, *bulk2, *bulk3, *bulk4, *bulk5;extern direct sexy     notemin, notemax;extern direct ubyte     midinnmin, midinnmax;void playone(rec)   int     rec;{     strcpy(filename, records[rec].recname);     records[rec].played = TRUE;   /* now, in case file can't open */     if( !diskio(filename) )          return;/* show title, start playing */     report();     play();     killem(0);     wkill();  /* for report() above */}main(argc, argv)  int     argc;  char    **argv;{    char    *bulk;    char    buff[SFILENAME+1], *cp, char1;       /* for main menu */    sexy    newkeys, oldkeys;   /* SHIFT, CTRL stuff */    int     i, rec;     bulk = bulk1;     bulk = bulk2;     bulk = bulk2;  /* to add a little more bulk by command itself */     bulk = bulk2;     bulk = bulk2;     bulk = bulk2;     bulk = bulk2;/*   bulk = bulk3;     bulk = bulk4;     bulk = bulk5; *//* Enable BREAK and ^C interception ASAP */     broke = 0;     intercept(breaker);/* Defeat CR-LF mis-processing */     stdout->_flag |= _RBF;     ourtmode();     *filename = *dirname = '\0';     uinit();  /* Defaults 1st *//* Read User Preferences file next, so Args can override it */     prefio();/* Process cmd line args 3rd.  Flags can have own '-' or share some. */     for(i = 1; i < argc; i++) {          cp = *(argv + i);          if(*cp == '-') {  /* Collect the goodies */               while(char1 = *++cp) {                    switch(char1) {                    case 'p':      /* Coco-MIDI Pak */                         midiser = FALSE;                         midipak = TRUE;                         break;                    case 's':      /* Serial Port */                         midiser = TRUE;                         midipak = FALSE;                    }               }          }/* Use this as a CHD directory */          else {     /* no '-' in arg; assume pathname */               strcpy(dirname, cp);          }     } /* argc loop *//* Got all the cmd args *//* Set up some colors */     printf("\x1b\x32%c\x1b\x33%c\x1b\x34%c",FORE,BACK,YESNOBACK);     pal(FORE, 077);         /* Bright White */     pal(MAINBACK, 000);     /* Black!  Was Dark Gray 007 */     pal(AVAILBACK, 040);    /* Med Red, use white */     pal(SELECTBACK, 020);   /* Med Grn, use black letters */     pal(ALERTBACK, 060);    /* Med Yellow NICE but not against Green */     pal(YESNOBACK, 010);    /* Med Blue, use white */     pal(TITLEBACK, 064);    /* Orange, use black */     pal(CHOICEBACK, 060);   /* Med Yellow again */     if(*dirname)  {          if(chdir(dirname)) {     /* Bass-ackwards return code */               printf("\n\lCan't get to '%s'\n\l", dirname);               *dirname = '\0';          }     }/* DiRead scores.ume into array */          nrecords = diread();/* MAIN LOOP -- load dir, get selections, play, ... */    for(;;) {          menu(TRUE);   /* Returns only when ready to Play *//* Playing Scores Loop */replay:          while( (rec = next()) >= 0) {               playone(rec);               menu(FALSE);     /* piece done, go to next */               if(nevents == -2)                    break;     /* if hit ^C, ignore, go to next */               if(broke == 2) /* Hit BREAK, break out */                    break;               if(delay)                    sleep60(60 * delay);          } /* playing loop */     /* If Repeat, set all records to unplayed and restart */          if(repeat && (broke != 2)) {               unplayall();               goto replay;          }          broke = 1;     /* ignore BREAKs when not playing *//* Foot of Main Loop, recycles to menu */     } /* Main Loop */     killem(0);     /* return all buffer memory */     os9tmode();     exit(0);}/* Find unplayed lowest nonzero Selection Index *//* Called by menu() also. */int next() {     int  minn, who, ord, rec;     minn = 32767;     who = -1;     /* invalid */     for(rec = 0; rec < nrecords; rec++) {         if( !(ord = records[rec].order) || records[rec].played )               continue;         if(ord < minn) {               minn = ord;               who = rec;         }     }     return(who);}/* Reset all records to Unplayed */unplayall() {     int  rec;     for(rec = 0; rec <nrecords; rec++)          records[rec].played = FALSE;}/* Read/Write user's preferences to/from file */prefio() {     int       chan;     notemin = midinnmin = 12;     /* In case not defined in file */     notemax = midinnmax = 108;     if((chan = open(PREFFILE, 1)) < 2)          return;   /* Don't complain *//* No. of bytes must match jdp.c !!! */     read(chan, &forergb, 16);     close(chan);     notemin = midinnmin;     notemax = midinnmax;}/* eof JUKE.C */