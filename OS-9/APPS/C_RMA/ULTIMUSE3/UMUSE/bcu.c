/* file ~VM640/BCU.C  -9-  Cursor & Menu Graphics routines *//* Also chosen to receive all the Fragged-Fcn Linkers!  Lucky you!*  NOTE:  All printf() pipeline feeders that end in '\n'*    require Fran to eat the \n as an extra Arg, so her entry*    for that fcn will have an arg count high by +1.*/#include <stdio.h>#include "wmuse.h"#include "wcodes.h"#include "wmenu.h"#include "mencodes.h"#include "windows.h"#include "screen.h"#include "cursors.h"#include "vmem.h"#include "soowee.h"extern int     tooly;extern direct FILE  *fmidi;   /* faked as int* in bdp.c & play.c */extern direct ubyte     arg0, arg1, arg2, arg3, arg4, arg5;extern NOTE     brush;extern char     filename[];extern direct Index     nevents, lftind, ritind;extern direct short     nstaves, nparts, nbars, numer, denom;extern direct char     *pct3, *pct4, *pct5, *pct6, *pct7, *pctn1, *pctn2, *pctn4;extern sexy     curcurse,     broke;extern void     barenum(), hitenter();extern int     printf();extern direct bool     mididev, smf, pldebug;extern Index   plind, prind;/******* Fragged subr modules couplers *******//* Fwrite() for non-stdio fraggies like Show.  Adds stdout. */int owrite(buff, count)  char    *buff;  int     count;{     return(fwrite(buff, 1, count, stdout));}/* Like above, but even better at eliminating junk args, using &arg0 */void nfwrite(howmany)  int     howmany;{     fwrite(&arg0, 1, howmany, stdout);}/* For /MIDI Playing, incl. .SMF */void putmidi(b)  sexy    b;   /* really ubyte */{     putc(b, fmidi);}/* For new .SMF "playing" */void smfwrit(where, cnt)  ubyte   *where;   /* could be anything */  int     cnt;      /* of cnt bytes long */{     fwrite(where, cnt, 1, fmidi);}void mflush(){     fflush(fmidi);}/* Open & close /MIDI here, to keep Play <stdio>-free;*    play just checks for non-null fmidi. */void play(first, last)  Index first, last;{     char mfname[34];     Reg void (*fcnp)();     automouse(FALSE);/* Play() also checks for successful file opening */     if(mididev || smf) {          for( ; ; ) {   /* attempts to fopen fmidi */               if (!smf)                    strcpy(mfname, "/MIDI");               else {                    dialogue(FALSE);                    printf("New .MID file: ");                    gets(mfname);                    wkill();                    if( !*mfname)                        return;                    *(mfname + 25) = '\0';                    strcat(mfname, ".mid");               }               if((fmidi = fopen(mfname, "w"))) {                    fmidi->_flag |= _RBF;                    break;    /* out of loop, success! */               }               else {                    alert("***Can't open /MIDI or File, try again.", 0);                    if( !smf)                        return;               }          } /* for *//* Is this REALLY needed? */          if( !timesig() ) {               numer = denom = 4;               timesig();          }     }     Playit(first, last);     if(mididev || smf)          fclose(fmidi);}/***** End of frags ***/void bell() {     putc(7, stderr);     fflush(stderr);}/*** Mouse and keyboard reading functions for graphics menus ***//* Wait for mouse to be released.  No-op if not being held. */void waitmouse() {     int     x, y;     while(mouce(&x, &y) != 0)          tsleep(4);     /* meaning 3 ticks */}/* No-frills mouse or keypress reader.  No echo, no cursors.*  Just mouce(), except that*  a positive return is a keyboard char, and FIRE is -1. */int kmouse(x, y)    /* yes, int, not char or bool */  int     *x, *y;{     char ch = 0;     if(mouce(x, y))          return(-1);     if(testkey())          read(0, &ch, 1);     return(ch);}/* General fcn to follow the mouse until button is pressed*    or a char is typed.  Does NOT echo.*  Returns NULL char if button is pushed (so caller shud read x, y),*    else the char.*/char keymouse(x, y)  int     *x, *y;      /* better give pointers! */{     int  oldx, oldy;     int  fire;     char ch;     oldx = oldy = 0;/* Wait for previous mouse push to release */     waitmouse();     cursor(oldx, oldy);      /* to get erased in loop *//* Main loop */     for( ; ; ) {          if( (fire = kmouse(x, y)) ) { /* anything? */               if(fire < 0)   /* Button? */                    ch = '\0';               else                    ch = fire;               break;          }     /* No button, no keys.  Update cursor if moved */          if((*x != oldx) || (*y != oldy)) {               cursor(oldx, oldy);           /* erase old */               cursor(oldx = *x, oldy = *y); /* draw new */          }          else               tsleep(2);     }     cursor(oldx, oldy);      /* leave no mouse droppings! */     return(ch);} /* keymouse() *//* Ask yes/no question. GRAFIX version. Prompt must supply own "? " if wanted. * May be in text or grafix mode. * No defaults accepted.  No newlines needed OR desired. * Ignores BREAK char already in stream. * "Floats" along with mouse 96-2-19.*/bool yesno(prompt)  char *prompt;{     sexy x, y, oldcurse, leftx, topy;     bool ret;     char ch;     automouse(FALSE);     mouce(&leftx, &topy);     leftx = (leftx >> 3) - (YN_COLS/2);     /* center, in pixels */     if(leftx < 2)          leftx = 2;     if(leftx > (COLS-2-YN_COLS))          leftx = COLS-2-YN_COLS;     topy += ((YN_ROWS+2) * 7) / 2;     if(topy > HM1-2)          topy = HM1 - 2;     if(topy < (YN_ROWS+2)*7 )          topy = (YN_ROWS+2) * 7;     printf("%c%c%c%s", YSNO, leftx, topy, prompt);    /* Fran puts it up */     flush();     oldcurse = curcurse;     curset(CBUTTON);  /* diamond */     for(;;) {          ch = keymouse(&x, &y);          if( !ch) {     /* Mouse click */               if( (y <= YN_UL) && (y >= YN_LL) ) {                    x >>= 3;                    if((x >= YES_L) && (x <= YES_R))                         ch = 'y';                    else                    if((x >= NO_L) && (x <= NO_R))                         ch = 'n';               }          }          if(ch == 'n') {               ret = FALSE;               break;          }          if(ch == 'y') {               ret = TRUE;               break;          }          if(ch == 5) {  /* BREAK */               continue;          }          bell();     }         /* loop */     wkill();     curset(oldcurse);     flush();       /* was fflush(stdout) */     waitmouse();     return(ret);}/* alert()  GRAFIX version.  Error and warning alert boxes for user.*  Restores previous cursor type.  UNSIGNED format as of 89/10/01.*  Pops it up centered on current mouse 96-2-20.*/void alert(msg, nargs, n1)   /* PLUS  n2, n3, n4, ..., n7 */  char    *msg;     /* MUST be null-terminated; '\n' optional */  int     nargs,    /* May be zero; negative gets Signed print. */          n1;       /* AND n2, ... n7 */{     Reg int   *sp;     /* Stack Pointer */     sexy      oldcurse, xc, y;     bool      signed;/*     bell(); */     mouce(&xc, &y);     xc = (xc >>3) - (AL_COLS/2);  /* center, in columns */     y += (AL_ROWS * 7)/2;/* Assume fterm() does safety checks on this */     wcreate(xc, y, AL_COLS, AL_ROWS, TRUE, WSSHADOW);     printf(msg);     oldcurse = curcurse;     curset(CBUTTON);  /* diamond */     if(signed = (nargs < 0))          nargs = -nargs;     nargs &= 7;             /* Test your brakes ... */     for(sp = &n1; nargs > 0; nargs--)  /* Portable?? */          printf(signed ? " %d" : " %u", *sp++);     putchar('\n');     hitenter();     wkill();     curset(oldcurse);     fflush(stdout);     /* waitmouse();     /* hitenter() does this */}void dialogue(big)    /* Open a small Double window */  bool    big;{     wcreate(14, 110, 50, big ? 5 : 2, TRUE, WSDOUBLE);}void monologue() {  /* Open smaller, off-center Shadow window */     wcreate(38, 140, 34, 4, TRUE, WSSHADOW);}/* Wait for user.  No cursor shud be showing, even on call 90/5/5 */void hitenter() {     int  mx, my;     char ch;     automouse(FALSE);     printf("  Hit ENTER or CLICK to go on:");     alcurset(TRUE);     flush();     waitmouse();        /* wait for release */     for( ; ; ) {          if( (ch = kmouse(&mx, &my)) == '\n')  /* user ENTERed */               break;          if(ch == -1) {        /* user Clicked */               waitmouse();               break;          }          tsleep(2);     }} /* hitenter() *//*** End of graphic menus Mouse fcns ***//*** Commands to Fran ***//****** Turn Alpha Cursor on/off.  Note that menu() turns it off. */void alcurset(onoff)  bool    onoff;{     printf(pctn2, ACUR, onoff);}/** Flush and make sure Fran reads it; she takes the \n as an Arg. */void flush() {     printf(pctn1, FLSH);     fflush(stdout);     /* yes this is necessary!  Why?? */}/***** Put up "This takes time" warning, till wkill()'ed */void patience() {     printf(pctn1, PATI);     flush();}/*** Make Fran print one of the stock menus *//* DO NOT take out the trailing '\n' w/out changing Fran's end */void menu(code)  sexy    code;{     printf(pctn2, MENU, code);     fflush(stdout);     /* no extra bytes, in case of menu args */}/*** Open a Pat & Vanna overlay window ***/wcreate(leftcol, topy, colswide, rowshigh, dosave, style)  sexy    leftcol, topy, colswide, rowshigh, style;  bool    dosave;{     printf(pct7, OWST, leftcol, topy, colswide, rowshigh, dosave, style);     flush();}/*** Close above window type ***/wkill() {     printf(pctn1, OWEN);}/************************* Set or reset Grafix Cursor Type, and update global curcurse.* Best done when no cursor is showing.*/void curset(curtype)  sexy    curtype;{     curcurse = curtype;     printf(pctn2, SCUR, curtype);}/******************************************************** cursor()    Graphics cursor for ultimuse mouce* Each call either draws or erases the cursor.* Very 1st call should NOT be to erase, else get patch of*   garbage on screen!*/void cursor(x,y)  int     x;   /* yes, Pixels! */  sexy    y;{     if(x < 0)      /* Avoid noise in lower left corner 90/3/24 */          return;/* Let Fran tune it up, but avoid wrap-around of Y */     if(y < 0)          y = 0;     printf(pctn4, DCUR, *((char *) &x), x, y);     fflush(stdout);     /* faster on Fran than flush()? */} /* end cursor() *//****** Menu-Drawing Functions, mostly for main() ******//* Clear & draw the scroll bar area (lines & arrows & scrollbar)*  Arrows need that SCROLTOP-SCROLBOT == 8.*/void scroll() {     printf(pct7, SCRL, *((char *)&nevents), nevents,       *((char *)&lftind), lftind, *((char *)&ritind), ritind);} /* scroll() *//* Draw the upper Pulldown Menu Bar */void dmenbar() {     putchar(MBAR);}/* Open pseudo-window over usual Menu Bar and print given phrase in it.*  Unlike real window, may overlay this over and over with different phrases,*  and kill it simpy by dmenbar().  Strictly look-only for user. */void barwindow(xc, str)  int     xc;  char    *str;{     yclear(SCORTOP+2, 190);     phrase(xc, 191-5, str, FALSE);}/* Draw pretty space-wasting side borders, which clear off Staff ends.*  Can trespass on Scroll Bar; it's drawn later and will win.*/void mainbord() {     putchar(MBRD);}/* Draw the tool box of palettes, bottom at global 'tooly' */void drtools(type, triplets)  sexy    type;     /* 0==rest, 1==note, 2==window */  bool    triplets;{     /* if(tooly < 0) tooly = 0; */     printf(pct4, RFTB, tooly, type, triplets);}/* As of 88/11, specs call for Rep Note/Rest info to be sent*  separately from 'cur' and the order to draw it.*  Until mused() incorporates whatever advantage of this,*  we'll update Note info only when cur==CBRUSH ==> note/rest. */void drawrep(repxc, repy)  sexy    repxc, repy;{/* If note/rest, send update just in case */     if( (curcurse==CBRUSH) || (curcurse==CSMASH) || (curcurse==CPLUS) )          defrep(&brush);     if(repy < 0)   repy = 0;     printf(pct4, DREP, repxc, repy, curcurse);flush();}void defrep(nptr)  NOTE    *nptr;{     printf(pct5, DFRN, nptr->slot, nptr->dur,       nptr->durmod, NORMAL /* nptr->artic */ );}/* Erase Rep, assuming Fran remembers where it is! */void erasrep(){     printf(pctn1, EREP);}/** End of Menu Graphics **//****** RANDOM User Interface text fcns *******//* Convert Hex string into integer.*  DOES NOT stop at non-Hex chars yet, so must be null-terminated! */hexatoi(s)  char    *s;{     int  d, val = 0;     char ch;     while(ch = *s++) {          d = hexc2i(ch);     /* returns 0 for non-hex char, too bad */          val = (val << 4) + d;     }     return(val);}#ifdef PRTNOTEvoid prtnote(np) NOTE *np; {    printf(      "   Du=%d, DM=%d, Slot=%d,\n  PM=%d, Ar=%d\n",      np->dur, np->durmod, np->slot,      np->pitmod, np->artic);}#endif/* BREAK-key catching fcn.  Also does ^C for Play().*  Does RTI, not RTS, to point of BREAK.*  Puts signal type into global 'broke'.*  1st time just sets broke; 2nd time tries to quit,*    setting broke = 99 to prevent stack overflow (see below).*  Externally clearing 'broke' resets everything.*  Random Menu calls this for 'q' command also.* 89/11/24  Protected by '99' from multiple BREAK/^C's.*/void breaker(sigtype)  int sigtype;{     char buff[81];     if(broke) {     /* not Playing */#ifdef SIGALERT          if((sigtype != 3) && (sigtype != 2))  { /* neither ^C nor BREAK */               alert("***SIGNAL #", 1, sigtype);               return;   /* RTI */          }#endif/* Printer Screen Dump on ^C if not playing */          if(sigtype == 3) {  /* ^C or SHIFT-BREAK */               dump();               return;   /* RTI after printout */          }/* BREAK key... */          else if(broke == 99)     /* inside the Quit Yes/No */               return;   /* RTI from extra breaks */          else {               broke = 99;    /* Indicate inside Quit question */               if( !yesno(" Quit UltiMusE-III ? ")) {                    broke = sigtype;    /* reprieved; unset 99 mode */                    return;   /* RTI == Return From Interrupt */               }          }/* Here is the ONLY WAY OUT of this whole program!  Really! */          sprintf(buff, "Save Score '%s' ?", filename);          if((nevents > 2) && yesno(buff))               Diskio(filename, TRUE, 'u', TRUE, FALSE);          wkill();  wkill();  /* in case overlaying another overlay */          unload("Um3S");          unload("Um3L");          unload("Um3T");    /* 91/10/01 includes Transp and Um3Go */          unload("Um3P");          unload("Um3D");          unload("Um3E");     /* 93/4/27 */          unload("Um3M");     /* 95/8/30 */          unload("Um3B");     /* 97/4/6 */          unload("Um3K");     /* 98/3/17 */          killem(0);          killpage(EVTPAGE);          system("tmode echo pause");       /* keysense();           /* Guarantee normal keyboard */       /* write(bwchan, "\x1B\x24", 2);      /* DWEnd */          exit(0);  /* closes bwchan and EOFs Fran's pipe */     } /* if(broke) *//* While PLAYing, broke == 0, comes here */     broke = sigtype;    /* Play() needs to know which key */     printf("\n");       /* for play-tracing window */     /* fall out == RTI */} /* breaker() *//* eof ~Vm640/BCURSE.C */