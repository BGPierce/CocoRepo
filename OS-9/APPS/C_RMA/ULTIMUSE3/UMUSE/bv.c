/* ~VM640/BV.C (BVIRT)  Buffer Virtual-score-memory subrs      89/08/23 ** 89/08/20 code for Grafix Buffers steda Data Modules.** NOTE: Pages are numbered from 1, not 0.* Not clear whether you can assume that every grafix buffer will* map into the same 8K block (if subrs are swapping too),* nor that every buffer will have the same offset.  (Size is constant.)* Would be a hell of a big help -- database and curptop wud be constants.** AGENDA:*    *Create (load) new modules as score expands*    *Unlink old modules as score shrinks (or after write-out)*    ?Protection against incrementing indices off limits*//* #define DEBUG 1 */#include <stdio.h>#include <os9.h>#include "wmuse.h"#include "vmem.h"#define BWCHAN 0    /* StdIn, L2 window to "support" Buffers *//* Following are in vmem.h but repeated here for reference */#ifdef NOVMEMH#define EVTARSIZ    4096#define EVTPAGE     34   /* Score can use 1 up to 33 */extern direct Index     nevents;/* Virtual Memory items */extern direct EVENT     *curevp,       /* current event pointer */     *database,     /* Bottom of current page (1st byte's addr) */     *curptop;      /* highest event ptr possible on current page */extern direct Index     curind;   /* current index */extern direct sexy     group,    /* buffer group, usually our PID */     curpage,  /* current page no. */     nmpages;  /* how many pages are in memory */#endifEVENT     *i2p(), *plusplus(), *decdec();bool pswap(), makepage(), killpage();/* end of VMem items *//* Immediate-Events (MIDI bytes) buffer vars */extern ubyte     *evtarray,     /* a "database" pointer to mapped block */     *evtartop,     /* to last usable byte */     *evtarnxt;     /* to next (1st unused) byte */ubyte *mapbuff(), *swapevts();/********* Functions ********//* Theoretically this function is not needed at startup,*  but only for restart.  Unforchly, L2 can't read theory books.*  Init the virtual memory system, but not the pointers: */void vinit() {     killem(0);     /* in case previous PID ran grafix */     curpage = nmpages = 0;}/* New Buffer for old.  Cheaper than DataMod pages.... *  Updates Globals: curpage, database, cureptop.*  Creates solid block of new pages as needed.*  Returns TRUE iff there is (still) a valid page mapped in at all. */bool pswap(page)  sexy    page;{/*   if(page == curpage)     return(TRUE);  /* No coals to Newcastle *//* Swap out old, if any */     mapbuff(curpage, FALSE);      /* mapbuff() checks for ==0 *//* Want to swap in new? */     if( !(curpage = page) )       /* Means don't map anything new in */          return(FALSE);           /* better not to NULL out database *//* Create new page(s) if needed *//* ONE centralized "Out of Memory" message -- Right HERE! */     for( ; nmpages < page; )      /* test added 89/10/13 */          if( !makepage(++nmpages)) {               curpage = --nmpages;     /* BUG FIXES 89/10/13, 15 */               alert("\007 Out of Memory Blocks!", 0);               return(FALSE);          }/* At last... */#ifdef DEBUG     alert("PSwap, mapping in CurPage=", 1, curpage);#endif     database = (EVENT *) mapbuff(curpage, TRUE);     if(!database)          return(FALSE);     curptop = database + (PNEVENTS - 1);     return(TRUE);}/* Given a good-old-style index, *  swap in the page and compute the pointer.*  Slowest thing you can do, if page swaps.*  Unlike plusplus() and decdec (), this i2p() will try to extend*    pages beyond nevents, and return NULL if it can't.*  CALLER MUST TEST RETURN FOR NULL if increasing nevents!!!*    Best is to pre-test bigger nevents by if(i2p(nevents-1)) *  Negative values (bad!) return the previous curind, have no other effect.*/EVENT *i2p(ind)  Index ind;{     int  page;     if(ind < 0)    /* Safety added 90/3/4 */          return(curevp);     /* the previous one */     curind = ind;/* Repeated subtraction to get quotient and remainder */     for(page = 1; (ind -= PNEVENTS) >= 0; page++)          ;     ind += PNEVENTS;    /* restore after last subtract *//* Swap data pages if needed */     if(page != curpage) {          if( !pswap(page))   /* out of memory? */               return(NULL);  /* CALLER MUST TEST when extending score */     }     return(curevp = database + ind);}/* Increment current pointer by one Event.*  Will not auto-extend score pages like i2p().*  Let if go off the end of nevents, so caller can (must!) check,*    but then don't tickle pswap().*    Instead, return previous unchanged curevp;*      later version may return NULL once callers' code is updated.  */EVENT *plusplus(){     if( ++curind < nevents) {     /* prevents auto-extend */          if(++curevp > curptop) {               pswap(curpage + 1);                curevp = database;          }     }     return(curevp);}/* Decrement by one.  Let curind go <0 but hold page=1 and curevp=0. */EVENT *decdec(){     if( --curind >= 0) {          if(--curevp < database) {               pswap(curpage - 1);               curevp = curptop;          }     }     return(curevp);}/*************** Grafix Buffer routines *//* Create (allocate) a grafix buffer *//* Used by both our "events" and MIDI_Events. */bool makepage(num)  sexy    num;{     char args[6];#ifdef DEBUG     alert("MakePage, making page ", 1, num);#endif     if( !num)          return(FALSE);     args[0] = 0x1b;     args[1] = 0x29;     args[2] = group;     args[3] = num;     *((int *)(args + 4)) = PAGESIZE;     if( write(BWCHAN, args, 6) != 6) {          curpage++;          /* shut up "**killing curpage!" */          killpage(num);      /* maybe it already exists */          curpage--;          if(write(BWCHAN, args, 6) != 6) {#ifdef DEBUG               alert(" **Can't Make Page ", 1, num);#endif               return(FALSE);          }     }     return(TRUE);  /* covers both "else's" */}/* Kill (de-allocate) a grafix buffer.  Num==0 kills whole group, silently.*  No Globals are diddled (or checked, except curpage). */bool killpage(num)  sexy    num;{     char args[4];/* alert("KillPage, killing page", 1, num); */     if(num && (num == curpage))          alert("**Killing CurPage! ==", 1, curpage);     args[0] = 0x1B;     args[1] = 0x2A;     args[2] = group;     args[3] = num;     if( (write(BWCHAN, args, 4) != 4) && num) {#ifdef DEBUG          alert(" **Can't Kill Page ", 1, num);#endif          return(FALSE);     }     return(TRUE);}/* Kill off all pages, if any, ABOVE the given number, adjusting globals.*  Give 0 to kill them all individually, BUT NOT the mass coup de grace;*    for that, must do killpage(0). */void killem(page)  sexy    page;{/* NEVER kill the currently mapped-in page! */     if(curpage > page)          pswap(page);   /* if page==0, then no page is mapped */     for( ; nmpages > page; )          killpage(nmpages--);}/* Kill off any buffers not needed by current score */void giveback() {     i2p(nevents - 1);   /* swap in highest in-use page */     killem(curpage);}/* Map a buffer into or out of our address space.*  If into, return its address (pointer); garbage if out.*  All errors return NULL.*  NO Globals set or consulted.*  Used by MIDI_Events subrs too.*/ubyte *mapbuff(num, in)  int     num;  bool    in;       /* TRUE in, FALSE out */{     struct registers    regs;     if( !num)           /* callers WILL do this normally! */          return(NULL);     *((char *) &num) = group;/* high byte */     regs.rg_a = BWCHAN;      /* Path */     regs.rg_b = 0x84;        /* SS.MpGPB, p.8-122 */     regs.rg_y = in;     regs.rg_x = num;         /* group << 8 | num */#ifdef DEBUG alert("MapBuff(Grp, #, I/O)", 3, group, num, in);#endif     if(_os9(0x8E, &regs)) {  /* 8E=SetStat, NOT 8D=GetStat! */#ifdef DEBUG          alert(" **MapBuff error ", 3, regs.rg_b & 255, num, in);#endif          return(NULL);     }     if(in && (regs.rg_y != PAGESIZE)) {#ifdef DEBUG            alert(" \007**Buffer # has Size at loca\n", 3,               num & 255, regs.rg_y, regs.rg_x);#endif            return(NULL);     }     return(regs.rg_x);  /* ignore this if mapping out */} /* mapbuff *//************* End of grafix buffer routines *//* Initialize the "outline" Immediate Events array *//*** Initialize, or re-init.  Return no. of bytes available*      or given cnt, whichever is smaller; this acts as limiter*      on diskio()'s read-in array sizes. *//* Swaps in and out */int ievtinit(cnt)  int     cnt;{     if(cnt <= 0)          cnt = 1;#ifdef DEBUG     alert("IEvtInit: cnt==, evtarray==", 2, cnt, evtarray);#endif     if( !evtarray) {    /* very 1st call */          if( !makepage(EVTPAGE)) {               alert("Can't create Events buffer!\n", 0);               return(0);          }     }     evtarray = swapevts(TRUE);#ifdef DEBUG alert("IEvtInit: EVTARRAY at", 1, (int)evtarray);#endif     if( !evtarray) {          alert("***Can't allocate Events array!\n", 1, EVTARSIZ);          swapevts(FALSE);          return(0);     }     evtartop = evtarray + (EVTARSIZ-1);     /* Last usable byte */     evtarnxt = evtarray + 1;    /* waste 1st byte so Null offset is invalid */     *evtarray = 0xEA;           /* and it says "Event Array" */     swapevts(FALSE);     return( (cnt < (EVTARSIZ-1)) ? cnt : EVTARSIZ-1 );} /* ievtinit() *//* Swap the Immed Events buffer in and out.* Returns (and updates) global "evtarray" ptr to base,*  which is NULL on failure.* Swapping out (back to Score) returns most recent swapped-in evtarray.* Like pswap(), but does NOT create any new pages,* nor does it diddle ANY globals besides evtarray.*/ubyte *swapevts(inout)  bool    inout;{     ubyte     *oevtarray;    /* for test only */#ifdef DEBUG     alert("SwapEvts:", 1, inout);#endif     if(inout) {          oevtarray = evtarray;    /* most recent previous swap-in */          mapbuff(curpage, FALSE); /* out with score */          evtarray = mapbuff(EVTPAGE, TRUE); /* in with ImmEvents */          if( !evtarray)               alert("Can't map ImEvts!\n", 0);#ifdef DEBUG          else               alert("Mapped Evts at", 1, (int)evtarray);#endif/* Remove test code someday ... */          if(oevtarray && (evtarray != oevtarray)) {               alert("EvtArray moved!\n", 2, oevtarray, evtarray);               evtarnxt += (evtarray - oevtarray);               evtartop += (evtarray - oevtarray);          }/* end of test code */     }     else {    /* swap it out */          mapbuff(EVTPAGE, FALSE);          mapbuff(curpage, TRUE);  /* ASSUME it doesn't move! */     }     return(evtarray);   /* new or previous */} /* swapevts() *//* eof BVirt.c */