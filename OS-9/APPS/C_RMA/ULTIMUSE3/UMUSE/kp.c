/* KP.C  COCO begun 97/11/07  KeyPad Input and Editing module*  98/3/31     Autoclone mode added; Screen-move and Entry modes removed.*/#define FRAG 1/* #include <stdio.h> */#include "wmuse.h"#include "vmem.h"#include "wmenu.h"#include "screen.h"#include "cursors.h"#include "macros.h"#include "chars.h"#include "windows.h"#include "mencodes.h"#include "fcnptrs.h"#include "soowee.h"extern Index     lftind, ritind, gind, undind, godotind;extern sexy      xyoff, xgoal, nparts;extern ubyte     grafxes[], grafyes[];extern sexy      curcurse;extern NOTE      brush;extern bool      toolson, rfr_scr, rfr_men, rfr_rep, rfr_bar, pitcarry;extern PART      parts[];char     *index();/* sexy     repart(); *//* bool     exprmenu(); *//* Global where-at's */extern Index     lastclik,     /* last score item mouse-clicked */     kpind,     kplast,          /* most recent keypad score item visited */     kplastact;     /* ... and worked on too *//************ Modes, In bglob.c for Coco. */extern bool     autooct,     autopick,      /* Auto pick-up (edit and clone modes) */     autoclone,     /* autoly enter clone mode where proper *//*   kpview,        /* OK to shift viewscreen on entry */     kpclone;       /* '+' - like mode */extern char     kpmode;          /* h==Horizontal, v==Vertical, b==Bar/Block *//*   kpgoto;          /* Keypad last, Mouse last */     /* kpemode='i',     /* e==Edit, i==Insert *//* Local Statics, like for inter-fcn commo.  In Coco put in bglob.c */extern char     kpoctch,     /* Octave char */     kpnotch;     /* Note char */extern sexy          /* "Sexy" on Coco */     kpdur,     kpdmod, kpitmod,     kpartic,      kvslot,     kpoctave,     kplnotenum;          /* last note no. = 'c', for auto-octave */void kpmen();bool ispwexpr();/* Move the cursor according to given code "udlra",*  where "udlr" mean just what they say and ignore barlines,*  but 'a' means "advance," whose meaning depends on Modes.*  If 'mypart'<0, take part from current cursor.*  If code==a && mode==h, must beat current startime by newdur.*/void kpmove(code, mypart, newdur)  char    code;  int     mypart;  Deltime newdur;   /* how many ticks you must advance */{     Deltime   dt;     bool      added = FALSE;  /* added bars yet? Anti-loop */     Reg EVENT *ep;          /* alert("Move: kpind ==", 1, (sexy)kpind); */     ep = i2p(kpind);     if(mypart < 0)          mypart = ep->part;     newdur += ep->startime;  /* now == target time */     switch(code) {     case 'u':     /* Up */          for( ; ;) {               ep = decdec();               if(ep->part)                    break;               if(curind < 0) {                    curind = 0;                    break;               }          }          break;     case 'd':     /* Down */          for( ; ;) {               ep = plusplus();               if(ep->part)                    break;               if(curind >= nevents) {                    curind = nevents - 1;                    break;               }          }          break;     case 'l':     /* Left */          while(curind >= 0) {               ep = decdec();               if(ep->part == mypart)                    break;          }          break;     case 'r':     /* Right */          while(curind < nevents) {               ep = plusplus();               if(ep->part == mypart)                    break;          }          break;     case 'a':     /* "Advance" is hard; do 'd' or 'r' and watch for bars */                    /* And you must land on a note/rest! */          if(kpmode=='v') {     /* Vertical, do smart 'n' */               for( ; ; ) {                    ep = plusplus();                    if(curind >= nevents) {     /* ran off end, add bars */                         kpind = curind = nevents - 1;                         if(autopick || added) /* no add bars in "Edit" mode */                              break;                         (*paddbars)();                         added = TRUE;                         ep = i2p(kpind);                    } /* 'v' off end */          /* Don't stop on clone parts if in either clone mode */                    else if( (ep->part > 0)                      && !( (kpclone || autoclone)                        && (parts[ep->part].philo & NOFLAG)) )                    {                         break;    /* update kpind & return */                    }               } /* 'v' ++ loop */          } /* 'v' */          else {          /* Horizontal or Bar modes */               for( ; ;) {      /* Drive down & forward */                    ep = plusplus();                    if(curind >= nevents) {     /* End of score */                         kpind = curind = nevents - 1;          /* Add no bars if mypart is a Clone */                         if(autopick ||added || (parts[mypart].philo & NOFLAG))                              break;     /* returns after kpind update */                         (*paddbars)();                         added = TRUE;                         ep = i2p(kpind);                         if(kpmode=='b')                              ep = plusplus();     /* into 1st new measure */                    }                    if(ep->part == mypart) {                         if(kpmode=='h') {   /* must beat newdur */                              dt = ep->startime - newdur;     /* Must do unsigned compare in two steps, via signed dt */                              if(dt >= 0)                                   break;                              else                                   continue;                         }                         else                              break;    /* returns */                    }     /* Bar/Block mode, gets tuff */                    if( (kpmode=='b') && anybar(ep) ) {                         mypart++;                         if(mypart > nparts) { /* Finished with this measure */                              mypart = 1;                         }                         else {     /* Newline back to left barline */                              while(curind > 0) {                                   ep = decdec();                                   if(anybar(ep))                                        break;                              }                         }                    } /* 'b' mode hit barline */               } /* 'b' or 'h' ++ loop */          } /* 'a' sub-modes */          break;     default:          bell();     } /* switch */     kpind = curind;     if(kpind >= nevents)          kpind = curind = nevents - 1;} /* kpmove() *//* These set size and shape of the KP cursor */#define GENVOLY     (SCORTOP-3) /* where GenVols hang out near top */#define KPBELOW     3           /* no. pixels deep below center of target */#define KPABOVE     3           /* and above target *//* Given an index, draw/erase the KeyPad Cursor on its screen object,*  provided it is on the current screen (return TRUE if it is).*  Later may vary the cursor to suit the target object.*/bool kpcurse(ind)  Index     ind;{     int x, y, xleft;     Reg EVENT *evp;     if((ind < lftind) || (ind > ritind))          return FALSE;     x = grafxes[ind - xyoff];     y = grafyes[ind - xyoff] & 255;     xleft = x - 1;     if(y==0)          y = GENVOLY;     else {    /* Adjust X,Y for certain items */          evp = i2p(ind);     /* SAVE first?? */          if(evp->part && (evp->show.slot==REST))               y += (evp->show.dur==1) ? 3 : 1;          else if( !evp->part && ispwexpr(evp->show.INCTYPE)) {               xleft++;          }     }     Invert(xleft, y - KPBELOW, x+1, y + KPABOVE);     return TRUE;} /* kpcurse() *//* Add a notestring character to the buffer, and echo it. */char *kpbuffit(buf, cp, ch)  char     *buf, *cp, ch;{     if(ch==Ctrl('H')) {          cp--;          (*pputchar)(ch);     }     else if( (ch==Ctrl('U')) || (ch==Ctrl('X')) ) {          cp = buf;          (*pputchar)(ch);     }     else if((cp - buf) < 80) {          *cp++ = ch;          *cp = '\0';          (*pputchar)(ch);     }     else          bell();     return(cp);} /* kpbuffit() *//* Copy note under kpcursor into the defaults.*  98/3/7 New version is ALWAYS called by main loop and decides for self*    what to do, if anything.*  If not a note/rest, do nothing.*  Depending on modes and victim, the timing and pitch fields*    may indep'tly be copied, left as-is, or carried over from left.*  kvslot is always i2p(kpind)->show.slot even if pitches are*    carried from left.*/void kpickup(userp)  bool     userp;     /* User typed 'P' */ {     sexy     part, staffy, botnote, hilo, notenum;     bool     plusdo;          /* like main's doplus */     Reg EVENT     *evp;          evp = i2p(kpind);     part = evp->part;     kvslot = evp->show.slot;  /* must report this when cloning */     plusdo = ((kpclone || autoclone) && (kvslot !=REST));/* Copy victim's timings if appropriate.  Never look left for these. */     if(userp || autopick || plusdo) {          if( !part) {               if(userp)                    bell();               return;          }          kpdur = evp->show.dur;          kpdmod = evp->show.durmod;          kpartic = evp->show.artic;     }/* Copy pitches if proper.  Here, or look left? */     if( !(userp || autopick || kpclone || autoclone || pitcarry))          return;/* Local pickup */     if(userp || autopick) {          kpitmod = evp->show.pitmod;          notenum = kvslot;     }/* Look-left pitcarry pickup */     else if(pitcarry && (kpclone || autoclone || (kpmode=='v'))) {          if(plusdo && !(part = (*ppluspart)(kpind)))               return;          notenum = (*prepart)(kpind, part, &kpitmod); /* Lookin' Left! */     }     else          return;/* Convert staff & slot to note-num and octave */     if(notenum==REST) {          kpnotch = 'r';          return;          /* leave octave as is */     }     partstaff(part, &staffy, &botnote, &hilo);     if(botnote==0)      /* If Perc clef, use Bass's */          botnote = 12;     notenum += (botnote +7 - 1);     /* +7 gives oct++ */     kpoctave = (notenum / 7);     notenum -= 7 * kpoctave;     /* = notenum % 7 */     if(kpoctave > 7)     kpoctave = 7;     kpoctch = '0' + kpoctave;     kpnotch = "cdefgab"[notenum];     kplnotenum = notenum;} /* kpickup() *//* Make a string rep of current defaults */char *kprint(buff)  char     *buff;{     Reg char     *cp;     cp = buff;     /* dur = v, w, h, q, 8, 16, 32, 64 */     if(kpdur >= 5)          *cp++ = "136"[kpdur - 5];     *cp++ = "vwhq8624"[kpdur];/* durmod = _, ., .., /3 */     if(kpdmod==2)          *cp++ = '.';     else if(kpdmod==3)          *cp++ = '/';     if(kpdmod)          *cp++ = "_..3" [kpdmod];     *cp++ = kpnotch;/* pitmod = _, _, #, x, N, N, FF, F */     if(kpitmod==6)          *cp++ = 'F';     if(kpitmod >= 2)          *cp++ = "__#xNNFF" [kpitmod];     /* *cp++ = 'o';      /* not needed with numbers */     *cp++ = kpoctch;     *cp++ = "tlnms" [kpartic];     *cp = '\0';     return(buff);} /* kprint() */     /* Convert global fields, found by kparse(), to a note/rest,*    and insert it in score.  Return the part no.*  Clear out default durmod, pitmod, and artic after use,*    but leave other defaults to carry over. *//* In Clone mode:*     start by auto-picking up*     if victim is a Rest, notestring overrides defaults*     if victim is a Note, then IGNORE notestring's*       dur, durmod, and artic (ie, take only pit and pitmod).  After chip-bombing the rest:    make sure you stay put on it (kpind no move)  For additional notes:    use pluspart() to find victim parts      prompt if need more  Leave only on arrow, space, etc.*/Deltime kprocess(doplus)      /* returns rawdur of new note/rest */  bool     doplus;         /* really do a Clone job */{     NOTE      notemp;     char      *notes = "cdefgab";     Deltime   rawdur;     Index     tind;     bool      stemdn;     sexy      vslot, notex, notey, grind, diff;     sexy      staff, part, staffy, botnote, hilo, notenum;     EVENT     *ep;     Reg NOTE  *bp;     /* shortens code */          ep = i2p(kpind);     /* victim */     part = ep->part;     if(part==0) {          (*palert)("Must overlay a note/rest!\n", 0);          return(0);     }     vslot = ep->show.slot;/* Stuff for erase & draw */     grind = kpind - xyoff;     notex = grafxes[grind];     notey = grafyes[grind] & 255;     staff = partstaff(part, &staffy, &botnote, &hilo);     if(botnote==0)          botnote = 12;     rawdur = (*pcod2raw)(kpdur, kpdmod);/* Load the Brush with new note/rest */     bp = &brush;     bp->dur = kpdur;     bp->durmod = kpdmod;     bp->artic = kpartic;     bp->pitmod = kpitmod;/* Clear non-sticky defaults after this ONE usage */     kpitmod = 0;     kpartic = NORMAL;/* Well gee that was easy.  Now for some real work... *//* Convert note-letter early for auto-octave use too */     if(kpnotch != 'r')          notenum = index(notes, kpnotch) - notes;     /* "cdefgab" *//* From botnote, convert letter & octave to slot *//* First get octave no. */     if((kpoctch >= '0') && (kpoctch <= '7'))          kpoctave = kpoctch - '0';     else switch(kpoctch) {     case '+':          kpoctave++;          break;     case '-':          kpoctave--;          break;     case '=':          kpoctave = kpoctave;          break;     case '\0':     /* Null, try auto-octave */          if(kpnotch=='r')               break;          if(autooct) {               notenum = index(notes, kpnotch) - notes; /* "cdefgab" */               diff = notenum - kplnotenum;               if(diff <= -4)                    kpoctave++;               else if(diff >= 4)                    kpoctave--;          }     }     if(kpoctave < 0)          kpoctave = 0;     if(kpoctave > 7)          kpoctave = 7;     if(kpnotch != 'r')          kplnotenum = notenum;/* Already converted note letter to notenum 0--6 */     if(kpnotch=='r') {          bp->slot = REST;     } else {          notenum += 1 + (7 * (kpoctave - 1));          bp->slot = notenum - botnote;     }/* Above loads the Brush.  Below inserts it in score. *//* Install the sucker! */     if(doplus ) {          if( (part = (*ppluspart)(kpind)) ) {               hilo |= NOFLAG;          }          else {    /* Prompt to add another, but NOT if just autoclone */               if( !kpclone || !(part = (*paddclone)(staff, hilo))) {                    kpmove('a', -1, rawdur);                    return(0);               }          }          tind = (*penter)((*pfulltime)(kpind), part, bp->slot);          if(tind < 0)     /* enter() failed */               return(0);          CopyNoteP(&(i2p(tind)->show), bp);/* To avoid annoying screen redraws while cloning chords,*  sneak a cloned note into grafx/yes[] without showall().*  Get new 'grind' from enter()'s new 'tind',*  bubble up grafx/yes from 'grind' to 'ritind++',*  slip new clone's x and y into grafx/yes[grind].*/          grind = tind - xyoff;          for(diff = ritind - xyoff; diff >= grind; diff--) {               grafxes[diff+1] = grafxes[diff];               grafyes[diff+1] = grafyes[diff];          }          ritind++;          grafxes[grind] = notex;          rfr_scr = FALSE;     /* why we did all this work! */     }     else {     /* good old Bomb/Chip the chosen event */     /* First erase victim */          stemdn = Stemway(hilo, vslot);          (*pdrawnr)            (&ep->show, notex, notey, staffy, stemdn, hilo & NOFLAG, BACK);          rfr_scr = (rawdur != (*pcod2raw)(ep->show.dur, ep->show.durmod));          CopyNoteP(&notemp, bp);          (*pchip)(kpind, &notemp, rawdur, part);          undind = BADIX;          if(kpartic==TIED)               kpartic = NORMAL;     }/* Draw the new one, clone or bomb/chip */     if( !rfr_scr) {          /* could just always do it */          vslot = bp->slot;     /* RE-USE */          if(vslot==REST)               notey = staffy + Roffset(hilo);          else               notey = staffy + vslot + vslot;          stemdn = Stemway(hilo, vslot);          (*pdrawnr)(bp, notex, notey, staffy, stemdn, hilo & NOFLAG, FORE);          grafyes[grind] = notey;     }/* Under Autoclone, if no more clone available, then advance */     if(autoclone && !(*ppluspart)(kpind))          kpmove('a', -1, rawdur);/* Clean up */     brush.artic  = NORMAL;     /* un-Tie after each use */     brush.pitmod = 0;          /* don't distract user */     return(rawdur);} /* kprocess() *//* Parse one notestring, loading statics.*  Return TRUE iff blank or end of string is reached*  i.e., you ate the whole thing (no bad or leftover chars).*/bool kparse(buf)  char     *buf;{     bool     gotmain;     /* Got a Dur, got a Pit */     char     gotano, *cptemp;     char     *artics = "tlnms";     Reg char     ch;     Reg char     *cp;     /* also Reg on Coco */     cp = buf;/* Parse by field.  Each field shall leave cp just beyond itself. */     ch = *cp++;/* 'y' as in carrY means just like previous, keep all defaults */     if(ch=='y')          goto kpend;/* Try for Dur (size digit) */     gotmain = TRUE;     switch(ch) {     case 'v':     /* Breve */          kpdur = 0;          break;     case '1':     /* Whole or 16th */          if(*cp == '6') {               cp++;     /* skip it */               kpdur = 5;          } else {               kpdur = 1;          }          break;     case 'w':     /* Whole */          kpdur = 1;          break;     case '2':     /* Half */     case 'h':          kpdur = 2;          break;     case '4':     /* Quarter */     case 'q':          kpdur = 3;          break;     case '8':     /* Eighth */          kpdur = 4;          break;     case '6':     /* 16th or 64 */          if(*cp == '4') {               cp++;               kpdur = 7;          } else {               kpdur = 5;          }          break;     case '3':     /* 32nd */          if(*cp == '2')     /* '2' is optional, same difference */               cp++;          kpdur = 6;          break;     default:     /* No consumption, so reset pointer */          cp--;          gotmain = FALSE;     } /* Dur switch *//* Durmod parse.  If user gave a Dur, then Durmod defaults to None,*  except triplets stick till explicitly changed with '_' or dots. */     ch = *cp++;     switch(ch) {     case '.':          if( *cp=='.') {     /* Double-dot */               kpdmod = 2;               cp++;          } else {               kpdmod = 1;          }          break;     case '/':          if( *cp=='3')     /* '3' is optional, no difference */               cp++;          kpdmod = 3;          break;     case '_':               /* Force "nothing" */          kpdmod = 0;          break;     default:     /* if given a main Dur, and not sticky Triplets, force Nil */          if(gotmain && (kpdmod != 3))               kpdmod = 0;          cp--;     } /* durmod switch *//* Note parse -- the easiest stage! */     ch = *cp;     gotmain = FALSE;     if( ((ch >= 'a') && (ch <= 'g')) || (ch=='r') ) {          kpnotch = ch;     /* converts to slot number below */          cp++;          gotmain = TRUE;     }          /* Pitmod parse.  Pitmods are sticky but cleared after 1st usage *  by kprocess(); this saves Picked-up accidentals for editing. * Also giving a note (above) requires an explicit pitmod. *//* 0--7: = Null, n/u, #, ##,   Natch, n/u, bb, b */     ch = *cp++;     switch(ch) {     case '#':     /* Sharps */     case 'z':     /* sZarp (Polish :-) */     case 'S':          kpitmod = 2;          if((*cp=='#') || (*cp=='S') || (*cp=='z')) {               kpitmod = 3;               cp++;          }          break;     case 'x':     /* Double Sharp */          kpitmod = 3;          break;     case 'F':     /* Flats */     case 'p':     /* Phlat :-) */     case '-':          kpitmod = 7;     /* If next char is also Flat, it's a Double-Flat */          if((*cp=='F') || (*cp=='-') || (*cp=='p')) {               kpitmod = 6;               cp++;          }          break;     case 'N':     /* Naturals */     case 'H':      /* German B-natch */     case '=':          kpitmod = 4;          break;     default:     /* If pitch was given, default pitmod is None. */          cp--;          if(gotmain)               kpitmod = 0;     } /* pitmod switch *//* Octave parse. Small 'o' is optional but can force octave interp on*  the following char.  */     ch = *cp++;     gotano = '\0';     if(ch=='o') {          ch = *cp++;          gotano = 'o';     }     kpoctch = '\0';     if((ch >= '0') && (ch <= '7'))          kpoctch = ch;     else switch(ch) {          case '-':          case 'd':               kpoctch = '-';               break;          case 'n':               if(gotano)                    kpoctch = '-';               else                    cp--;     /* give 'n' to Artic */               break;          case '+':          case 'u':               kpoctch = '+';               break;          case '=':          case 'o':     /* "oo" means "o=" */               kpoctch = '=';               break;          default:               if(gotano)          /* Else kpoctch stays NULL */                    kpoctch = '=';               cp--;     } /* octave switch *//* Artic parse. Teflon.  0--4 = tie, legato, normal/none, marcato, stuccato */     ch = *cp++;     cptemp = index(artics, ch);     if(cptemp != NULL)          kpartic = cptemp - artics;     else          cp--;     /* Parse finished.  Test for proper completion: */kpend:     if((*cp=='\0') || (*cp==' ') || (*cp==ENTER))     /* ignore final blank */          return TRUE;     else          return FALSE;     } /* kparse() *//* Main "boss" fcn and interpreter during keypad edit mode.*  Many temporary experimental test cmds will be deleted later.*/void main() {       /* aka kpmain() */     char      buff[80];     sexy      dumxy;     int       cursave;     Index     entryind; /* screen's center when main() was called */     Index     back1;     Deltime   newdur;     bool      doplus,   /* have real cloning situation */               puser;    /* user typed 'P' */     sexy      vdur, vdurmod, vartic, vslot;     /* copies of picked-uppers */     char      ch;     char      *strind;     Reg char  *bp;      /* notestring Buffer pointer */     cursave = curcurse;     curset(CNONE);     barwindow(40-10, "KeyPad Input Editor");     /* flag top menu bar */     bp = buff;     entryind = (lftind + ritind) >> 1;#ifdef KPENTRY     if(kpgoto=='m')          kpind = lastclik;     /* else kplast by identity */#endif     if(kpind < 0)          kpind = 0;/* If off current screen, then center it in current screen*  unless permitted to move viewscreen */     if(((kpind <=0) || (kpind < lftind) || (kpind > ritind)) /* && !kpview */)          kpind = entryind;     back1 = kpind;     puser = FALSE;     rfr_scr = toolson;/* Keypad Main Loop: Pickup or Adjust defaults, Parse, Insert, Advance */     for( ; ; ) {          kpickup(puser);          /* may do nothing to defaults */          puser = FALSE;          vdur = kpdur;          /* Save timings in case of clone */          vdurmod = kpdmod;          vartic = kpartic;          vslot = kvslot;          /* for Rest test below only *//* Update screen */          if(rfr_scr)               Showall('s');          rfr_scr = FALSE;/* Draw special cursor */          if( !kpcurse(kpind)) {     /* musta gone off screen */               gind = kpind;               xgoal = 40;               /* center screen */               Showall('s');               kpcurse(kpind);          /* now should show up */          }          (*pflush)();          read(0, &ch, 1);     /* or use kmouse(&sexydum, &sexydum) */          kpcurse(kpind);          /* erase *//* If already buffering a notestring, then keep it up.** If not, then is char a possible notestring beginning?**       If so, start buffering with it.**   Otherwise, switch on that char as a command.*/     /* Pre-test for notestring char */          strind = index("y012345678abcdefgrhqvw./_#SzxFpNounslmt", ch);          if(bp > buff) {     /* Already buffering */               if( !strind && (ch != ' ') && (ch != ENTER)                 && (ch != Ctrl('h')) && (ch != Ctrl('u'))                 && (ch != Ctrl('x'))                 ) { /* Not legal in notestring */                    bell();                    continue;               }               bp = kpbuffit(buff, bp, ch);               if(bp == buff) {     /* in case ^H, ^X or ^U cleared it */                    wkill();                    alcurset(FALSE);                    continue;               }     /* Above checks for overflow and echos the char. */               if((ch==' ') || (ch==ENTER)) {                    wkill();                    /* alcurset(FALSE); */                    if(kparse(buff) || (*pyesno)(                      "Extra chars in string!  Use anyway?"))                    {          /* Handle Clone Mode here */kproc:                         doplus = (kpclone || autoclone) && (vslot != REST);                         if(doplus) {                              kpdur = vdur;                              kpdmod = vdurmod;                              kpartic = vartic;                         }                         newdur = kprocess(doplus);  /* translate & insert note */                         kplastact = kpind; /* mark scene of crime */                         if( !(kpclone || autoclone) || (kpnotch=='r') ) {                              back1 = kpind;                              kpmove('a', -1, newdur); /* cursor to next victim */                         }                    }                    bp = buff;                    wkill();               }          } /* inserting note *//* Start a notestring? */          else if(strind) {               dialogue(FALSE);     /* later use a better window? */               alcurset(TRUE);               /* drtools(2, 0); */ /* but this one doesn't disappear */               bp = kpbuffit(buff, bp, ch);               continue;          }/* Must be a command */          else {               switch(ch) {               case 'Q':     /* Quit, intuitive */               case 'k':     /* symmetric -- in and out! */                    kplast = kpind;                    godotind = kpind;     /* so "g." comes back here */                    curset(cursave);                    rfr_bar = rfr_rep = rfr_men = TRUE;                     return;               case 'H':      /* refresH screen */                    rfr_scr = TRUE;                    break;               case 'L':     /* connect notes of pars */               case 'R':     /* and include rests */                    (*ppartline)(ch=='R');                    break;               case '?':     /* Show current defaults */                    kprint(buff);                    dialogue(FALSE);                    (*pprintf)("Current Note: ");                    (*pprintf)(buff);                    (*pprintf)("   Hit ENTER: ");                    (*pgets)(buff);                    wkill();                    break;               case '+':     /* Enter Clone Mode */               case 'C':                    kpclone = TRUE;                    break;               case 'B':     /* Brush, leave clone mode */               case '-':                    kpclone = FALSE;                    break;               case 'D':      /* Duplicate the Default note */               case 'Y':     /* carrY previous note in part */                    goto kproc;               case 'P':     /* Pick up the note/rest */                    puser = TRUE;     /* for next kpickup() */                    break;     /* Goto's to last-kp or last-mouse-click */               case 'G':                    dialogue(FALSE);                    (*pprintf)                      ("Entry, or last Mouse, Keypad exit, Action keypad: ");                    (*pflush)();                    read(0, &ch, 1);                    wkill();                    switch(ch) {                    case 'e':                    case 'E':                         kpind = entryind;                         break;                    case 'm':                    case 'M':                         kpind = lastclik;                         break;                    case 'k':                    case 'K':                         kpind = kplast;                         break;                    case 'a':                    case 'A':                         kpind = kplastact;                         break;                    }                    break;     /* Real dumb test code -- just increment index */               case '=':     /* lazy man's '+' */                    if(kpind < nevents)                         kpind++;                    break;           /*  case '-':     /* has become "Leave Clone Chord" *//*                    if(kpind > 0)                         kpind--;                    break;               */     /* Official arrow-key moves */               case ' ':  /* Empty blank advances, even leaves clone chords */                    back1 = kpind;                    kpmove('a', -1, 0);                    break;/* On MM/1 this is BS, separate from LFTARROW */               case Ctrl('u'):     /* Back up to before last Advance */               case Ctrl('x'):                    kpind = back1;                    break;               case UPARROW:                    kpmove('u', -1);                    break;               case DNARROW:                    kpmove('d', -1);                    break;               case LFTARROW:                    kpmove('l', -1);                    break;               case RITARROW:                    kpmove('r', -1);                    break;               case '>':     /* whole screen right, same as mouse */                    gind = ritind;                    xgoal = 0;                    if(ritind == nevents - 1)                         (*paddbars)();                    Showall('s');                    kpind = (lftind + ritind) >> 1;                    break;               case '<':                    gind = lftind;                    xgoal = 78;                    Showall('s');                    kpind = (lftind + ritind) >> 1;                    break;               case 'M':     /* Menu of Modes */               default:                    kpmen();     /* same as 'M' */                    waitmouse();               } /* switch */          }     } /* cmd for() */} /* kpmain() */void kpmen() {     char          buff[BUFFSIZE];     sexy          oldcurse;     Reg char     ch;     oldcurse = curcurse;     curset(CBUTTON);     /* was CNONE */     for( ; ;) {          menu(MEN_KPM);/*        (*pprintf)("%d%d%d%d%d%d", autooct, autopick, kpclone,            (kpgoto=='k' ? 1 : 2), kpview,            (kpmode=='h' ? 1 : (kpmode=='v' ? 2 : 3)) );*/          (*pprintf)("%d%d%d%d%d%d", autooct, autopick, pitcarry,            kpclone, autoclone,            (kpmode=='h' ? 1 : (kpmode=='v' ? 2 : 3)) );          ch = (*pmenukey)(" opyca hvbine\n",             KPM_LCOL, KPM_CWID, KPM_TOPY, KPM_BOTY);          wkill();          if(ch==ENTER) {               curset(oldcurse);               return;          }          ch = Small(ch);          switch(ch) {          case 'o':               autooct = !autooct;               break;          case 'p':               autopick = !autopick;               break;          case 'y':      /* dupes main Options Menu */               pitcarry = !pitcarry;               break;          case 'c':               kpclone = !kpclone;          /*     kpickup(FALSE);     /* done on Exit too, but no harm (?) */               break;          case 'a':               autoclone = !autoclone;               break;          case 'h':          case 'v':          case 'b':               kpmode = ch | 64;     /* tolower() */               break;/*          case 's':               kpview = !kpview;               break;          case 'k':          case 'm':               kpgoto = ch | 64;               break;*/          case 'i':          case 'n':               alcurset(FALSE);               menu(ch=='i' ? MEN_KPH : MEN_KPN);               (*pflush)();               read(0, buff, 1);   /* any key to exit */               wkill();               curset(oldcurse);               return;          case 'e':               if(rfr_scr = (*pexprmenu)(kpind))     /* one '=' */                    undind = BADIX;               curset(oldcurse);               return;          default:       /* Razz & recycle */               bell();          } /* switch */     } /* for() */} /* kpmen() *//* eof KP.C */