/* file PRINT.C  -6B-    Adapted from SHOW.C  3/90*  Prints entire score within [] or start to end.Options:Bold printing*Auto LF or not*Start & End pointsCompact or not -- maybe analog settings in betweenOnly certain parts or stavesBarline numbers -- all, top, bottom, individual staves selectable*/#define LASTCLUZ ACCENT  /* highest defined VISIBLE Inclusion type */#include "wmuse.h"#include "vgraf.h"#include "wwidths.h"#include "wmenu.h"#include "wcodes.h"#include "titles.h"#include "windows.h"#include "vmem.h"#include "macros.h"#include "fcnptrs.h"#define FRAG   1#include "soowee.h"#define LPAD    0  /* left "margin" for notes figuring */#define SYSLEFT 1  /* space for "System" braces if used */#define RPAD    2  /* was 3 */#define LMARGIN (SYSLEFT+CLEFWID+LPAD)#define RMARGIN (SCORIGHT-RPAD)Deltime   barmin();sexy      findkey();Index     sametime();void      sqdump();bool      ispwexpr();extern direct char  *pctn1, *pctn3, *pctn4, *pctn5, *pctn6;extern STAFF staves[];extern ubyte bcluzis[];extern ubyte grafxes[];extern ubyte grafyes[];extern char  filename[];extern direct sexy     numer, denom;extern direct short    nparts, nstaves, nzones,    xyoff,           /* index - xyoff = xyindex */    xgoal,           /* where gind's object should be shown */    gbar;            /* bar # containing gind */extern direct Index    nevents,    gbarind,         /* index of gbar's barline */    lftind, ritind;  /* edgemost indices shown */extern direct Deltime    zonedur;extern direct Time    length;          /* current length of piece */extern direct bool    rfr_scr, rfr_bar,    compact,       /* Squeeze as many notes as possible */    dosqueez,       /* compress vertically */    doesff, automarg,    /* Printer features */    beam,    tripper;extern direct ubyte    printype;extern ubyte    *evtarray;/* Structured as 3 Nested Loops (maybe 2 or 3 Fcns):(1) Steps thru the piece, drawing "lines" of music, spacing them verti'ly    and skipping page fold perforations.  In Fran.(2) For a given leftind, keeps flogging showp() with    different kernings till right margin is decent.  Just one try.(3) Showp(kern) like Showall(), but kern arg tells how much extra wasted    horiz space to insert to make margin come out decent.Either (2) xor (3) judges "decency" of right margin, by whether it falls ona barline, or at least just before a major Beat.Trial draw once.  Then find rightmost "decent" stopping point.Re-draw to put that at right.Stopping point MUST BE just before a beat, ie, before a multiple of dendur.Best if end of bar.Otherwise, better the closer to middle of bar you get.*/hprint() {     char buff[60], *cp;     bool doprint;     Index     lind, rind, stind, endind, ritlin;     sexy      bartype, lebartype, rebartype, barnum, lebarnum,                endnum, lendnum, ritlinx, pline;     int       /* badness, */ pass, kern, durs, remain;     Deltime   rbartime, lastime, overtime, goaltime;     Reg EVENT *evp;     if( !(*pfixmarx)(&lind, &rind, &stind))          return;     if(rind < nevents-1)     /* ie, if there's a ']' */          rind--;     dosqueez = (*pyesno)("Squeeze Vertically (recommended)?");     if(doprint = (*pyesno)("Real Print, not just preview?")) {          if( !printype || !(*pyesno)("Printer Ready?  Paper at Page Top?"))               return;          (*palert)("To abort print once started,\n hit 'Q' -- not BREAK!\n",            0);     }     sqdump('b');   /* Init Fran's end, even if not printing */     pline = 1;     stind = lind;/* Title on first page */     yclear(0, 191);     alcurset(FALSE);     wcreate(5, 180, 70, TOTLINES+2, FALSE, WSNONE);     (*pprintf)(filename);     /* system("date t");   /* No output -- why??? */     (*pputchar)('\n');     (*pswapevts)(TRUE);     for(pass = 0, cp = Titles; pass < TOTLINES;  pass++, cp += TLENP1)          (*pprintf)("       %s\n", cp);     (*pswapevts)(FALSE);     if(doprint) {          kern = dosqueez;          dosqueez = TRUE;          sqdump('d');          dosqueez = kern;     }     else {          squeeze();          (*palert)("", 0);     }     wkill();/* Check whether starting on barline, after '[' */     evp = i2p(stind);     if( !evp->part && (evp->show.INCTYPE == LMARK))          evp = plusplus();     if(anybar(evp)) {          bartype = evp->show.INCTYPE;          barnum = EvBarNo(evp);          endnum = evp->show.REPENDN;     }     else {          bartype = (curind <= 3) ? SINGLEBAR : -1;          barnum = endnum = 0;     }     for(;;) {    /* Loop (1) */          ritlin = BADIX;     /* see if show draws any barlines */          ritlinx = 0;/* The Trial print */          showp(stind, rind, 0, 0, 0, &ritlin,            lebartype = bartype, lebarnum = barnum, lendnum = endnum, FALSE); /* Judge how close to right edge is the rightmost good stopping point */     /* Get last item's time from last barline shown.      * If no barline on screen, use the one to left of view */          if(ritlin == BADIX) {               for(evp = i2p(stind); curind >= 0; evp = decdec())                    if(anybar(evp))                         break;               ritlin = curind;               ritlinx = 2;   /* "no hope" */          }/* All times are wrt rightmost barline, to avoid Long Times */          bartype = (evp = i2p(ritlin))->show.INCTYPE;          barnum = EvBarNo(evp);          endnum = evp->show.REPENDN;          if( !ritlinx)               ritlinx = grafxes[ritlin - xyoff];          rbartime = (Deltime) evp->startime;          overtime = i2p(ritind)->startime - rbartime;/* If trial print showed final item, skip lotsa stuff */          if(ritind >= rind) {               endind = rind;            /* durs = !overtime;   /* control final barline print */               goto kernit;          }/* Find TS for final bar, to figure good breakpts */          (*pfindts)(sametime(ritlin, TRUE));    /* not perfect *//* Good breaks are bar or 1/2 way thru bar, or 1/4 or 1/3 way if busy */          durs = overtime / zonedur;/* Trade off badness of split -vs- badness of right edge *//* Go by special cases for common T/S'es *//* Later allow for X percentage of screen, to override.* Ultimately, figure where the 1/4, 1/2, etc. points are on screen!*  Splitting in half is badness of 1; in 4ths is 2; worse is 3 */          if(ritlinx >= 72)   /* good enuf not to worry with */               durs = 0;          else if((numer==4) && (denom==4)) {     /* 4/4 */               if(ritlinx >= 56)   /* was 60 */                    durs &= 2;     /* 0 or 2 */               if(ritlinx >= 64)                    durs = 0;               /* badness = 1; */          }          else if(numer==3) { /* Hate to split a 3/S */               if( ((durs == 1)&&(ritlinx >= 53)) || (ritlinx >= 57) )                    durs = 0;               /* else   badness = 3; */          }          else if((numer==4) && (denom==2)) {    /* 2/4 */               if(ritlinx >= 70)                    durs = 0;               /* badness = 1; */          }/* This case needs more than just splitting in half */          else if((nzones & 1)==0) {    /* even effective numer */               durs = ((durs + durs) > nzones) ? (nzones >>1) : 0;               /* badness = 1; */          }          else if((nzones & 1) != 0) {  /* odd meter, split either side */               if(durs >= (nzones >>1) + 1)                    durs = (nzones >>1) + 1;               else if(durs < (nzones >>1))                    durs = 0;               /* badness = 1; */          }          /* if(durs == 0)    badness = 0; */          goaltime = rbartime + durs * zonedur;/* Find rightmost now-showing note of startime LESS THAN goaltime,*  using funny comparison for Etimes. */                        for(evp = i2p(ritlin); curind <= ritind; evp = plusplus())               if( ((int)goaltime - (int)evp->startime) <= 0)                    break;          endind = curind - 1;/* How far to move last item to right on screen? */kernit:   kern = 77 - grafxes[endind - xyoff];    /* frogs can't spell */          if(kern <= 0)               kern = remain = 0;          overtime = kerntime(kern, &remain, stind, endind);/* The for-real print show */          showp(stind, endind, kern, remain, overtime, &ritlin,            lebartype, lebarnum, lendnum, beam);/* Force barline at end if full measure.  Do this better later *//* Later allow for hangers-on before & after barline *//* rebartype is type to end line with; bartype starts off next line if >= 0 */          if( !durs) {               rebartype = bartype;               switch(bartype) {                    case BEGREPEAT:                         rebartype = SINGLEBAR;                         break;                    case ENDREPEAT:                    case FINE:                         bartype = SINGLEBAR;                         break;                    case NTHENDING:                         rebartype = (endnum==1) ? SINGLEBAR : ENDREPEAT;                         break;               } /* switch */               putalst(79, rebartype, 0);          }          else if(endind >= nevents-2)               putalst(79, FINE, 0);          else               bartype = -1;  /* i.e., none */          if(doprint) {               if( (*pinkey)() == 'q')                    break;    /* Abort on any key */               sqdump('d');          }          else {               squeeze();               (*psprintf)(buff,                 "Line %d.  Keep on previewing? ", pline++);               if( !(*pyesno)(buff))                    break;          }          stind = endind + 1; /* fudge this later *//* if(!doprint) (*palert)("Stind, Rind: ", 2, stind, rind); */          if(stind >= rind)   /* rind == nevents-1 if no ']' */               break;     } /* loop(1) */     if(doprint)          sqdump('e');   /* Eject last page */     rfr_scr = rfr_bar = TRUE;     alcurset(TRUE);     (*palert)("\007 Print Finished.\n", 0);} /* main/print() *//* Given kern==# of cols to waste, find the max deltime between the given* limits such that if showp() inserts an extra col after each deltime* >= that value, it will eat up 'kern' cols.* Except that only 'remain' cols of == that value should be spaced.*/Deltime kerntime(kern, remain, sind, eind)  int     kern, *remain;  Index   sind, eind;{     Deltime   lastdmax, dmax, dtime;     Etime     lastime;     Reg EVENT *ep;     lastdmax = 32767;     while(kern > 0) {          *remain = kern;     /* how many cols remain *//* Find next lower max deltime (greatest that's less than previous dmax) */          for(dmax = 0, lastime = (ep = i2p(sind))->startime;            curind <= eind; ep = plusplus()) {               dtime = (Deltime)ep->startime - lastime;               if((dtime > dmax) && (dtime < lastdmax))                    dmax = dtime;               lastime = ep->startime;          }/* Bail out if nothing left to kern! 90/9/15 */          if(dmax==0)               return(lastdmax);/* Count how many occurrences of exactly this dmax */          for(lastime = (ep = i2p(sind))->startime;             curind <= eind;  ep = plusplus())          {               if(dmax == ep->startime - lastime)                    kern--;               lastime = ep->startime;          }          lastdmax = dmax;    /* for next run */     }     return(dmax);} /* kerntime() *//* Draw screen from stind to endind, or screen space runs out *//* Later do real ties, etc. -- take your time to do things right. */showp(stind, endind, kern, remain, kmintime, ritlin,  bartype, bar, nth, dobeam)  Index   stind, endind, *ritlin;  Deltime kmintime; /* Add a column to all deltimes >= this */  int     kern,     /* how many extra columns to fudge in */          remain;   /* how many cols fudges to make at ==kmintime */  sexy    bartype,  /* Left-edge barline type, if >= 0 */          bar,      /* Barnum of bartype */          nth;      /* Ending No. iff bartype==NTHENDING */  bool    dobeam;{    sexy    staffy, notex, lmargin;    int     xincr, notey;    Index   ind;    sexy    slot, part, oldslot, oldpart, hilo, incwid;    Deltime bmin;     bool    stemdn;    Deltime deltime;    Etime   thistime, lastime;    Reg EVENT  *evp;    if(endind >= nevents)          endind = nevents - 1;/* If starting with single bar, add 1 to notex; for fancy bars, add 2 */    lmargin = SYSLEFT;    if(bartype >= 0)         lmargin++;    if(bartype > 0)         lmargin++;    notex = lmargin + CLEFWID+1;    evp = i2p(stind);    lastime = evp->startime;/* Set gbarind to barline of bar containing stind, * allowing that stind may already be that barline. */    for( ; curind >=0; evp = decdec() )        if(anybar(evp))            break;    gbarind = curind;    gbar = EvBarNo(evp);    bmin = barmin(gbarind + 1, FALSE);    /* may exceed nevents-1 *//* How about let's Draw something ... */    wkill(); /* grafix(); */    yclear(0, 191, BACK);/* Draw the open-ended staves, with Clefs at lmargin */    drstaves(lmargin, FALSE);/* Draw special initial barline, if any */    if(bartype >= 0) {          if(bartype==NTHENDING)               bartype = (nth == 1) ? SINGLEBAR: DUBARLINE;          else               nth = 0;          putalst(SYSLEFT, bartype, bar);          if(nth)  /* Draw Nth-brackets and # last */               putalst(SYSLEFT, NTHENDING, nth);    }/* Draw "System" braces */    (*pprintf)(pctn1, DSYS);/* Put key signature down left margins */    if(ind = findkey(stind)) {         drawks(notex - 2, ind);         notex++;    }/* Use Xgoal to set the offset of graphic-X,Y arrays *   relative to events[], * for arrays[413] divided over 640 pixels. * 427 / 640  -- 2/3 x 8*/    xyoff = stind - (16 * (notex - (LMARGIN-LPAD))) / 3;/* Put the notes & rests on. */    ind = stind;    bar = gbar;    oldpart = oldslot = 0;     /* for now *//* THE Innermost, Events Loop */     for( evp = i2p(ind);       (curind <= endind) && (notex <= RMARGIN);       evp = plusplus() )     {  /* If new to this bar, update min duration */          part = evp->part;          if( !bmin) {               ind = curind;   /* save thru fcn call */               bmin = barmin(curind, FALSE);               evp = i2p(ind); /* restore */          }/* if(bar==30) (*palert)("Bar 30, bmin=", 1, bmin); */      /* If no time change, skip lots of code: */          thistime = evp->startime;          if(deltime = thistime - lastime)  /* '=' */          {/* if(bar==30) (*palert)("Bar 30, deltime=", 1, deltime); */      /* The times they are a changin' ... */               lastime = thistime;/* Kerning */               if(kern > 0) {     /* Any left to do? */                    if(deltime > kmintime) {                         notex++;                         kern--;                    }                    else if((remain > 0) && (deltime == kmintime)) {                         notex++;                         kern--;                         remain--;                    }               }/* Linear placement if delt < bmin or compact mode is off *//* Temporarily re-enter Pixel-X Domain */               if((deltime < bmin) || !compact) {                    xincr = (8 * NOTEWID * deltime) / bmin;     /* Quantize to byte size for BYTBLT graphics */                    xincr = (xincr + 4) & ~7;                    if(xincr < 8)                         xincr = 8;                    notex += xincr / 8;               }/* No, Compact -- just advance by note width */               else                   notex += NOTEWID;          /* Test for screen edges */               if(notex > RMARGIN)                   break;          } /* time advanced *//* AT LAST, process note, rest, or inclusion */          slot = evp->show.slot;    /* ASSUMES .slot == .INCTYPE *//* Figure some way to extend this trick to Accidentals! *//* A group of partwise expressors may have been repeating in same X-space;*  if so but now out of the group, then catch up notex to reality. */          if( !oldpart && ispwexpr(oldslot)            && (part || (slot != oldslot)) )                notex += incwid; /* previous incwid *//* Inclusion Processing.*  All 'incwid' values must be multiples of 8 for BYTBLT.  */            if(part == 0) {        /* Inclusion */                grafxes[curind - xyoff] = notex;/* Markers aren't real music notation, so omit; also undef'ed types */                if((slot > LASTCLUZ)                  || ((slot >= LMARK) && (slot <= TMARK))) {                    continue;                }                incwid = bcluzis[slot];                notey = 0;         /* std default for all-staffers *//* Here, "barline types" means only actual bar lines,*    not including hangers-on from barline menu (TS, K/S, etc.) */                if(slot <= FINE) {  /* BarLine types */                    bar = EvBarNo(evp);/* Draw barline & no. for each staff; * special hacks for Nth endings: */                    if(curind && (bartype == -1)) { /* no redraw ledge bar */                        nth = 0;                        if(slot == NTHENDING) {                             nth = evp->show.REPENDN;                    /* Use a double bar or endrepeat for Nth */                              slot =  (nth == 1) ? SINGLEBAR: ENDREPEAT;                         }            /* All barline types converge here ... */                        putalst(notex, slot, bar);                        if(nth)                    /* Draw the Nth-ending brackets and number;                     * do this last so it wins the dynamite war. */                            putalst(notex, NTHENDING, nth);                    }            /* ...except non-redrawn left-edge Bar */                    else {                        grafxes[curind - xyoff] = SYSLEFT;                        incwid = 0;     /* don't move */                        bartype = -1;                    }             /* Set up for next Bar */                    bmin = 0;   /* Flag 'bmin' as obsolete */                    *ritlin = curind;               } /* BarLine inclusions */        /* Complex inclusions needing special draw code        *  and maybe funny 'incwid' diddling:  */               else if(slot==KEYSIG)                    drawks(notex, evp->show.KSN);               else if(slot==NUTEMPO)                    drawgli(NUTEMPO, notex, evp->show.TEMPONO);               else if(slot==GENVOL)                    drawgli(GENVOL, notex - 1, evp->show.LEVELNO);               else if(slot==CLOCKON)                    drawgli(CLOCKON, notex, evp->show.PARAM1);               else if((slot==CRESC) || (slot==ACCEL))                    drawcres(notex, evp->show.LEVELNO,                      evp->show.pitmod, evp->show.dur);               else if(slot==LABEL)                    drawlab(notex, evp);               else if(slot==ACCENT)                    drawgli(ACCENT, notex, evp->show.PARAM1);               else if(slot==TIMESIG)                    drawts(notex, evp->show.TSNUMER, evp->show.TSDENOM);               else if(slot==ISEVT)                    drawgli(ISEVT, notex, -1);               else if(slot==TSEVT)                    drawgli(TSEVT, notex, evp->show.TEVTNO);/* Following inclusions are Part-Specific and need true noteY value.*  Also they fudge notex so groups of them draw in same X-space. */               else if(ispwexpr(slot)) {                    notey = drindiv(                      (slot==INSTR) ? DINS                      : ((slot==LEVEL) ? DXLV                      : ((slot==MCHOP) ? DMCH : DPEV) ) ),                      notex, evp->show.PARTNO,                      ((slot==IPEVT) ? -1 : evp->show.PARAM1);/* PARAM1 == TEVTNO, INSTRNO */                    notex -= incwid;               }     /* (Add other inclusion types here) */     /* Simple inclusions, fixed width and drstring */               else {                    putalst(notex, slot, 0);               }     /* Code common to ALL inclusions, incl BarLines */               grafyes[curind - xyoff] = notey;   /* for beaming */               if(curind)     /* undrawn bar #1, no x++ */                    notex += incwid;          } /* inclusions */          else        /* Note or rest. */          {     /* Figure vertical position of note wrt staff */               showstaff(part, &staffy, &hilo);               notey = staffy;            /* lftbar = bar; */               if(slot != REST) {     /* Note */                    notey += (slot + slot);                    if( !dobeam) {                         stemdn = Stemway(hilo, slot);     /* Keep note stems on screen */                         stemdn &= (notey > 15);                         stemdn |= (notey > (191-15));                    }               }               else   /* Duet Rests need hi/lo placement */                    notey += Roffset(hilo) + 8;               grafxes[curind - xyoff] = notex;               grafyes[curind - xyoff] = notey;    /* So do it already! */               if( !dobeam || (slot==REST) || (hilo & NOFLAG))                    (*pdrawnr)(&(evp->show), notex, notey, staffy, stemdn,                      hilo & NOFLAG, FORE);          } /* note/rest *//* Common code for ALL EVENTS -- needed for Inst & Level prefixes */          oldpart = part;          oldslot = slot;     } /* event loop *//* Got here by curind out of range or plotting off screen; * either way, curind and evp are last valid values + 1. */     /* ritbar = bar; */     evp = decdec();     ritind = curind;     lftind = stind;     /* for beams */     /* lftbar = lftlin = gbar; */     if(dobeam)          Beam();    (*pprintf)("\n");  /* flush everything */} /* print() *//* eof PRINT.C */