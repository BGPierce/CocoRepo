/* file BMS/BMENSUBS.C   --4B--*  Subrs to support BMens.c, plus misc. human I/O fcns.*  Menus themselves fragged out 95/8/29.*/#include <stdio.h>#include "wmuse.h"#include "mencodes.h"#include "windows.h"#include "screen.h"#include "cursors.h"#include "vmem.h"#include "soowee.h"/* Note: Channel #s are kept 0--15, as actually transmitted */extern ubyte     chans[NPARTS + 1];extern direct bool     compact, rfr_scr, midipak, midiser, mididev, instren, clocken,     midievts, scrclock, pldebug, smf;extern direct ubyte     midinnmin, midinnmax;extern direct byte  accentwt;extern EVENT     undevent, zevent;extern direct Index    undind, lftind, ritind, gbarind, gind, godotind;extern direct int      xgoal;extern char     instnams[][INAMEL],     lastgo[];extern sexy     ioff,     instvals[];extern bool     partens[NPARTS + 1], chanens[16];extern direct sexy    nparts, numer, denom, curcurse,    velo,       /* MIDI note attack velocity */    transp,     /* # semitones to shift play */    secmin;extern ubyte percmids[17];extern char  *percnams[17],             percsynth[24];/* Fcn pre-decls */bool testbar(), anybar();Time fulltime();/* If given "where" buffer is empty, prompt in dialogue box*  and read new response into same buffer.  Else fcn is no-op.*  Always return TRUE iff buffer ends up non-empty. */bool getempty(where, prompt, bigwin)  char    *where, *prompt;  bool    bigwin;{     if ( ! *where) {          dialogue(bigwin);          printf(prompt);          gets(where);          wkill();     }     return(*where != '\0');} /* getempty() *//* Fcn to print a menu plus "Choice:" and collect prompted response.*  Note: ENTER returns '\n', not '\0'.*  87/8/29 reads ONE char w/out ENTER; caller must get any more.*  88/1/2  no longer clears screen unless your 1st string has a ^L.*  89/10/13 Mouse click serves as an ENTER for default out of menus.*/prmenu(code, answer)  sexy    code;  char    *answer;  /* set to NULL to skip reading response */{     menu(code);     waitmouse();     printf("  Choice: ");     alcurset(TRUE);     if(answer)          charmaus(answer);}/* Prompt and read an integer; blank ENTER returns given 'def'. *  If prompt string contains a "%d", "%x", etc.,*    the default value will be shown to user.*  Yes, user can type '0' and force a zero return value.*/short getdefp(prompt, def)  char *prompt;  short def;{     char buff[BUFFSIZE];     printf(prompt, def);     /* ignores def if prompt has no "%d" */     gets(buff);     if(! *buff)              /* just ENTER */          return(def);     else         return(atoi(buff));}int clamp(it, lower, upper)  int     it, lower, upper;{     if(it < lower)          return(lower);     if(it > upper)          return(upper);     return(it);}/* Convert ONE hex-digit lower-case char to an integer.*  We permit hex digits greater than 'f', on purpose.*  Returns zero for invalid char.*/#define TOPHEX 'g'  /* Max "hex" char allowed (g == 16.) */short hexc2i(c)  char c;{     c -= '0';     if((c >= 0) && (c <= 9))          return(c);     c -= ('a' - '0');     if( (c >= 0) && (c <= (TOPHEX - 'a')) )          return(c + 10);     return(0);} /* hexc2i() *//* Inverse of above; no hard limit */char i2hexc(i)  short i;{     i &= 31;       /* super-MPARTS */     if(i <= 9)          return(i + '0');     return(i + ('A' - 10));} /* i2hexc() *//* Give '+' for TRUE and '-' for FALSE */char conoff(what)  bool    what;{     return(what ? '+' : '-');}/****** Marker subrs *//* Find current indices of all 3 markers; * put -1 in those not defined */void fmarks(lind, rind, tind)  Index   *lind, *rind, *tind;{    short slot;    register EVENT *ep;    *lind = *tind = *rind = -1;    for(ep = i2p(0); curind < nevents; ep = plusplus() )        if( !ep->part)            switch(slot = ep->show.INCTYPE) {                case LMARK:                    *lind = curind;                    break;                case RMARK:                    *rind = curind;                    break;                case TMARK:                    *tind = curind;            }} /* fmarks() *//* Find markers and ask whether to default missing [ or ]*  to beginning or end of score.  Calls fmarks() above.*  Returns TRUE iff [ and ] are usable.  Tind ignored.* 90/2/19 No longer asks about ] when you've already NO'ed the [.*/bool fixmarx(lindp, rindp, tindp)  Index   *lindp, *rindp, *tindp;{     fmarks(lindp, rindp, tindp);     if(*lindp < 0) {          if(yesno("No [.  From beginning? "))               *lindp = 0;          else               return(FALSE);     }     if(*rindp < 0) {          if(yesno("No ].  To end? "))               *rindp = nevents - 1;          else               return(FALSE);     }     return(TRUE);}/* Tests for any type of Barline; == testbar(evp, FALSE) */bool anybar(evpab)  /* Also used in Um3Go */  EVENT *evpab;{    return( (!evpab->part) && (evpab->show.INCTYPE <= FINE) );}/* Clear instrument arrays to value 128 (shows as 1, not o011) and blanks. */instinit() {     register sexy i;     for(i = 0; i < NINSTRS; i++) {          instvals[i] = 0x80;          instnams[i][0] = '\0';     }}/* 89/1/15 Radically rewritten so there is no longer a "main" or "top"*    menu, just the screen-top Menu Bar.*  The old "main" menu is now the "Random" Menu and requires*    an 'r' or 'SPACE' to reach, or a click over RANDOM.**  Code immediately below is just for dispatching Menu Bar.*//* "Menu-BAR" choices.  Returns TRUE iff *  main editing loop should be broken out of. * Re-loops for most commands. * 88/10/10 If 'given' not null, skip menu display, just clear screen. * CAUTION: Microware C bug prevents goto'ing from *  inside a switch scope to outside label.*/bool mainmen(given)          /* TRUE ==> Restart UmusE */  char    given;{     char buff[BUFFSIZE];     if( !given)           return(FALSE);      /* don't restart! */     switch(given)     {/* Escape back to graphics on empty line (ENTER) or ^C or BREAK */     case '\n':     case 3:     /* Ctrl-C */     case 5:     /* BREAK */          break;     case 'r':       /* Random (old Main) Menu */     case ' ':          return(randmen('\0'));     /* True ==> Restart Umuse */     case 'i':       /* Instrument (patch, stop) definitions */          Instrmen();          break;     case 'l':       /* Layout Menu */          if(nevents > 1)               Laymen(TRUE);  /* Layout */          else               newscore(TRUE);     /* Raw laymen() won't count! */          /* Laymen(nevents > 1); */          break;/* Goto nth bar, or -nth special bar *//* Executes it all right here, not permanent */     case 'G':     case 'g':          dialogue(FALSE);          *buff = given;          printf("%c", given);     /* echo */          goto searches;     case 7:          /* ^G == Menu Bar case */gomenu:          prmenu(MEN_GOTOS, buff);      /* gets 1st character */          if(*buff == '\n') {           /* quick bailout 89/10/14 */               wkill();  /* the menu */               return(FALSE);          }searches:          gets(buff + 1);     /* get args */          if( *(buff+1) == '?') {               wkill();  /* either Men_Gotos or the dialogue */               goto gomenu;          }          else               Gobar(buff);          break;     case 'f':          iomen();          break;     case 'm':          Midimen();          break;     case 'b':          Blockmen();          break;     case 'o':      /* Options */     case 'c': /* Compact display, for old compat */  /* case 't': /* Trace play, now Tools "" */     case 'd': /* Debug play, "" */          optmen(given);          break;/* If can't identify command, ship it to Random */     case 'p':     default:          return(randmen(given));     } /* end case */     wkill();     return(FALSE);      /* don't restart Umuse */} /* mainmen() *//* Expression: Instr, Volume and Tempo sub-menu, from ^ insert */bool exprmenu(ind)   /* TRUE means refresh screen */  Index   ind;      /* of event "found" by mouse */{     char      obuff[BUFFSIZE], buff[BUFFSIZE];     EVENT     evtemp;     Index     newind;     sexy      num, topy;     char      cm, c1;     sexy      prt, btype, otype, newtype;     Time      otime;     Reg EVENT      *evptr;/* In all cases, get startime of "found" event.* Insert() with that time and special .evtype==0;* insert should go *ahead of* found event, since .name==0.* Fill in that new *event slot with needed goodies.** Each case loads its goods into a copy of zevent* and _strass that into the new event after insert() done after cases.*/     newind = BADIX;        /* invalid *//* Get goods on item under mouse *//* Someday, if Barline, jump to "Insert A New:" menu */     evptr = i2p(ind);     prt = evptr->part;     otype = evptr->show.INCTYPE;     otime = fulltime(ind);/* If hit a KeySig, give chance to alter it */     if( !prt && (otype == KEYSIG)) {          if(yesno("Change Key Signature?")) {               num = evptr->show.KSN;               sprintf(obuff, "Currently %d %ss.\n New Value: ",                  num, (num < 0) ? "Flat" : "Sharp");               *buff = '\0';               if( !getempty(buff, obuff, FALSE))                    return(FALSE);               evptr->show.KSN = clamp(atoi(buff), -7, 7);               return(TRUE);          }     } /* if not keysig, or no wanna change, fall thru */re_expr:     prmenu(MEN_EXPRS, NULL);     cm = textmenu(EXPR_LCOL, EXPR_TOPY, EXPR_CWID, 1, 1, 14, TRUE);     if(cm < 0)     /* typed chars come negated */          *buff = c1 = -cm;     else          c1 = "\nivme  tgc<a^le" [cm];     putchar(c1);     if(c1 == '\n') {    /* either clicked or typed */          wkill();          return(FALSE);     }/* Self-contained Event-entering fcn -- covers both Menu 'e' slots */     if(c1 == 'e') {          wkill();          return(Evtenter(ind));     }     strevent(&evtemp, &zevent);     evtemp.startime = (Etime) otime;/* Get more chars if typed, not clicked.  Gottaa hit \n, rats! */     if(cm < 0)          gets(buff + 1);     else          *(buff + 1) = '\0';     wkill();     switch(c1)     {/* Fill in that *event with *human* Tempo value */     case 't':      /* May change the limit values */          newtype = NUTEMPO;          if(!prt && otype == NUTEMPO)               newind = ind;            /* Replace old Tempo */          if( !getempty(buff + 1, " New Tempo (30 - 240: ", FALSE))               return(FALSE);          evtemp.show.TEMPONO = clamp(atoi(buff+1), 30, 240);          break;     case '^':     case '7':     case 'l': /* Layoff */     case '-':          newtype = ACCENT;          evtemp.show.PARAM1 = ((c1=='^') || (c1=='7')) ? 14 : (-14);          break;     case 'g':          if( !prt && (otype == GENVOL))               newind = ind;          newtype = GENVOL;          goto levels;     case '<':     case '>':          if( !prt && (otype == CRESC))               newind = ind;          newtype = CRESC;          evtemp.show.dur = (c1=='<');  /* Improve this someday! */          goto levels;     case 'a':     case 'r':          if( !prt && (otype == ACCEL))               newind = ind;          newtype = ACCEL;          evtemp.show.dur = 2 + (c1=='r');          if( ! getempty(buff + 1, "To Tempo: ", FALSE))                              return(FALSE);          evtemp.show.PARAM1 = clamp(atoi(buff+1), 30, 240);          goto beats;     case 'c': /* MIDI Clock on/off */          if( !prt && (otype==CLOCKON))               newind = ind;          newtype = CLOCKON;          evtemp.show.PARAM1 = yesno("Turn Clock ON, not OFF?");          break;/* I, V, and M can be done only to non-zero Parts, or Selves */     case 'h':     case 'm': /* was 'c' */          if(!prt) {               if(otype != MCHOP)                    goto ivnono;               newind = ind;    /* Replace existing */               prt = evptr->show.PARTNO;          }          newtype = MCHOP;          evtemp.show.PARTNO = prt;          if( !getempty(buff + 1, " MIDI Channel (1 - 16): ", FALSE) )               return(FALSE);          evtemp.show.INSTRNO = (atoi(buff + 1) - 1) & 15;          break;     case 'i':          if(!prt) {               if(otype != INSTR)                    goto ivnono;               newind = ind;    /* Replace existing instr */               prt = evptr->show.PARTNO;          }          newtype = INSTR;          evtemp.show.PARTNO = prt;     /* Pop-up the Instruments Window for click select  3/93 */          if( (cm < 0) && *(buff + 1))     /* Typed, with value already */                    num = atoi(buff + 1);     /* No value given, let pick from Menu */          else {               wcreate((COLS - INST_CWID)/2, EXPR_TOPY+14, INST_CWID,                 NILINES+4, TRUE, WSDOUBLE);reshow:               if(ioff < 0)                    ioff = 0;               if(ioff > (NINSTRS-2*NILINES))                    ioff = NINSTRS-2*NILINES;               ioff &= 0xFE;     /* force Even */               Instrshow();               printf( " (Back in list)          (Forward)\n");               printf("\n Instr. No. (0-63): ");               cm =  textmenu((COLS - INST_CWID)/2, EXPR_TOPY+14,                 (INST_CWID+1)/2, 2, 0, NILINES+1, TRUE);               if( !cm || (cm == -'\n')) {                    wkill();                    goto re_expr;               }               if(cm > 0) {     /* clicked */                    if(cm > 2*NILINES) {     /* Back or Forward */                         if(cm & 1)                              ioff -= 2*NILINES;  /* Full screen */                         else                              ioff += 2*NILINES;                         putchar('L' & 31);                         goto reshow;                    }                    num = cm + ioff - 1;               }               else {     /* Typed */                    c1 = -cm;                    if((c1 >='0') && (c1 <='9')) {                         *buff = c1;                         putchar(c1);                         gets(buff + 1);                         num = atoi(buff);                    }                    else {                         if(c1=='b')                              ioff -= 2*NILINES;     /* whole page */                         if(c1=='f')                              ioff += 2*NILINES;                         putchar('L' & 31);                         goto reshow;     /* ignore other chars */                    }               }          } /* from Instr menu */          evtemp.show.INSTRNO = num & MINSTRS;          wkill();          break;     case 'v':      /* Volume (expression) level, individual */          if(!prt) {               if(otype == LEVEL) {                    newind = ind;    /* Replace existing level */                    prt = evptr->show.PARTNO;               }               else {ivnono:             alert(" I, V, or M must go on a Note or Rest.\n", 0);                    wkill();                    return(FALSE);               }          }          newtype = LEVEL;          evtemp.show.PARTNO = prt;levels:/* New floating dialogue box for above */          if( ! *(buff + 1)) {     /* Match height of popup to Expr_Menu click */               topy = LEV_TOPY - ((c1=='v') ? 7 : 49);               if(newtype == CRESC)                    topy -= 14;               wcreate(LEV_LCOL, topy, LEV_CWID, LEV_LINES, TRUE, WSDOUBLE);               printf(          "\n 0=ppp  1=pp  2=p   3=mp\n 4=mf   5=f   6=ff  7=fff\n\nNo.: ");               cm = textmenu(LEV_LCOL+1, topy, 6, 4, 0, 2, TRUE);               wkill();  /* the popup */               if( !cm)                    return(FALSE);               if(cm < 0)     /* typed */                    *(buff + 1) = -cm;               else                    *(buff + 1) = cm + ('0' - 1);      /* [1-8] => ['0-'7] */               *(buff + 2) = '\0';          }          evtemp.show.LEVELNO = atoi(buff + 1 ) & MLEVELS;          if(newtype != CRESC)               break;/* Cresc & Accell shared code */beats:          *buff = '\0';          if( !getempty(buff, "Over how many Beats? ", FALSE))               return(FALSE);          evtemp.show.pitmod = clamp(atoi(buff), 1, 99);          break;     case '\n':          return(FALSE);     default:                 /* this SHOULD recycle someday? */          bell();          goto re_expr;     } /* cases */  /* Common finish-up code */     evtemp.show.INCTYPE = newtype;     if(newind == BADIX)         /* ie, if not a replacement */          newind = enter(otime, 0, newtype);     if(newind < 0)          return(FALSE);     strevent(i2p(newind), &evtemp);     return(TRUE);} /* exprmenu *//* eof BMS.C */