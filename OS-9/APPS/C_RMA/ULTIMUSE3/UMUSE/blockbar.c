/* file ~VM640/BLockBar.C    Frags BlockMen()*    into the Transp/Gobar Um3TranGo group.*/#include <stdio.h>#include "wmuse.h"#include "mencodes.h"#include "cursors.h"#include "windows.h"#include "vmem.h"#include "fcnptrs.h"#include "macros.h"extern direct Index    undind, lftind, ritind, gbarind, gind, xgoal;extern direct short     xgoal, numer, denom, nstaves, nbars;extern PART parts[];extern direct bool     compact, rfr_scr, rfr_bar, pldebug, tripper;extern EVENT     undevent, zevent;extern direct Time    length;extern direct sexy     nparts, curcurse, dencodur;extern ubyte levels[];extern STAFF staves[];extern char *vols, filename[];extern direct Deltime    dendur;extern NOTE    qrest;char *index();void transpose();bool unmark();#ifdef NEED WAITM/* Wait for mouse to be released.  No-op if not being held. */void waitmouse() {     int     x, y;     while((*pmouce)(&x, &y) != 0)          tsleep(4);     /* meaning 3 ticks */}#endifsexy hilostaff(prt, hilo)     /* Returns staff no. */  sexy    prt, *hilo;{     Reg PART  *pptr;     *hilo = (pptr = (parts + prt)) -> philo;     return(pptr -> pstaff);}/* Fcn to sort all the parts' notes on one given staff,*  so that highest-pitched note is in lowest-numbered Part.* This applies only to a "chord" of notes of equal Dur & DurMod;*  any "misfits" are left as-is, tho sets of 2 or more like misfits*  get sorted among themselves too.* Purpose is to make top part (or bottom, if stems down) carry*  the flags for the whole "chord".  Many current scores are out-of-sorts*  in this regard, so can't be made to look right by stem-only.* Notes are already sorted in partwise order,*  so bubble higher pitches towards the front.* Now includes Artics 01/10/27.*/int notesort(stf, lind, rind)  sexy      stf;  Index     lind, rind;{     EVENT     base;     int       cnt = 0;     Index     baseind;     ubyte     idler;     sexy      basehilo, scthilo;     Reg EVENT *evp;     stf--;     /* Machine uses Org 0 *//* Plant basep on next note/rest of group */     for(evp = i2p(lind); curind <= rind; evp = plusplus() ) {          if( !evp->part            || (stf != hilostaff(evp->part, &basehilo)) )               continue;          baseind = curind;          CopyObjP(&base, evp);          for(evp = plusplus(); curind <= rind; evp = plusplus() ) {               if( evp->startime != base.startime)                    break;               if( !evp->part                 || (stf != hilostaff(evp->part, &scthilo))                 || ((basehilo ^ scthilo) & (UPPER|LOWER))                 || (evp->show.dur != base.show.dur)                 || (evp->show.durmod != base.show.durmod)               )   continue;/* 960304 Sort stem-downers so lowest part no has lowest pitch,*    stem-uppers so lowest part no has highest pitch,*    and ignore solo (middle) parts.*  960423 -- Always push Rests toward highest-numbered parts --*    this code does that so long as REST == high positive "pitch".*/               if( ( (basehilo & UPPER) && (evp->show.slot != REST)                 && ((base.show.slot==REST) || (evp->show.slot>base.show.slot))                   )                 || ( (basehilo & LOWER) && (evp->show.slot < base.show.slot))               ) {                    idler = base.show.slot;                    base.show.slot = evp->show.slot;                    evp->show.slot = idler;                    idler = base.show.pitmod;                    base.show.pitmod = evp->show.pitmod;                    evp->show.pitmod = idler;                    idler = base.show.artic;                    if(base.show.slot != REST)                         base.show.artic = evp->show.artic;                    if(evp->show.slot != REST)                         evp->show.artic = idler;                    cnt++;               }          } /* end scout loop */     /* Put away the base before moving it, in case swaps happened */          evp = i2p(baseind);      /* also needed for next iteration */          CopyObjP(evp, &base);     } /* end base loop */     return(cnt);} /* notesort() *//*********** Block-commands sub-menu system ********* Present Move does Copy then Delete, needs lotsa RAM.* Uses strange but theoretically verified hanky-panky with differences*  of unsigned .startimes into signed delta-st's that are then applied to*  more unsigned .startimes, which are just the LSWords of Long Times.*/bool blockmen() {   /* return added 90/2/25, not used */     EVENT     evtemp;     char      buff[BUFFSIZE], c, c2;     Index     lind, rind, tind, ito, ifrom;     sexy      mx, my, staffy;     sexy      n, nbeyond, oldcurse;     Deltime   dst;     register EVENT  *evp;     oldcurse = curcurse;     curset(CBUTTON);     menu(MEN_BLOCK);     c = (*pmenukey)(BLK_STR, BLK_LCOL, BLK_CWID, BLK_TOPY, BLK_BOTY);     wkill();     curset(oldcurse);     if(c == '\n')          return(FALSE);/* Needn't check before Un-marking (removing all) */     if(c=='u') {          return(rfr_scr = unmark() );     }     (*pfmarks)(&lind, &rind, &tind);  /* find the markers, quietly *//* "Insert Coda" needs Tmark only.     *  Coda overwrites the previously-inserted Tmark. */     if(c == 'o') {          if(tind < 0) {               (*palert)("Need an I marker!", 0);               return(FALSE);          }          evp = i2p(tind);     /* leave startime as-is, correct */          evp->show.INCTYPE = CODA;          return(rfr_scr = TRUE);     }/* Inclusive tests prevent bogus [] gripes on illegal commands */   /* Other jobs need Lmark & Rmark, & maybe Tmark */     if( index("tfdmcps", c) != NULL) {          if( (rind >= 0) && (lind > rind) ) {               (*palert)(" ] [ backwards!", 0);               return(FALSE);          }          if(c=='p') {        /* Play gets softer treatment */               if((lind < 0) && !(*pfixmarx)(&lind, &rind, &tind))                    return(rfr_scr);               else if(rind < 0)                    rind = nevents - 1; /* silently give "to end" */               if(pldebug)                    text();               (*pplay)(lind, rind);    /* 1st Recursive Soowee 95/8/9 */               if(pldebug)                    wkill();               return(rfr_scr);          }     /* Transpose does own marker checks */          else if(c=='t') { /* Transpose whole score, or sub-block */               dialogue(FALSE);               (*pprintf)("(Use '-' for Down)\n How many Semitones up? ");               (*pgets)(buff);               wkill();               if(n = atoi(buff) ) {                    transpose(n);                    rfr_scr = TRUE;               }               return(rfr_scr);          }                    else if( (c=='f') || (c=='s') ){   /* Fixup or Sort-parts */               rfr_scr = FALSE;               if( !(*pfixmarx)(&lind, &rind, &tind)) {                    if( !(*pyesno)("Do the Current Screen showing?"))                         return(FALSE);                    lind = lftind; rind = ritind;               }               dialogue(FALSE);               if(c=='f') {                    (*pprintf)( "Part (1 to G) to fix up: ");                    (*pcharmaus)(&c2);                    wkill();                    if( !(n = hexc2i(c2)) )                         return(FALSE);                    if(n > nparts)                         return(FALSE);     /* If user asked for a Plus-part, fill its rests in too! */                    (*pfixup)(lind, rind, n, TRUE);               }               else {     /* (c=='s') Note sort, use fixmarx() */                    (*pprintf)                      ("CLICK Staff to Sort Notes on\n or Type its No.: ");                    c2 = (*pkeymaus)(&mx, &my);                    wkill();                    if(!c2) { /* clicked, not typed */                         /* waitmouse(); */                         n = (*pfindstaff)(my) + 1;    /* human Org 1 */                    }                    else {    /* typed */                         if(c2=='\n')                              return(FALSE);                         n = hexc2i(c2);                    }                    if(n > nstaves)                         return(FALSE);                    n = notesort(n, lind, rind);                    (*palert)("Notes Swapped:", 1, n);               }               return(rfr_scr = !!n);     /* always TRUE for fixup */          } /* 'f' or 'c' *//* Remaining cmds need [ ] already; check now */          else if( (lind | rind) < 0) {      /* Portable?? */               (*palert)("Missing [ or ] !", 0);               return(FALSE);          }     }/* Now have good pair of [ ], back to command */     switch(c) {     case 'd':    /* Also deletes the two Markers as a by-product */          patience();del:      n = nevents - 1 - rind; /* # of events to move */     /* LSW of startime difference between the '[' and the ']', truly positive,     *    though MSW and LSW's sign don't matter! */          dst = i2p(rind)->startime - i2p(lind)->startime;     /* Move-down loop for deletion.  VERY SLOW across page boundaries! */          for(rind++; n; n--) {    /* one beyond the ']' */               strevent(&evtemp, i2p(rind++));    /* source */               evtemp.startime -= dst;               strevent(i2p(lind++), &evtemp);    /* destin */          }          nevents = lind;     /* Really!  Don't change till done! */          length = (*pfulltime)(nevents - 1);          rfr_scr = TRUE;          (*pgivebac)();          wkill();       /* the Patience */          break;     case 'm': /* Move block; deletes [], leaves ^. */     case 'c': /* Copy block; leaves ^ and original [] */          if(tind < 0) {               (*palert)("Need a ^ mark.", 0);               break;          }          if( (lind < tind) && (tind < rind) ) {               (*palert)("\n\Must have ^ outside [block].\n", 0);               break;          }     /* Find Length and Event_count of block */          n = rind - lind - 1;     /* don't count markers */          dst = i2p(rind)->startime - i2p(lind)->startime;     /* Will it fit in memory? */          if((n > (NEVENTS - nevents)) || (i2p(n + nevents - 1)==0) ) {               (*pgivebac)();    /* any pswap grabs on i2p() */               (*palert)(" Score left unchanged.", 0);               break;          }     /* Remove this time overflow test later *//*        if((c == 'c') && ((length + dst) < 0)) {               (*palert)("**Time overflow; no change.", 0);               break;          }*/     /* Move up everything beyond TIND, fix startimes */     /* Must preserve lind & rind values */          patience();          ifrom = nevents - 1;     /* last event */          ito = ifrom + n;         /* how far to move them up */          nbeyond = ifrom - tind;  /* how many to move */          nevents += n;  /* Gets set back later by "del:" if Move */          length += dst;          for( ; nbeyond; nbeyond--) {               strevent(&evtemp, i2p(ifrom--));               evtemp.startime += dst;               strevent(i2p(ito--), &evtemp);          }     /* If TIND to left of block, fix LIND and RIND */          if(tind < lind) {               lind += n;               rind += n;          }     /* At last, copy the block, but not the Markers */     /* "These blocks will never overlap" -- Capt Smith, HMS Titanic */     /* Re-define the to & from indices and dst */          ifrom = lind + 1;   /* skip the '[', leave it */          ito = tind + 1;     /* just past the 'I' */     /* dst may be negative */          dst = i2p(ito)->startime - i2p(ifrom)->startime;          for( ; n; n--) {               strevent(&evtemp, i2p(ifrom++));               evtemp.startime += dst;               strevent(i2p(ito++), &evtemp);          }     /* If Move, delete original block & original markers */          if(c == 'm')               goto del;          wkill();            /* end Patience */          return(rfr_scr = TRUE);     /* Copy, just return */          break;     /* END Move/Copy */     default:                 /* Bad cmd, Razz him! */          bell();             /* bleep! */          return(FALSE);     } /* switch */     return(rfr_scr);  /* just in case */} /* blockmen() *//* Remove up to all three extant markers,*  returning TRUE iff at least one was found. */bool unmark() {     bool      didwe = FALSE;     Index     isave;     Reg EVENT *ep;     for(ep = i2p(0); curind < nevents; ) {          if( !ep->part && ( (ep->show.INCTYPE==LMARK)            || (ep->show.INCTYPE==RMARK) || (ep->show.INCTYPE==TMARK)) ) {               isave = curind;     /* damned virtual memory! */               (*premove)(curind);               ep = i2p(isave);               didwe = TRUE;          }          else               ep = plusplus();     }     return(didwe);} /* unmark() *//* eof ~Vm640/blockbar.C */