/* file GOBAR.C   --4C--*  Goto Search stuff, fragged out.** Additions 90/9/29:  g> or g<  any Cresc or Dim  gr any Accel or Rit  ga any Artic but Tied  g_ any Tie  g: any Repeat  gd DC, DS, etc.  p# Part #'s non-rest     add to any other command of v, i, or h, or a.  i, v, and h can take one arg number     and this can be followed by a p#.  t  can take tempo value  g  can take 0-7*/#include <stdio.h>#include "wmuse.h"#include "vmem.h"#include "macros.h"extern void (*palert)(), (*pfmarks)();extern bool (*pfixmarx)();extern char pfdat1[];    /* to pull in 349. fake bytes */extern direct bool     rfr_scr;extern direct Index    lftind, ritind, gbarind, gind, godotind;extern direct int      xgoal;extern char     lastgo[];/* Main() switch to merge Gobar and Transpose subr mods, *   really called trango() in core code bcu.c *//* bool blockmen(), int notesort() */int main(what, arg, lind, rind)  char         what;  unsigned     arg; /* can be anything */  int          lind, rind;  /* notesort() */{     switch(what) {     case 'g':          gobar(arg);          break;     case 's':          return(notesort(arg, lind, rind));  /* staff, lind, rind */          break;     case 'b':          return(blockmen());      /* bool */     }     return(0);}/****** Package to Search for given item types:* (G|g){-|+}{nnn}{what}**  g = any type barline, unless 'what' is given*  G = special barlines only; 'what' ignored*  nnn = absolute, count from beginning*  +nnn  count forward from current rightmost visible given item*  -nnn  count backwards from current leftmost visible given item*  If nnn too big, just go to end.  Zero is Beginning.*  Omitted nnn defaults to 1, not 0.*New "What" List:  88/6/1  All working, not a wish list!(, [   goto Left Marker bracket), ]   guess!, |   goto Tmark+i     goto next Instr-i     goto preceding Instr+v     next Volume level+t     next Tempo+x,',^ next eXpr (Instr, Level, Tempo)+/     next Time Sig+k     next Key Sig+g     goto next General Volume (future).      go back where last g command was issued from<space> repeat last g-command* Note: Almost everyone deals not in BARNUMs but in counts of*   barlines from beginning of score, starting at 1, not 0.*   Same applies when restricted to "special" barlines*   (other than Just Plain Singles).*   Findbar() returns -1 for failure, being in Index domain.** Uses globals godotind, lastgo[].*/void bell() {  /* putc(7, stderr)  Known to work! */     char c;     c = 7;     write(2, &c, 1);}/* Acceptor predicate functions to recognize items *//* Generic -- Test whether event is an Inclusion of the given Type */bool testype(evp, type)  EVENT   *evp;  sexy    type;{     return( !evp->part && (evp->show.INCTYPE == type) );}/* Test for any of Instr, Level, Tempo, General_Volume, or Accent *//* Should this also find Artics?  Maybe, but's that's separate. */bool anyexpr(evp)  EVENT   *evp;{     Reg sexy type;     return( !evp->part && (       ((type = evp->show.INCTYPE) == INSTR)       || (type == LEVEL) || (type == NUTEMPO) || (type==ACCENT)       || (type == GENVOL)|| (type == CRESC) || (type == ACCEL)       ) );}/* Label restriction rules are: l   any label, incl blank l*  " l** " la  'a' exactly lab "ab" exactly l?  any one-char l?? any two-char l?* any non-blank l*? " la? 2-char label starting with 'a' l?a 2-char label ending in 'a' la* 'a' or 'a' plus one more char l*a 'a' or any ending in 'a' */bool labpair(c, r)  char    c, r;{     if(r == '*')          return(TRUE);     if(r == '?')        /* Any c but NULL */          return(c != '\0');     return(c == r);     /* literal r, including NULL */} /* labpair() */          bool labmatch(c1, c2, r1, r2)  char    c1, c2, r1, r2;{     if( !r1)          return(TRUE);/* no r's */     if( !labpair(c1, r1))          return(FALSE);     if(r1 == '*') {          if( !r2)               return(TRUE);          return(labpair(c1, r2) || labpair(c2, r2));     }     return(labpair(c2, r2));}     bool anylabel(evp, arg)  EVENT   *evp;  sexy    arg; /* really two packed chars! */{     if( evp->part || (evp->show.INCTYPE != LABEL))          return(FALSE);     return(labmatch(evp->show.LCHAR1, evp->show.LCHAR2,       (arg >>8) & 127, arg & 127) );}/* End of Label reg-expr package */ /* Any note or rest */bool anypart(evp)  EVENT   *evp;{     return(evp->part > 0);}/* Tests for any Note with Artic other than TIED or NORMAL  90/7/6 */bool anyart(evp)  Reg EVENT   *evp;{     return( (evp->part > 0) && (evp->show.slot != REST)       && (evp->show.artic != NORMAL) && (evp->show.artic != TIED) );}bool anytie(evp)  Reg EVENT   *evp;{     return(evp->part && (evp->show.slot != REST) && (evp->show.artic==TIED) );}/* Tests for any type of Barline; == testbar(evp, FALSE) */bool anybar(evp)  EVENT *evp;{    return( (!evp->part) && (evp->show.INCTYPE <= FINE) );}bool anyrep(evp)  Reg EVENT   *evp;{     return( !evp->part && ((evp->show.INCTYPE==BEGREPEAT) ||       (evp->show.INCTYPE==ENDREPEAT) || (evp->show.INCTYPE==NTHENDING) ) );}bool anydcds(evp)  Reg EVENT    *evp;{     return( !evp->part &&       (evp->show.INCTYPE >= DACAPO) && (evp->show.INCTYPE <= DSSENZAREP) );}/* Custom-callable for any mix of the 4 MIDI_Event types */bool anyevt(evp, what)  Reg EVENT *evp;  int       what;   /* bit-codes IP=8, IS=4, TP=2, TS=1 */{     if(evp->part)          return(FALSE);     return( ((what & 8) && (evp->show.INCTYPE == IPEVT))       ||    ((what & 4) && (evp->show.INCTYPE == ISEVT))       ||    ((what & 2) && (evp->show.INCTYPE == TPEVT))       ||    ((what & 1) && (evp->show.INCTYPE == TSEVT))     );}/* Test whether event is a Barline, and of desired type.*  Note: special bars are also counted as ordinaries. */bool testbar(evp, special)  EVENT *evp;  bool special;{    return(anybar(evp) && (!special || (evp->show.INCTYPE != SINGLEBAR))    );}/* Tests for any type Barline of the given Number */bool numbar(evp, num)  EVENT   *evp;  int     num;{     return( anybar(evp) && ( EvBarNo(evp) == num ) );}/* Check restrictions on expr value, part num, and note/rest */bool restrict(evp, exval, partn, what)  Reg EVENT    *evp;  sexy    exval, partn;  char    what;{/* if(exval >= 0)  (*palert)("Part Restriction == ", 1, partn); */     if(partn > 0) {          if((what=='p') || (what=='P')) {   /* Just checking part */               if(evp->part != partn)                    return(FALSE);               return((what=='p') || (evp->show.slot != REST));          }     /* Note/Rest distinction no matter otherwise */          if((what=='a') || (what=='_'))     /* Restrict on note/rest */               return(evp->part==partn);          else if(evp->show.PARTNO != partn) /* Restriction on expr */               return(FALSE);     }     if(exval >= 0) {          if((what=='t') || (what=='r'))               return(evp->show.TEMPONO == exval);     /* INSTRNO also covers LEVELNO, MIDIchan, etc. */          if(evp->show.INSTRNO != exval)               return(FALSE);     }     return(TRUE);} /* restrict() *//* Scan a string for a DECIMAL number, sort of like strtol;*  diddle the caller's pointer past the number, if any */sexy scanum(sptr, def)  char    **sptr;   /* ->1st char of hoped no.; exit -> after it */  sexy    def;      /* Return this if not a number */{     char ch;     ch = **sptr;     if((ch < '0') || (ch > '9'))          return(def);     def = atoi((*sptr)++);     if(def > 9)    (*sptr)++;     if(def > 99)   (*sptr)++;     return(def);} /* scanum() *//* The main go-to-it routine.*  Figures where to show it before it finds it. */gobar(cmd)      /* Really gobar() */  char *cmd;   /* string, not very long */{     Index ind;     short           arg, /* specific inclusion type, if needed */          gx,  /* where to put it X-wise on screen */          nnn, /* user's numeric arg */          partn,    /* Part No. if given */          exval;    /* Expr Value for i, v, g, etc. */     char  c1, c2, what;     bool  special;     sexy  sign;      /* user's sign (mine's Pisces, what's yours?) */     char  *str;     Reg bool  (*pred)();  /* pointer to acceptor fcn */     str = pfdat1;  /* to pull in fake printf 349. bytes */     partn = 0;     /* invalid */     exval = -1;    /* invalid */     nnn = 1;     for(;;) {      /* Just to eliminate goto on "g " */          c1 = *(str = cmd);          if( !c1 || (c1 == '\n') )               return;          special = (c1 == 'G');        /* 'g' or 'G' */          if( (c2 = *(++str)) == ' ')   /* sign, 1st digit, or  what */               strcpy(cmd, lastgo);     /* repeat last g cmd */          else               break;                   /* ie, get on with biz */     }     if((c2=='.') || (c2=='u')) {  /* return to (undo) last g result */          ind = godotind;     /* old lftind */          gx = 0;          goto bc;     }     else      /* All normal commands pass thru here */          strcpy(lastgo, cmd);      /* save for possible "g " *//* Normal processing -- Check for sign */     sign = (c2=='+') ? 1 : ((c2=='-') ? -1 : 0);     if(sign)          c2 = *(++str);/* Number nnn? */     if( (c2 >= '0') && (c2 <= '9') ) {          nnn = atoi(str++);          if(nnn > 9)               str++;          if(nnn > 99)               str++;          if(nnn > 999)               str++;     }/* What sort of target? */     pred = testype;          /* generic inclusion matcher fcn */     switch(what = *str++)     {     case '\0':     /* nothing, bar */          if(!sign) {               if( !nnn) {    /* "g0" or "G0", same effect */                    gx = ind = 0;  /* force 1st event, no search */                    goto bc;               }               if( !special) {     /* "gNNN" new 89/2/24 */                    pred = numbar;                    arg = nnn;     /* note "g" means "g1" */                    break;               }          }     /* Signed and/or Special */          pred = testbar;          arg = special;          break;/* Markers get separate processing */     case '[':      /* Left marker */  /* case '(': */          arg = LMARK;          gx = 0;   /* Left edge (maybe should be near?) */          break;     case ']':      /* Right marker */  /* case ')': */          arg = RMARK;          gx = 79;      /* Right edge, mod same-timers */          break;     case '|':      /* To-marker */     case '!':          arg = TMARK;          gx = 41;      /* Center, same-timers to right */          break;     case '*':      /* End of piece */          ind = nevents - 1;          gx = 70;  /* near right edge */          goto bc;     case 'a': /* Artic */          pred = anyart;          goto party;     case '_': /* Tied note */          pred = anytie;          goto party;     case 'x': /* Any eXpression.  Part# invalid on some. */          pred = anyexpr;          goto party;     case 'i':      /* Instr */          arg = INSTR;          goto scanit;     case 'v':      /* Volume Level */          arg = LEVEL;          goto scanit;     case 'h': /* Hopper */     case 'm': /* Revoke later? */          arg = MCHOP;          goto scanit;     case 't':      /* Tempo */          arg = NUTEMPO;          goto scanonly;     case 'r': /* Ritard/Accel can restrict on Tempo, but not Beats */          arg = ACCEL;          goto scanonly;     case '/':          arg = TIMESIG;          break;     case 'k':          arg = KEYSIG;          break;     case 'e': /* Immediate Events */          pred = anyevt;          arg = 0xC;          break;     case 'E': /* Table Events */          pred = anyevt;          arg = 0x3;          break;     case 'n': /* Nth endings */          arg = NTHENDING;          break;     case 'f':      /* FINE. */          arg = FINE;          break;     case 'o':      /* Coda sign */          arg = CODA;          break;     case '$':      /* Segno sign */     case 's':          arg = SIGN;          break;     case 'd':      /* DC, DS, etc. */          pred = anydcds;          break;     case 'c':          arg = CLOCKON;          break;     case '^':          arg = ACCENT;          break;     case 'l':          pred = anylabel;          arg = *str++;                      /* 1st restricting char */          arg = (arg <<8) | (*str++ & 255);  /* 2nd, into short int */          break;     case ';':          pred = anylabel;          arg = *str++;  /* 1st restriction char */          arg = (arg <<8) | (*str++ & 127);  /* 2nd */          break;     case ':':      /* Repeats incl Nths */          pred = anyrep;          break;     case 'g':      /* General volume */          arg = GENVOL;          goto scanonly;     case '<': /* Cresc/Dim can restrict on Level, but not Beats */     case '>':          arg = CRESC;scanonly: exval = scanum(&str, -1);          break;   /* Scan for argument restriction, fall into party */scanit:   exval = scanum(&str, -1);   /*  Check for Part# restriction */party:    if((*str++ != 'p') && (*str != 'P'))               break;     /* Fall thru.  Accept Extended_Hex or Decimal part no. */     case 'p':      /* Part No. by itself */     case 'P':      /* Must be Note not Rest */          c1 = *str++;          if((c1 >= '1') && (c1 <= '9')) {     /* Note 1 not 0 */               partn = c1 - '0';     /* In case of 2-digit decimal part no. */               if( ((c1 = *str) >= '0') && (c1 <= '9'))                    partn = 10 * partn + (c1 - '0');          }     /* Hex part needs only one digit */          else if((c1 >= 'a') && (c1 <= 'g'))               partn = c1 + 10 - 'a';          else               partn = 1;     /* Default, useful */          break;     default:       /* Fail safe, do NOTHING! */          bell();          return;          } /* switch */     if((what=='p') || (what=='P'))          pred = anypart;/* If searching relative to right (left),*  start from right (left)-most such item on screen. */     if(sign) {          ind = searcher(lftind, ritind, (sign > 0) ? 25*16 : 1,            pred, arg, exval, partn, what);          if(ind < 0)         /* no such item on screen */               ind = lftind;  /* good as any */     }     else          ind = 0;  /* absolute, from beginning */ /* Now find the real target */     ind = searcher(ind, (sign < 0) ? 0 : nevents - 1, nnn,       pred, arg, exval, partn, what);/* Screen X goal depends on left or right search and special cases */     if(sign < 0) {          if(what == ' ')          /* barline */               gx = nnn ? 0 : 79; /* rt-justify if "g-0" */          else               gx = 79;           /* right edge */     }     else                /* Absolute or +nnn */          gx = 0;        /* Hard left */     if(ind == nevents -1 )          gx = 60;           /* 3/4 over if last event *//* Skip to here when goal index was known, else fall in *//* Convert target index (if valid) to Showall() goals */bc:  if(ind < 0) {          (*palert)("None found.", 0);          return;   /* Invalid, do nothing */     }     gind = ind;         /* OK, update globals */     xgoal = gx;     godotind = lftind;      /* save for later "g." */     rfr_scr = TRUE;} /* gobar() *//* General-purpose event-type finder.* Different mixes of args can do anything gobar() needs.*/Index searcher(start, limit, howmany, fcn, arg, exval, partn, what)  Index   start,    /* starting index */          limit;    /* index to stop on */  short   howmany;  /* or stop after this many */  bool    (*fcn)(); /* tests for a hit */  short   arg;      /* feed this to fcn() */  sexy    partn, exval;  /* PartNo & Expr Value restrictions */  char    what;     /* User's target spec, for restrictor */{     Index     hit;           /* index of last successful test */     bool      reverse;     Reg EVENT *evp;/* Prepare for the Loop */     evp = i2p(start);     hit = -1;      /* invalid *//* Adjust the case where you're already sitting on such an item */     if( start && (*fcn)(evp, arg) && restrict(evp, exval, partn, what) )          howmany++;          /* don't count the freebie starter */     for(reverse = (limit <= start);       howmany && (reverse ? (curind >= limit) : (curind <= limit));       evp = reverse ? decdec() : plusplus() )     {          if( (*fcn)(evp, arg) && restrict(evp, exval, partn, what) ) {               howmany--;               hit = curind;   /* record success */          }     }     return(hit);} /* searcher() *//* eof GoBar.C */