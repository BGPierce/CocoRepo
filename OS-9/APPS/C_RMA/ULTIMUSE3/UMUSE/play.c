/* file ~VMem/PLAYART.C   --11--  MIDI synther driver for UltiMuse* 00/10/7 'chrind' limited to 0--49.* 98/3/14 Timesigs don't change beat unless paired with a Tempo.* 92/5/28 Better fixed-point ticks compensation* 91/9/17 Compensated for missed ticks, using getclock()* 90/9/20 started Cresc/Dim, then Accel/Rit* 90/6/11:  Structurized* 90/5/27-6/27  Articulation system.  Benefits:   No need to kill notes at barlines in case of Tacet following   Simpler handling of Ties  Rests are entered as ZERO remtimes.  Tied notes entered as full duration plus 2 more ticks, steda tieds[].*/#include <stdio.h>#include "wmuse.h"#include "keys.h"#include "vmem.h"#include "fcnptrs.h"#include "macros.h"/* #define STATS 1 *//* #define SERCOMP 1     /* Serial-port residue feed-forward compensation */#define UART   SPCHSYS   /* normal production *//* #define UART   COLORCH  /* Mike Bridges, Nashville */#define Print  (*pprintf)#define Alert  (*palert)#define Flush  (*pflush)#define Smfd   if(smf) smfdelout()#define MIDICLKS    2    /* Our_ticks per MIDI Clock period *//* New TEMPCON * 60 == previous 1200 */#define TEMPCON     20        /* Human <--> Machine tempos */#define SPCHSYS     0xFF6E    /* Speech Systems C/S reg */#define COLORCH     0xFF66    /* ColOrchestra's C/S reg */#define NOTEOFF     0x80#define NOTEON      0x90#define PARAM       0xA0#define CHMODE      0xB0 /* ANO and OMNI on/off */#define PATCH       0xC0#define AFTERTCH    0xD0#define BENDER      0xE0#define TIMCLK      0xF8 /* Drive drum machines, PSS-480, etc. */#define MSTART      0xFA /* start & stop drum machines */#define MSTOP       0xFC/* For repeats, Ith endings, DC/DS, Coda, etc */#define RS_SIZE 8typedef struct {    Index lefty;    sexy  repcnt;} REPSTACK;typedef struct {    /* size 16, was 13  92/5/21 */  sexy    pchans;   /* Part's MIDI channel */  sexy    notes;    /* now playing MIDI no. */  int     remtimes; /* ticks remaining */  sexy    prtbots,  /* Botnote cache, must match playstaff(&bn) */          midlvls;  /* current MIDI level */  int     trannies, /* transpose semis */          itrans;   /* Instrs' +-12 contribution */  byte    plarts,   /* previous artic, for defaults */          oldslots; /* previous slot playing, tie tester */ } PLAYPART;extern short getclock();extern direct FILE  *fmidi;extern ubyte   chans[NPARTS + 1];  /* Part --> MIDI_channel assgnmts */extern bool    partens[NPARTS + 1], chanens[16];extern byte    levels[];           /* volumes per parts */extern sexy    instvals[];         /* inst #s ==> MIDI patch #s */extern char    filename[],               instnams[][INAMEL];extern ubyte   percmids[17];extern direct Index     gind;extern direct bool     tripper, rfr_scr, midipak, midiser, mididev, instren, midievts, pldebug,     clocken, scrclock;extern direct sexy     runstat,     broke,         /* interrupt (BREAK) flag */     nparts, keysig, velo,     numer, denom, xgoal,     secmin, transp;  /* secmin == seconds per minute */extern direct ubyte     mydat0,     midinnmin, midinnmax;extern direct short     scorelvl;extern direct byte  accentwt;/* Direct-Page stuff for speed */extern direct char     *midics;extern direct bool     sound, inending, smf,     senzarep;      /* turns repeats off */extern direct REPSTACK *rsptr;     /* pointer to 1st empty stack slot */extern direct sexy     plpart, plslot, white, midnote, oldmid, chrind, fix,     plart, midchan, accent;extern direct unsigned     contemp,  /* secmin * TEMPCON */     tempo,    /* Human (score) tempo */     machtemp,     smfdelta,     midicnt;extern direct Index     sign, dcds,  /* Sign and DC/DS */     nthendx,     /* Next Ith ending's loca */     coda;extern direct short     residue;extern direct Etime     now, lastime;extern direct Deltime    /* both -dur's shud be Etime ?? */     delt, dendur, zonedur;/* 90/9/29 */extern direct Deltime     takeoff,  /* ticks to clear min of remtimes[] */     tilloff,  /* ticks till next note turnoff */     ttemp;    /* time temporary */extern direct int     towait;   /* ticks to wait in sleep60() *//* Cresc & Accel vars */extern direct Deltime     crdelt, acdelt;   /* runtime so far */extern direct short     crbeglvl, acbegmt, /* init vol & machtemp*/     crmult, acmult, acscale;/* End of cresc & accel */extern char pfdat1[];    /* dummy printf stuff */void main(what, first, last)   /* really play() */  char    what;     /* selector, not used */  Index   first, last;{     REPSTACK repstack[RS_SIZE + 1];     PLAYPART parties[NPARTS+1];     ubyte          bigkeyc[50],    /* Seven white Key of C octaves */          chroma[50],     /* Seven White octaves blackened for KeySig */          thiskey[7];     /* One-octave intermediary */#ifdef STATS     unsigned  counter, cumer, zeros, holes;#endif/* Deferred timesig-changes items 98/3 */     sexy nunumer, nudenom;     Time tsstart;/* Cresc vars (move up later) */     Deltime   crnticks; /* how long to go for */     bool crescon;     sexy crendlvl; /* target vol 1-127 *//* End of cresc *//* Accel vars (move up later) */     Deltime   acnticks; /* how long to go for */     bool accelon;     int  acendmt;/* End of accel */     sexy      hilo;     int       avgvol;     Index     evx;     int       oldtick;     bool      doclock;     int       clocks;   /* ticks remaining before next MIDI Clock */     int       basevol;     PLAYPART  *pptr;    /* on top of stack */     register EVENT  *evp;/* Execute some code already! */#ifdef STATS     counter = cumer = zeros = holes = 0;#endif     getmydat();     /* (*palert)("DAT.0 at", 1, mydat0); */     midics = pfdat1;            /* just to get it linked */     if( !smf)          setpr(group, 254);/* Set up MIDI UART (Speech Systems 6850) */     if(midipak) {          midics = (char *) UART;          *midics = 0x17;     /* Master Reset */          *midics = 0x15;     /* working modes */     }/* Prepare BREAK catcher */    broke = 0;  /* differs from main prog, no quit *//* Init your own mind */     avgvol = (levels[3] + levels[4]) >>1;   /* average(mp, mf) */     basevol = velo;     contemp = TEMPCON * secmin;     for(plpart = 1, pptr = parties+1; plpart <= nparts;  pptr++, plpart++)     {          pptr->plarts = LEGATO;          pptr->remtimes = pptr->notes = 0;          pptr->midlvls = levels[4];      /* mf */          pptr->oldslots = REST;          pptr->pchans = chans[plpart];/* Load rapid-access part->botnote cache and transposer vector.*  Re-do only if parts hop to different staves (sure...) */          playstaff(plpart, &(pptr->prtbots), &hilo);     /* Don't transpose drum parts */          pptr->trannies = ((hilo & PERC) != 0) ? 0 : transp;          pptr->itrans = 0;     }     nthendx = sign = dcds = coda = BADIX; /* illegal index */     accelon = crescon = senzarep = FALSE;/* Prepare for THE MAIN LOOP */    inending = sound = FALSE;    tilloff = takeoff = 32767;    keysig = runstat = 0;    tempo = 120;    /* (TimeSig defaults to globals) */    lastime = 0;     nunumer = numer;     nudenom = denom;     tsstart = 0;/* Always make beginning a left repeat for stack's sake */    rsptr = repstack;    rsptr->lefty =  0;    (rsptr++)->repcnt = 0;/* Init (just once) full-keyboard Key of C reference */     newkey7(thiskey, 0);     spread50(thiskey, bigkeyc);/* Re-init chroma[] in two stages: *//* Use KeySig to form one octave into thiskey[];*  must re-do only if new KeySig is encountered */     newkey7(thiskey, keysig);/* Replicate thiskey[] thru 7 octaves of chroma[].*  Must re-do after each BarLine to clear Accidentals. */     spread50(thiskey, chroma);     tempcon();     /* convert tempo domain */     residue = accent = 0;     clocks = MIDICLKS;     smfdelta = 0;     if(smf)          smfhead(tempo);     if(doclock = (scrclock && clocken) )          putsys(MSTART);     /* incl. SMF wrapper */     if(pldebug) {Print("Key %d\n", keysig); Flush(); }     sleep60(2);#ifdef SERCOMP     midicnt = 0;#endif/* ------------ THE MAIN LOOP ----------- */     for(evp = i2p(evx = 0); evx < nevents; evp = plusplus(), evx = curind)     {        if(broke) {    /* Move screen to last event played if ^C instead of BREAK */            if(broke == 3) {                gind = curind - 1;    /* undo loop's plusplus() */                xgoal = 40;        /* center screen */                rfr_scr = TRUE;            }            break;        }/* Turn sound on if caught up with specified start point, * but don't reset it after a backwards goto -- * if neither test applies, leave it as-is. */          if(evx >= first) {               if( !sound)                    oldtick = getclock();               sound = TRUE;          }          if(evx > last)               sound = FALSE;/* Kill time iff present "chord" is all turned on *//* This still works with new Unsigned times in events */                    now = evp->startime;          if( (delt = now - lastime) > 0) {   /* new chord */               if(mididev)                    (*pmflush)();               accent = 0;               lastime = now;               crdelt += delt;               acdelt += delt;               if(sound)               {                    fix = keysense();/* NEW LOOP -- inside "if(sound)" but tabbed 4 less *//* Entry conditions:  delt > 0 == time from old lastime till now (next event);*  clocks == 1 or 2;  takeoff = ticks till next note turnoff.*/do {/* Which of 3 things will happen next? */     towait = (delt > tilloff) ? tilloff : delt;  /* min() */     if(doclock) {          if(towait < clocks)      /* ie, towait == 1 */               clocks -= towait;          else {               towait = clocks;               putsys(TIMCLK);               if(mididev)                    (*pmflush)();               clocks = MIDICLKS;  /* = 2 */          }     }/* Sleep */     smfdelta += (ttemp = towait);     if( !smf) {          if(fix & SHIFT) {     /* Fast Forward */               if(ttemp & 1)      /* if odd, */                    residue += 32; /* credit half a tick */               ttemp >>= 1;          }          else if(fix & CTRL)              /* Half Speed */               ttemp += ttemp;          residue += ttemp * machtemp;#ifdef SERCOMP/* Deduct time spent on serial MIDI bytes from residue,*   5/4 of a residue for each byte */          if(midiser && /* !midipak && */ !mididev)               residue -= (midicnt + (midicnt >>2));          midicnt = 0;#endif/* Miss any ticks?  Check 60 Hz countdown clock's current value*  against when we woke up.  91/9/17 */          if((oldtick -= getclock()) < 0)   /* normally positive */               oldtick += 60;      /* rollover */#ifdef STATS          if(oldtick) {               counter++;               cumer += oldtick;          }#endif          residue -= (oldtick <<6); /* THE Clock Compensation fix! */               if( (ttemp = residue >>6) > 0) {               residue &= 63;      /* credit & delete its integer part */               sleep60(ttemp);     /* THE ONLY sleep() in play() */          }          oldtick = getclock();    /* Remember exact time we woke up */     } /* if( !smf) *//* Reduce each part's time by sliver 'towait',*  iff at least one part should turn off. */     if( (tilloff -= towait) <= 0) {   /* shud never be < */          tilloff = 32767;             /* to find new takeoff */          for(plpart=1, pptr=parties+1; plpart <= nparts; pptr++, plpart++) {               if((ttemp = pptr->remtimes) <= 0)                    continue;      /* part wasn't playing *//* Still playing, deduct and test for turnoff */               if( (pptr->remtimes = (ttemp -= takeoff)) > 0) {                    if(ttemp < tilloff)      /* Still on, update min */                         tilloff = ttemp;               }/* Tied notes get turned off in PlayNote section, unless dangling */               else {  /* Turn note off -- no rests here */                    if(partens[plpart] && chanens[pptr->pchans]) {                         Smfd;                         if( (oldmid = NOTEON + pptr->pchans) != runstat)                              midiwr(runstat = oldmid);    /* Abuse oldmid */                         midiwr(pptr->notes);                         midiwr(0);     /* OFF */                    }               } /* turnoff */          } /* for plpart */          if(mididev)               (*pmflush)();          takeoff = tilloff;     } /* if reduce */} while( (delt -= towait) > 0); /* Exit conditions: delt==0, tilloff >= 0, clocks = 1 or 2.*  tilloff is updated for 'now' which == evp->startime;*  takeoff is still full value of smallest remtime.*/               } /* if(sound) *//* Crescendo update */               if(crescon) {                    if(crdelt >= crnticks) {                         crescon = FALSE;                         basevol = crendlvl;/* if(pldebug) {Print(" Cresc/Dim ended.\n"); Flush(); } */                    }                    else                         basevol = crbeglvl + ((crmult * crdelt) >> 8);               }/* Accel update */               if(accelon) {                    if(acdelt >= acnticks) { /* Finish */                         accelon = FALSE;                         machtemp = acendmt;                    }                    else                         machtemp = acbegmt + ((acmult * acdelt) >> acscale);                    if(smf)                         smftempo(temprev(machtemp));               }          } /* if(delt) *//* Time's up, analyze this event */        plslot = evp->show.slot;     /* assumed INCTYPE */        if( !evp->part) { /* Inclusion processing *//* If any barline, print number, reset accidentals to keysig. */            if(plslot <= FINE)  {    /* any barline */                spread50(thiskey, chroma);                if(pldebug) {Print("%d ", EvBarNo(evp)); Flush(); }            }            switch(plslot) {            case CLOCKON:                if(evp->show.PARAM1) {  /* ON */                     if(doclock = clocken)                         putsys(MSTART);                }                else if(doclock) {      /* OFF */                    doclock = FALSE;                    putsys(MSTOP);                }                break;            case FINE:                if(dcds != BADIX)      /* if a DC or DS is on */                    evx = nevents; /* This exits Main Loop */                break;            case BEGREPEAT:                if(rsptr > repstack + RS_SIZE)                    Alert("**Stack Full!\n", 0);                else {                    rsptr->lefty = evx;                    (rsptr++)->repcnt = 0;                    nthendx = BADIX;   /* Nth ends */                }                break;            case ENDREPEAT:                if(rsptr == repstack)                    Alert("**Stack MT!\n", 0);                else if((--rsptr)->repcnt ==0) { /* pop */                    rsptr->repcnt++;        /* count use */                    evx = (rsptr++)->lefty; /* push back */                }                /* else leave stack popped, go on */                break;            case NTHENDING:        /* Still needs senzarep mode */                inending = TRUE;                if(evp->show.REPENDN == 1) {                    if(nthendx != BADIX) {  /* already played 1st */                        evx = nthendx; /* skip to next */                    }                   /* else play 1st ending by default */                }                else {  /* not 1st ending, repeat back */                    nthendx = evx;  /* for next time */                    if(rsptr == repstack) {                        Alert("**Stack MT!\n, 0");                        break;                    }                    inending = FALSE;                    evx = (rsptr - 1)->lefty;                }                break;            case DOUBLEBAR:     /* stops Nth endings */                if(inending && (nthendx !=BADIX)) {  /* were we doing Nth's? */                    nthendx = BADIX;                    rsptr--;    /* Pop stack */                }                break;/***** End BarLine types, do other Inclusions *****/          case NUTEMPO:               accelon = FALSE;               tempo = evp->show.TEMPONO & 255;               if(pldebug) {Print("Tempo %d.\n", tempo); Flush(); }     /* Was there a TimeSig just before? */                    if(evp->startime == tsstart)                    goto tsupdate;               tempcon();               if(smf)   smftempo(tempo);               break;          case TIMESIG:               nunumer = evp->show.TSNUMER;               nudenom = evp->show.TSDENOM;               tsstart = evp->startime;     /* Update system iff TimeSig is at very beginning */               if(evp->startime)   /* nope */                    break;     /* ... or if a Tempo comes next */tsupdate:               numer = nunumer;               denom = nudenom;               if(pldebug) {Print("%d/%d\n", numer, denom); Flush(); }               tripper = (denom >= 8) && (numer >= 6) && !(numer % 3);               zonedur = dendur = 192 / denom;               if(tripper)                    zonedur += (dendur + dendur);               tempcon();   /* keep wrt denom */               if(smf) {                    smftimes();                    smftempo(tempo);    /* so MIDI player can recompute */               }               break;          case KEYSIG:        /* build new keysig */               newkey7(thiskey, keysig = evp->show.KSN);               spread50(thiskey, chroma);               if(smf)   smfkeys();               if(pldebug) {Print("Key %d\n", keysig); Flush(); }               break;          case GENVOL:               crescon = FALSE;               basevol = velo + levels[evp->show.LEVELNO] - avgvol;/* if(pldebug) {Print(" GenVol=%d.\n", basevol); Flush(); } */               break;          case ACCENT:               accent = (evp->show.PARAM1 > 0) ? accentwt : (-accentwt);               break;          case CRESC:               crescon = TRUE;               crdelt = 0;               crbeglvl = basevol; /* capture current level */               crendlvl = velo + levels[evp->show.LEVELNO] - avgvol;               crnticks = zonedur * evp->show.pitmod;  /* nbeats */               crmult = ((crendlvl - crbeglvl) <<8) / crnticks;               break;          case ACCEL:               accelon = TRUE;               acdelt = 0;               acbegmt = machtemp;               acendmt = hum2mach(evp->show.PARAM1 & 255);               acnticks = zonedur * evp->show.pitmod;  /* nbeats *//* History lesson, kids -- remember FLOATING POINT? */               acscale = 0;               if( !(acmult = acendmt - acbegmt))                    accelon = FALSE;    /* just forget it */               else if(acmult < 0) {    /* Accel */                    while((acmult += acmult) < 0)                         acscale++;                    acmult = (acmult >> 1) | 0x8000;               }               else {    /* Rit. */                    while((acmult += acmult) > 0)                         acscale++;                    acmult = (unsigned)acmult >> 1;               }               acmult /= acnticks;                              break;          case INSTR:    /* Warning -- redefines 'pptr' */               if( !instren)  /* Loses any +-8va stuff too */                    break;               pptr = parties + evp->show.PARTNO;/* Deliberately ignore Part Enable */               if(chanens[pptr->pchans]) {                    Smfd;                    midiwr(runstat = PATCH + pptr->pchans);                    midiwr(instvals[fix = evp->show.INSTRNO] & 127);               }               fix = instnams[fix][0];         /* 16' and 4' feature */               pptr->trannies -= pptr->itrans;  /* Undo previous shift */               pptr->trannies +=                 (pptr->itrans = ((fix=='+') ? 12 : ((fix=='-') ? -12 : 0) ));               break;          case LEVEL:               (parties + evp->show.PARTNO) ->midlvls                 = levels[evp->show.LEVELNO];               break;          case MCHOP:    /* First kill note on old channel */               pptr = parties + (plpart = evp->show.PARTNO);               if(pptr->remtimes > 0) {                    pptr->remtimes = 0;                    if(partens[plpart] && chanens[pptr->pchans]) {                         Smfd;                         midiwr(runstat = NOTEON + pptr->pchans);                         midiwr(pptr->notes);                         midiwr(pptr->notes = 0);                    }               }               pptr->pchans = evp->show.INSTRNO;  /* really CHANNEL */               break;           case IPEVT:          case ISEVT:     /*   case TPEVT:          case TSEVT: */               if(midievts) {                    playevt(evp);                    runstat = 0;               }               break;/* Go-to items, a la standard musical notation;*  Handles multiple Sign+Coda sections! */          case SIGN:                sign = evx;     /* remember where */                break;          case CODA:  /* both goto and label *//* Assume 2nd coda sign (the label) is 1st playable*  event after the DC/DS.  Just go to the DC/DS.*  1st IF scope extended 89/7/29, fixed Jon Howell's BUG */                if(dcds != BADIX) {    /* assume coda_come follows */                    evx = dcds;                     dcds = BADIX; /* no lOOp on label! */                     if(nthendx != BADIX) {   /* were we doing Nth's? */                         nthendx = BADIX;                         rsptr--;    /* Pop stack */                     }               }               break;           case DCSENZAREP:    /* from the top, no reps */                senzarep = TRUE;           case DACAPO:        /* from top, do repeats */                dcds = evx;     /* save your loca */                evx = 0;                break;           case DSSENZAREP:    /* from Sign, no reps */                senzarep = TRUE;           case DALSEGNO:      /* from Sign, do repeats */                if(sign == BADIX)                    Alert("**No Sign!\n", 0);                else {                    dcds = evx;     /* save your loca */                    evx = sign;                }                break;/* Add:* CALL label* LABEL -- later spit out a smf.MID code*/            } /* switch */        /* In case evx got moved: */            if(evx != curind) {    /* yes, it got moved */                 evp = i2p(evx);   /* sets  curind = evx */                 lastime = evp->startime;            }            continue;   /* Skip Note/Rests */        } /* end inclusions *//*************** Play note or rest ********//* Changes for Artics:* Old note is already off unless Tied.* Compute new sounding duration for remtimes[] even if old was Tied.*/          pptr = parties + (plpart = evp->part);          if( !partens[plpart])               continue;          if( !chanens[midchan = pptr->pchans])   /* 00-15 chans */               continue;          oldmid = pptr->notes;          plart = evp->show.artic;          if(plslot == REST) {               midnote = 0;    /* Rest in this context */          }          else { /* Note */               if( !(midnote = pptr->prtbots)) { /* Perc part */                    midnote = percmids[plslot + 4];               }               else { /* Music, not drums :-) */                    chrind = midnote + plslot;                    while(chrind < 0)                         chrind += 7;                    while(chrind > 49)                         chrind -= 7;                    if( !(fix = evp->show.pitmod) ) { /* no accidental */                         midnote = chroma[chrind];                    }                    else {   /* keep accidental thru bar */                         chroma[chrind] = midnote = bigkeyc[chrind]                           + "\x00\x00\x01\x02\x00\x00\xFE\xFF"[fix];                    }                    midnote += pptr->trannies;               }     /* Professional-grade MIDI-range folding; needs int, not byte */               while(midnote > midinnmax)                    midnote -= 12;               while(midnote < midinnmin)                    midnote += 12;          } /* note vs rest *//* Before playing, update partwise Artic history */          if(plart == NORMAL)  /* i.e., none; use history */               plart = pptr->plarts;          else if(plart != TIED)               pptr->plarts = plart;/* Do "sound" test here to respect accidentals, ties, artics *//* Skip if sound not yet started */          if(!sound)               continue;          if(plslot==REST)               ttemp = 0;          else {/* LAST USE of evp */               ttemp = cod2raw(evp->show.dur, evp->show.durmod);               switch(plart) {               case TIED:                    ttemp += 2;    /* extra ticks keep it lit */                    break;               case MARCATO:                    ttemp -= (zonedur >> 3);  /* 32nd note in N/4 */                    break;#ifdef PIZZICATO               case PIZZICATO:                    ttemp = dendur >> 3;                    break;#endif               case STACCATO:                    ttemp >>= 1;                    break;/* default: LEGATO: NORMAL:  just leave full-length as-is! */               } /* switch *//* Avoid "slivering" or neg */               if(ttemp < 2)                    ttemp = 1;     /* Was 2  92/5/5 */          } /* note vs rest *//* Was previous note tied?  If so, valid for this new note? */          if(pptr->remtimes > 0) {   /* still kickin', assume Tied */               if( (midnote == oldmid)                  || ( !fix && (plslot == pptr->oldslots)) )                    goto validtie;               else {    /* Invalid Tie, MUST turn off */                    Smfd;                    if( (fix = NOTEON + midchan) != runstat)                         midiwr(runstat = fix);    /* OFF */                    midiwr(oldmid);                    midiwr(0);               }          }/* At last, record and play it! */          if(pptr->notes = midnote) {    /* '=', don't play new Rest */               Smfd;               if((fix = NOTEON + midchan) != runstat)                    midiwr(runstat = fix);               midiwr(midnote);     /* Re-use fix */               fix = pptr->midlvls + basevol + accent;               if(fix > 127)                    fix = 127;               else if(fix < 1)                    fix = 1;               midiwr(fix);          }validtie:/* Skip these if !sound, so tied notes WILL sound on entry */          if(ttemp) {    /* if Note */               if(ttemp < tilloff) {                    takeoff = ttemp + (takeoff - tilloff);                    tilloff = ttemp;               }     /* Boost ttemp to match bloated array entries;     *  sets ttemp = takeoff if above block fired */               ttemp += (takeoff - tilloff);          }          pptr->remtimes = ttemp;          pptr->oldslots = plslot;    /* for Tie validations */     } /* Main Loop *//* F.I.N.E.!  Only way out is here!* Turn off any still playing.  Don't trust ANO. */     if(doclock)          putsys(MSTOP); /* shoot the drummer */     for(pptr = parties + nparts; pptr > parties; pptr--) {          if(pptr->remtimes) {               Smfd;               midiwr(NOTEON + pptr->pchans);               midiwr(pptr->notes);               midiwr(0);          }     }     if(smf)          smfinish();     broke = 1;  /* send BREAKs to Quit option */     setpr(group, 140);#ifdef STATS     (*palert)("Fix Count, CumErr, 0's, -'s: ",       4, counter, cumer, zeros, holes);#endif} /* play() *//* eof play.c */