/* KPSUBS.C  Subrs for KeyPad()  98/3/15 *//* #include <stdio.h> */#include "wmuse.h"#include "wcodes.h"#include "vmem.h"#include "macros.h"#include "screen.h"#include "wmenu.h"#include "windows.h"#include "fcnptrs.h"#define Print  (*pprintf)#define Write  (*pnfwrite)extern direct sexy     curcurse,     numer, denom, nzones, dencodur, nstaves, nparts;extern direct Deltime     dendur, zonedur;extern direct bool     tripper, thick;extern STAFF   staves[];extern CLEF    clefs[];extern PART    parts[];extern ubyte   grafxes[], grafyes[];extern direct char  *pct7, *pctn1, *pctn2;/* "ArgBox" for faster piping to Fran.*  These MUST be kept contiguous and in order! */extern direct ubyte     arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7;/* Crap needed to force RLINK to link in pfdat347.r */extern char pfdat1[];char *pfdum() {   /* Just to link in pfdat stuff */     return(pfdat1);}bool ispwexpr(slt)  sexy    slt;{     return( (slt==INSTR) || (slt==LEVEL) || (slt==MCHOP)       || (slt==IPEVT) || (slt==TPEVT) );} /* Tests for any type of Barline; == testbar(evp, FALSE) */bool anybar(evp)  EVENT *evp;{    return( (!evp->part) && (evp->show.INCTYPE <= FINE) );}sexy partstaff(part, sty, lownote, hilo)    /* Returns staff # */  sexy  part;       /* INput; rest are OUTputs: */  short *sty;       /* staffY */  sexy  *lownote;   /* clef.bnote */  sexy  *hilo;      /* indicators */{    sexy            istaff;    register STAFF  *stptr;    if((part < 1) || (part > nparts)) {        part = nparts;     }    istaff = parts[part].pstaff;    *hilo =  parts[part].philo;    *sty =  (stptr = staves + istaff) -> staffY;    *lownote = clefs[stptr->clef_no].bnote;    return(istaff);} /* partstaff() *//*** Open a Pat & Vanna overlay window ***/wcreate(leftcol, topy, colswide, rowshigh, dosave, style)  sexy    leftcol, topy, colswide, rowshigh, style;  bool    dosave;{     Print(pct7, OWST, leftcol, topy, colswide, rowshigh, dosave, style);}/*** Close above window type ***/wkill() {     Print(pctn1, OWEN);}/* Wait for mouse to be released.  No-op if not being held. */void waitmouse() {     int     x;     while( (*pmouce)(&x, &x) != 0)          tsleep(4);     /* meaning 3 ticks */}bell() {  /* putc(7, stderr)  Known to work! */     char c;     c = 7;     write(2, &c, 1);}void curset(curtype)  sexy    curtype;{     curcurse = curtype;     (*pprintf)(pctn2, SCUR, curtype);}alcurset(onoff)  bool    onoff;{     (*pprintf)(pctn2, ACUR, onoff);   }void dialogue(big)    /* Open a small Double window */  bool    big;{     wcreate(14, 110, 50, big ? 5 : 2, TRUE, WSDOUBLE);}void menu(code)  sexy    code;{     (*pprintf)(pctn2, MENU, code);}phrase(x, y, s, caps)  sexy    x, y;  char    *s;  bool    caps;     /* Capital letters only, for Menu Bar */{     (*pprintf)("%c%c%c%c%s\n", PHRS, x, y, caps, s);} /* phrase() *//* New version ignores color, since Fran does already! 89/9/30 */yclear(y1, y2, paint)  short y1, y2, paint;{     Clear(0, y1, 79, y2, paint);  /* still send paint arg */} /* yclear() */void barwindow(xc, str)  sexy    xc;  char    *str;{     yclear(SCORTOP+2, HM1-1);     phrase(xc, HM1-5, str, FALSE);}/* BYTBLT() series of rectangle Blit functions * to move the given rectangle to/from a  byte array 'where[].' * Usually called as more mnemonic macros. * Stripped down for kp.c */bytblt(what, xc1, y1,  xc2, y2)  sexy what;  /* 0=Get, 1=DynaPut, 2=Clear, 4=Blacken, 3=Invert, 5=OrPut */  sexy xc1, y1, xc2, y2;{     int n, color = 1;       /* Foreground */     if(y1 < 0)     y1 = 0;     if(y2 < 0)     y2 = 0;     arg1 = xc1;     arg2 = y1;     arg3 = xc2;     arg4 = y2;/* Choose which way to move what */     switch(what) {     case 2:   /* CLEAR area to all-Background */          color = 0;     case 4:   /* PAINT to Foreground  */          arg0 = CLR;          arg5 = color;          n = 6;          break;     case 3:   /* INVERT area, used by KP */          arg0 = NBOX;          n = 5;          break;     default:          (*palert)("Bad BytBlt ", 1, what);          return;     } /* switch */     (*pnfwrite)(n);     (*pflush)();} /* bytblt() *//* eof kpsubs.c */