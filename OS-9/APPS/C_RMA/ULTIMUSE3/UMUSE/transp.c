/* TRANSP.C  begun 91/08/22 about two years too late */#include "wmuse.h"#include "vmem.h"/* Limits are place()'s slot limits, -15 thru +16 + 4, NOT sacred, *  but these avoid creating un-editable notes. */#define MAXSLOT     20#define MINSLOT     (-11)extern char    pfdat1[]; /* To pull in printf data-faker module */extern direct sexy     nparts, nstaves, keysig;extern sexy    transtaff();extern void    (*palert)();extern bool    (*pfixmarx)(), (*pyesno)();extern Index   (*penter)();extern Time    (*pfulltime)();extern STAFF staves[NSTAVES];extern PART  parts[NPARTS + 1]; /* Parts are ORG 1, not 0! *//* Botnotes are White keys above 16' C==01.  Mid C ==22. */extern CLEF  clefs[];/* Given no. of semitones to transpose up or down,*  return number of sharps to add to orignal key.*  Output limited to -6 (flats) thru +6 sharps.*/sexy sem2sharps(sems)  sexy    sems;{     sexy deltakey;/* Convert all "downs" to ups */     while(sems < 0)          sems += 12;     deltakey = (sems * 7) % 12;   /* This gives 0-11 sharps */     if(deltakey > 6)              /* convert to flats */          deltakey -= 12;/* (*palert)("SemisUp -> Delta_Sharps", -2, sems, deltakey); */     return(deltakey);}/* Given a keysig -7 thru +7 and a 7-slot array*  representing white scale C-B, set each element for how much*  the given key sharps or flats each white note, by -1, 0, or +1.*  Adapted from newkey7() in playsubs.c*/void ks2array(key, array)  sexy    *array;  sexy    key;      /* no. of sharps or flats */{     sexy step, inc, start;     Reg sexy  *rap;     rap = array;     for(start = 8; --start; )   /* Clear array to 0 */          *rap++ = 0;     if( !key )          /* Key of C, done */          return;     rap = array;     if(key > 0) {       /* Sharps */          start = 3;     /* 1st one is F */          step = 4;      /* up by 5ths */          inc = 1;     }     else {              /* Negative, Flats */          start = 6;     /* 1st one is B */          step = 3;      /* up by 4ths */          inc = -1;          key = -key;     }     for( ; --key >= 0; ) {          *(rap + start) = inc;   /* zap that note */          if((start += step) > 6)               start -= 7;     }} /* ks2array() *//* Given keysig, return note letter C-B as 0-6.*  No input range checking for wild keysigs.*/sexy key2let(key)  sexy key;{     if( !key)          return(0);     if(key > 0)          return( (4 * key) % 7);     else          return( (-3 * key) % 7);} /* key2let() *//* Incredible RLink bug prevents including this fcn in main file;*  it must be kept separate, tho near-identical to other versions. */#ifdef ALLINONE/* Parnasian interface to Staff; given Part No., returns the other items *//* This is a Stripped-down version of partstaff() for transpose only! */sexy transtaff(prt, lownote, hilo)     /* add transposing data later */  sexy  prt;       /* INput; rest are OUTputs: */  sexy  *lownote;   /* clef.bnote */  sexy  *hilo;      /* indicators */{     sexy      istaff;     Reg PART  *ptptr;     if((prt < 1) || (prt > nparts)) {          prt = nparts;      }     ptptr = parts + prt;     *hilo = ptptr->philo;     istaff = ptptr -> pstaff;     *lownote = clefs[(staves + istaff) ->clef_no] . bnote;/* Later get transposing-instrument clef goodies */     return(istaff);} /* transtaff() */#endif/* Semi-main function to transpose all the notes between the given indices*  from the given keysig up/down by the given number of semitones.*  May find another way to specify old & new keys later.*/void dotransp(stind, endind, sourceks, semis, zap)  Index   stind, endind;  sexy    sourceks, semis;  bool    zap;      /* 1st event is a KS to update */{     sexy srcarray[7], trgarray[7];     char *prefer = "\007 Do you prefer 6 Flats to 6 Sharps?";     sexy diatoff;     sexy chromoff;     sexy sourcelet, targlet; /* 0 - 6 Keys, not notes */     sexy oldlet, newlet;     /* 0 - 6 Notes, not keys */     sexy targks;     sexy sharpoff;     sexy oldslot, newslot, oldpit, newpit;     sexy staffno, botnote, hilo;     Reg EVENT *evp;/* 0. Convert semis up/down to keysig change; find new keysig */     sharpoff = sem2sharps(semis);     targks = sourceks + sharpoff;/* Reverse excessive no. of sharps or flats */     if(targks > 6)      /* Too many sharps, go to Flats */          targks -= 12;     if( (targks == 6) && (*pyesno)(prefer) )    /* Borderline */          targks = -6;     else if(targks < -6)          targks += 12;     else if( (targks == -6) && !(*pyesno)(prefer) )          targks = 6;     if(zap) {/* (*palert)("Zapping index, to New keysig: ", -2, stind, targks); */          i2p(stind)->show.KSN = targks;     }/* 1. Get source and target keys into letter-pitmod notation */     sourcelet = key2let(sourceks);     targlet = key2let(targks);/* (*palert)("Old & New White-key Letters:", 2, sourcelet, targlet); *//* 2. Find diatonic offset.  Zero does not mean quit early (E to Eb) */     diatoff = targlet - sourcelet;/* Respect given semis' sense of up or down, regardless */     if( (semis > 0) && (diatoff < 0) )          diatoff += 7;     else if( (semis < 0) && (diatoff > 0) )          diatoff -= 7;/* (*palert)("Diatonic Offset =", -1, diatoff); *//* 3. Prepare the src & target keysig arrays */     ks2array(sourceks, srcarray);     ks2array(targks, trgarray);/* Main Loop -- For each note */     for(evp = i2p(stind); curind <= endind; evp = plusplus()) {          if( (!evp->part) || (evp->show.slot == REST) )               continue;     /* Get Staff data.  Skip if percussion staff */          staffno = transtaff(evp->part, &botnote, &hilo);          if( !botnote || (hilo & PERC) )               continue;/* 4. Move slot by diatonic offset */          oldslot = evp->show.slot;          newslot = oldslot + diatoff;     /* This sucks, but ... */          if(newslot > MAXSLOT)               newslot -= 7;          else if(newslot < MINSLOT)               newslot += 7;          evp->show.slot = newslot;/* 5. If no accidental, leave new pitmod == 0.  Skip to next note */          if( !(oldpit = evp->show.pitmod))               continue;/* 6. Find letter C-B (0-6) of source note and target note */          oldlet = (oldslot + botnote - 1) % 7;          newlet = (newslot + botnote - 1) % 7;/* 7. Re-encode source accidental to -2 thru +2 */          oldpit = "\0\0\x01\x02\0\0\xFE\xFF" [oldpit];/* 8. Find chromatic offset of source note wrt its keysig */          chromoff = oldpit - srcarray[oldlet];/* 9. Add target letter's keysig array value to chromatic offset*     to get new target accidental code. */          newpit = chromoff + trgarray[newlet];/* 10. Convert accidental code back to UME format, insert into note. */          evp->show.pitmod = "\x06\x07\x04\x02\x03" [newpit + 2];     } /* main for() */     } /* dotransp() *//* MAIN PROGRAM watch it grow, verrrry slow-lee *//* Caller must prompt user for semis up/down, since it's too much * work from here with no (*pdialog)() */void transpose(upsemis)       /* really transpose() */  sexy    upsemis;{     Etime     thistime;     Index     lind, rind, thislind, thisrind;     sexy      nextks, oldks;     Reg EVENT *evp;     lind = (Index)pfdat1;    /* just to link in fake data */     (*pfixmarx)(&lind, &rind, &thislind);/* Do by sections, each section terminated by next section's keysig. *//* Find keysig for first section ... *//* first look right till you hit a note, then quit */     patience();     thislind = BADIX;     for(evp = i2p(lind); curind < nevents; evp = plusplus() ) {          if(evp->part) {               break;    /* note, failed */          }          if(evp->show.INCTYPE != KEYSIG)               continue;          thislind = curind;       /* right on old KS event */          oldks = evp->show.KSN;/* (*palert)("Right found KS, at Index: ", -2, oldks, thislind); */          break;         /* Scored! */     }/* second, look left */     if(thislind == BADIX) {          for(evp = i2p(lind); curind >= 0; evp = decdec() ) {               if( (evp->part) || (evp->show.INCTYPE != KEYSIG) )                    continue;               oldks = evp->show.KSN;               thislind = curind;/* (*palert)("Left found KS, at Index: ", -2, oldks, thislind); */               break;          }/* third, punt and use keysig global read in with file */          if(thislind == BADIX) {               oldks = keysig;/* (*palert)("Punted to global keysig =", -1, keysig); */          }     /* In 2nd or 3rd cases,      * overwrite (update) old KS iff found and at same time as start point,      * else enter a new KS at lind's startime. */          if( (thislind == BADIX)            || (i2p(thislind)->startime != i2p(lind)->startime ) ) {               thislind = (*penter)( (*pfulltime)(lind), 0, KEYSIG);               if(thislind == BADIX) {                    (*palert)("\007 Out of memory, no transpose!", 0);                    wkill();  /* patience */                    return;               }/* (*palert)("Inserted new KeySig at Index =", 1, thislind); */               rind++;          }     } /* 1st look right failed *//* Now thislind points to event to put new keysig value into.*  dotransp() computes it and finishes enter()'s overwrite later. *//* Enter main loop for rest of sections */     nextks = oldks;     /* in case no more KSes */     while(thislind < rind) {  /* Find next keysig, and stop before that */          for(evp = i2p(thislind + 1); curind <= rind; evp = plusplus() ) {               if( !evp->part && (evp->show.INCTYPE == KEYSIG) ) {                    nextks = evp->show.KSN;                    break;               }          }          thisrind = curind - 1; /* either rind or just before keysig *//* (*palert)("Ending section at Index =", 1, thisrind); */          dotransp(thislind, thisrind, oldks, upsemis, TRUE);          oldks = nextks;          thislind = thisrind + 1;     }/* Still need to restore last old KS if have ']' not at end *//* Know that thisrind == rind, so thislind = rind + 1 */     thistime = i2p(thislind)->startime;     if( (rind < nevents - 1)       && (thistime != i2p(nevents-1)->startime) ) {/* Unless there is a KS beyond rind with same startime as rind+1, * insert one with same value as last old one == oldks */          for(evp = i2p(thislind); curind < nevents; evp = plusplus() ) {               if( !evp->part && (evp->show.INCTYPE==KEYSIG)) {                    thisrind = curind;                    break;               }          }          if( (curind >= nevents)  /* no more KSes */            || (thistime != i2p(thisrind)->startime) ) {               thisrind = (*penter)( (*pfulltime)(thislind), 0, KEYSIG);               i2p(thisrind)->show.KSN = oldks;          }     }     wkill();  /* patience */} /* main transpose() *//* eof transp.c */