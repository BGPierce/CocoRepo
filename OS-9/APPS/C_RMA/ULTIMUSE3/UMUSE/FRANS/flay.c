/* ~Sw640/FLAY.C  Fran's Graphics Layout (Staves set up) menu */#include <stdio.h>#include "../wmuse.h"#include "../screen.h"#include "../wmenu.h"#include "../vgraf.h"#include "../windows.h"#include "../mencodes.h"#include "../macros.h"/* CAUTION: this type must track same in staves.c!!! */typedef struct {    /* Like CLEF but no clefname string */     ubyte     *fclimg;} FranCLEF;#define Noffset(hilo) ((hilo & UPPER) ? 6 : ((hilo & LOWER) ? -6 : 0))#define GRAY   6    /* maverick bytblt() code */extern STAFF   staves[];extern FranCLEF    clefs[];extern sexy     nparts, nstaves,     keysig, numer, denom;extern unsigned     iclefs[NCLEFS] [CLEFHGT],     imarks[5] [MARKHGT];extern char     *inotes[16],     *glayprs[],     *setuprs[];char i2hexc();/* Clear a full-size screen, but with usual Score borders:*    Menu Bar lines at top (maybe TS, KS, CLEF here)*    Vertical side borders*    Scroll-bar sized bottom** Vertical dashed column markers for the TS, KS, and CLEF areas at left* Column markers for the 16 Parts (both at top and bottom?)** Palettes:*    see below*//* Some Rules:* Dragging is only for moving existing item (like Staff up/down,*   or a part to a different staff.* Pick-up by short click?  NO!* Lay down (including overwrite) by any click (unlike score notes)* Clear Brush by any click in illegal area for current Brush item* Cursor turns into current brush item, even big clefs* Any action that could possibly make sense, does indeed that thing.*//* Draw the background for layout display */void layback(exlay)  bool    exlay;    /* if existing layout adjust, NOT new score */{     char buff[4];     sexy i, xc, y;     int  x;/* Clear screen */     Clear(0, 0, PALXC-1, 191);/* Draw top border */     for(y = SCORTOP + 1; y <= 191; y += 2)          hline(0, 8*(PALXC-2)+8, y, -0x5555);/* Draw side borders */     vpatdyn(0, SCROLTOP+1, 191, 0xAA);/* Draw bottom border */     hline(0, 8*(PALXC-2)+8, SCROLTOP, FORE);/* Vertical markers */     phrase(0, SCROLBOT + 1, "Clef", FALSE);     phrase(0, SCORTOP + 2, "Clef", TRUE);     vline(8*TSCOL+2, SCROLTOP+1, SCORTOP, FORE);     phrase(TSCOL+1, SCROLBOT + 1, "TS", TRUE);     phrase(TSCOL+1, SCORTOP + 2, "TS", TRUE);     phrase(KSCOL+1, SCROLBOT + 1, "KS", TRUE);     phrase(KSCOL+1, SCORTOP + 2, "KS", TRUE);     vline(8*KSCOL+3, SCROLTOP+1, SCORTOP, FORE);     vline(8*PARTCOL+5, SCROLTOP+1, 191, FORE);/* Number all the Part Columns, but draw vertical dividers only*  for those in use.  Terminate 1st unused column with the Big Gray.*/     buff[1] = '\0';     for(i = 1, xc = PARTCOL+1, x = 8*PARTCOL+3; i <= NPARTS;       i++, xc += 3,x += 8*3) {          if(i <= nparts + 1)               vline(x, SCROLTOP+1, 191, FORE);          buff[0] = i2hexc(i);          phrase(xc, SCROLBOT + 1, buff, TRUE);          phrase(xc, SCORTOP + 2, buff, TRUE);     }/* Put gray column after first free part number cloumn */     i = (nparts < NPARTS) ? nparts + 1 : NPARTS;     vpatdyn(PARTCOL + 3 * i, 0, 191, 0x55);} /* layback() */laymenu(exlay)  bool    exlay;{     int  i;     sexy xc;     Clear(PALXC-2, 0, 79, 191);/* ------ Palettes --------- */     winbox(PALXC, 1, 79, 191-1, WSDOUBLE);     bytblt(GRAY, PALXC+1, 1+3, 79-1, 191-1-3);   /* Clear to Gray */     Clear(PALXC+4, 191-9-1, PALXC+3+13, 191-9+5);     /* for phrase */     phrase(PALXC+5, 191-9, exlay ? "LAYOUT MENU" : "SETUP  MENU", TRUE);/**    4 styles of notes (Pitched/Percussion, Flags/Noflags)*    X-out icon for deleting items*    !exlay Pop-up palette for Time Sigs*    !exlay Pop-up palette for Key Sigs*//* Draw palette of Clefs */     /* boxc(CLFPLEFT, CLFPLBOT, CLFPLRGT, CLFPLTOP); */     Clear(CLFPLEFT, CLFPLBOT, CLFPLRGT, CLFPLTOP);     phrase(CLFPLEFT+2, CLFPLTOP-6, "Staff Clefs", FALSE);     for(i = 0, xc = CLFPLEFT+1; i < NCLEFS; i++, xc += 2)           dyna2(xc, CLFPLTOP-6-3, CLEFHGT, iclefs[i]);/* Palette of Part (Note) Types */     Clear(PRTPLEFT, PRTPLBOT, PRTPLRGT, PRTPLTOP);     phrase(PRTPLEFT+1, PRTPLTOP-6, "Voice Parts", FALSE);     for(i = 4, xc = PRTPLEFT+1; i > 0; i--, xc += 3)          put2(xc, PRTPLTOP-6-3, NOTEHGT, inotes[i], FORE);/* Palette of Tools */     /* Xout */     Clear(XOUTLFT, XOUTBOT, XOUTRGT, XOUTTOP+3);     dyna2(XOUTLFT+1, (XOUTBOT+XOUTTOP)/2-7+MARKYOFF, MARKHGT-4, imarks[3]);/* Menu of Buttons -- UpOctave, Tacetize, etc. */     if(exlay)          pbmenu(LAYWINX, LAYWINY, glayprs, LAY_NITEMS, LAY_CWID, TRUE, FALSE);     else          pbmenu(LAYWINX, LAYWINY, setuprs, SET_NITEMS, SET_CWID, TRUE, FALSE);} /* laymenu() *//* MAIN ENTRY FCN -- Plot staves and parts of present layout */showglay(exlay, range)  bool    exlay,    /* if existing layout, not new setup */          range;    /* if note-range bytes follow */{     byte      mins[NPARTS+2], maxes[NPARTS+1];   /* signed */     NOTE      notemp;     int       mx, mn, y;     sexy      p, s, hilow, lownote, x;     layback(exlay);     /* clear & draw background 1st */     for(s = 0; s < nstaves; s++)          y = storf(s, FORE);/* Get range data if needed */     if(range) {          fread(maxes + 1, 1, nparts, stdin);          fread(mins + 1, 1, nparts + 1, stdin);  /* also eats \n */          wcreate(PALXC+3, 191-9+5, 15, 14, TRUE, WSDOUBLE);     }/* Show the Parts on this staff */     notemp.artic = NORMAL;     notemp.slot = 7;    /* anything but a Rest */     notemp.durmod = 0;     notemp.pitmod = 0;/* Pitched notes are 8ths except NOFLAG are Quarters;*    percussion notes are Halves except NOFLAG are Wholes.*  SOLO (Middle) notes have stems both up and down.*  Range-report notes have stems turned inwards. */     for(p = 1; p <= nparts; p++) {          x = PARTCOL-2 + 3 * p;          grafstaff(p, &y, &hilow);          notemp.dur = 4 - ((hilow & NOFLAG) !=0)            - (((hilow & PERC) != 0) << 1);          if(range) {               if(notemp.dur > 3)       /* < quarter? */                    notemp.dur = 3;     /* no messy flags */               mx = maxes[p]; mn = mins[p];               if(mx==REST)                    continue;               drawnr(&notemp, x, y + mx + mx,                 y, mx > 4, FALSE, FORE);               drawnr(&notemp, x, y + mn + mn,                 y, mn >= 4, FALSE, FORE);          }          else {               drawnr(&notemp, x,                 y + Noffset(hilow) + 8, y, ((hilow & LOWER) !=0),                 FALSE, FORE);               if((hilow & (UPPER | LOWER)) == SOLO)                    drawnr(&notemp, x,                      y + Noffset(hilow) + 8, y, TRUE, FALSE, FORE);          }     } /* for p */     drawks(KSCOL+1, keysig);     drawts(TSCOL+1, numer, denom); } /* showglay() *//* Draw a short staff, with barline, clef, and Number.*  Return height of its bottom line.  */sexy storf(s, draw)  sexy    s;   /* staff # 0--nstaves-1 */  sexy    draw;     /*  == FORE to draw */{     sexy      clefnum, y, ty;     Reg ubyte *imgptr;     y = staves[s].staffY;     clefnum = staves[s].clef_no;     imgptr = clefs[clefnum].fclimg;     vline(8*CLEFCOL-1, y, ty = y + 16, draw);     for( ; ty >= y; ty -= 4)          hline(8*CLEFCOL, 8*(PALXC-2)+6, ty, draw);     drawbcd(s + 1, CLEFCOL, y + 8-2);     put2(CLEFCOL+1, y+CLEFYOFF-1, CLEFHGT, imgptr, draw);     return(y);}    /* storf() *//* Integer to extended-Hex char; no hard limit */char i2hexc(i)  short i;{     i &= 31;       /* super-MPARTS */     if(i <= 9)          return(i + '0');     return(i + ('A' - 10));}/* eof flay.c */