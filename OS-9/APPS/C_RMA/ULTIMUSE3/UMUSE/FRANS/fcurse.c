/* file ~/Wm640/FCURSE.C  -9-  Cursor & Menu Graphics routines */#define FCURSE 1    /* to enable cursor-array creation *//* #define ALERT 1     /* for debugging anyway */#include <stdio.h>#include "../wmuse.h"#include "../wmenu.h"#include "../screen.h"#include "../windows.h"#include "../tools.h"#include "../vgraf.h"#include "images.h"#include "../macros.h"/* "cursors.h" is included below, after array declarations */extern NOTE     brush, qrest, qnote;extern direct ubyte     *vdgram;extern char     filename[], pathname[];extern direct sexy     nstaves, nparts, nbars, numer, denom;extern direct bool     tgwmode;extern direct sexy  /* Y's really need int! */     brushx, brushy, tooly, curcurse;extern ubyte     brushsave[];/*extern unsigned     *inotes[], iclefs[][CLEFHGT];*/static direct int     cleft, cright, ctop, cbot, cwid, cheight;static direct unsigned     *curse;/* static unsigned     carrow[5] = { 0xFC00, 0xF000, 0x9C00, 0x0700, 0x0180 };*/#include "../cursors.h"     /* includes cursors[] and curinit() fcn */setcurse(curtype)  sexy    curtype;  /* index into array of cursors */{     register Cursor     *cp;     if((curtype < 0) || (curtype >= NCURSORS))          curtype = CARROW;   /* default */     curcurse = curtype;     cp = cursors + curtype;     cleft = cp->left;     cright = cp->right;     ctop = cp->top;     cbot = cp->bot;     cheight = ctop + cbot + 1;     cwid = cleft + cright + 1;     curse = cp->cimage;}/******************************************************** cursor()    Graphics cursor for ultimuse mouce* Each call either draws or erases the cursor.* Very 1st call should NOT be to erase, else get patch of*   garbage on screen!** Cursor is an arrow, XORed.*  X (in Pixels!) and Y are forced into these limits if need be:*      CLEFT <= x <= 639-CRIT;  CBOT <= y <= 191-CTOP;*/cursor(x, y)  short   x, y;     /* X in Pixels */{    register short  *base;    int             i, xfine;    unsigned        *cb;/* Convert x,y to upper left corner of cursor, & test limits */     if((x -= cleft) < 0)          x = 0;     else if(x > (640 - cwid))          x = 640 - cwid;     if((y += ctop) < (cheight - 1))          y = cheight - 1;     else if(y > 191)          y = 191;/* XOR onto graphics screen */    xfine = (cwid <= 9) ? x & 7 : 0;    /* don't shift "giant" cursors */    base = (int *)(vdgram + ((191 - y) * 80) + (x >>3));    cb = curse;    for(i = cheight; --i >= 0;  base += 40)        *base ^= *cb++ >> xfine;} /* end cursor() *//****** Menu-Drawing Functions, mostly Main ******//* Draw the "ToolBox" Menu/Palette.  Visually-center icons in the center * of their cells, so no rounding is needed of mouse coordinates. * Extended double-decker 90/2/19.  Still needs Full Artic set.*/#define DJ     (8*(TOOLEFT+PALW*DMODS))void drtools(type, triplets)  /* 1st arg, tooly, now global */  sexy    type;     /* For now, 0==NOTE, 1==REST, 2==Message */  bool    triplets; /* may have other interps later */{     /* char buff[81]; */     NOTE notemp;     int  pslot, centery;     int  i, j, tempy;     tempy = 0;     argfix(&tempy, &tooly, SCORTOP);     notemp.durmod = triplets ? 3 : 0;     notemp.pitmod = 0;     notemp.slot = pslot = ((type==1) ? REST : 1);     notemp.artic = NORMAL;     centery = (pslot==REST) ? TOOLHGT/2 : TOOLHGT-NOTEHGT;/* Box in the toolbox */     Clear(TOOLEFT, tooly, TOOLRGHT-1, TOOLTOP);     if(type==2)        /* Open a Window in the note/artic/out area */       /* wcreate(TOOLEFT+1, TOOLTOP-1, 37, 1, FALSE, WSNONE); */          wcreate(TOOLEFT+1, TOOLTOP-1, NRIO*PALW, 2, FALSE, WSNONE);     boxc(TOOLEFT, tooly, TOOLRGHT, TOOLTOP);     for(i=0, j=TOOLEFT; i < NTOOLS; i++, j += PALW)     {          if((type==2) && (i <= NRIO))               continue;/* draw the Notes|Rests palette */          if(i <= NRPE) {               notemp.dur = i;               drawnr(&notemp, 1 + j, centery+tooly, centery+tooly,                 FALSE, FALSE, FORE);          }/* Draw palette of DurMods */          else if(i == DMODS-1) {    /* Boxes and vertical divider lines */               vline(DJ + 0, tooly, TOOLTOP, FORE);            /* vline(DJ + 4*PALWP + PALW2P-10, tooly, TOOLTOP, FORE); */               vline(DJ + 4*PALWP + 5, tooly, TOOLTOP, FORE);               hline(DJ + 0, DJ + 4*PALWP + 5, TOOLHALF, FORE);          }          else if(i == DMODS) {    /* Draw first (Straight) Durmod and 1st (Legator) Artic */               hline(DJ+PALW2P+0, DJ+PALW2P+6,                 TOOLTOP-6, FORE);  /* for Straight */               dyna2(j+1, tooly + 6, ARTHGT, iartics[1]);  /* Legato */          }    /* Draw other 3 durmods and artics: . .. 3 and NIL marcato staccato */          else if(i <= (DMODS + 3) ) {               dyna1(j+1, TOOLTOP-4, DMODHGT, idmods[i-DMODS]);       /* 1-3 */               put2(j+1,tooly + 7, ARTHGT,iartics[i-(DMODS-1)],FORE); /* 2-4 */          }/* Draw palette of Note-vs-Rest, whichever's currently deselected */          else if(i == NRIO) {               tempy = (TOOLHGT+TOOLHGT/2 - NOTEHGT) - centery + tooly;               qrest.dur = 3;               drawnr((pslot==REST) ? &qnote: &qrest,                 j + 1, tempy, tempy, FALSE, FALSE, FORE);               vline(8*(TOOLEFT+PALW*(NRIO+1)) + PALW+4,                 tooly, TOOLTOP, FORE);          }/* Draw palette of Editing Tool Cursors (slots 13 - NTOOLS) */          else {     /* Alternate Brush or Plus, whichever is Out */               tempy = i - (TOOLBOXS-COTB);  /* abuse tempy */               dyna2(j + (PALW/2), TOOLTOP-2, 9,                 icurses[((tempy==CPLUS) && (curcurse==CPLUS))                 ? CBRUSH-4 : tempy]);     /* Lower deck, "power tools" */               dyna2(j + (PALW/2), TOOLHALF-1, 9,                 icurses[i - (TOOLBOXS+4-CNTB)]); /* +4 comps for Artics */          }     } /* for i, j */} /* drtools() */ /* Clear & draw the upper menu bar area (lines & arrows & scrollbar)*  Arrows need that SCROLTOP-SCROLBOT == 8.*/scroll(howmany, start, end)  unsigned     start, end, howmany;{     unsigned  lx, rx, y;    /* left & right edges of bar */     yclear(SCROLBOT+1, SCROLTOP-1, BACK);     box(1, SCROLBOT, 638, SCROLTOP);     hline(3, 637, SCROLBOT, BACK);     vline(LBARP-1, SCROLBOT, SCROLTOP, FORE);     vline(RBARP+1, SCROLBOT, SCROLTOP, FORE);/* Hard-left & -right arrows */     dyna2(1, SCROLTOP-2, 5,       "\xe\x0\x3c\x0\xff\xff\x3c\x0\xe\x0");     dyna2(80-3, SCROLTOP-2, 5,       "\x0\x70\x0\x3c\xff\xff\x0\x3c\x0\x70");     if(howmany) {          lx = LBARP+1 + (short)((((long) start) * SCROLLWP) / howmany);          rx = LBARP+1 + (short)((((long) end  ) * SCROLLWP) / howmany);          for(y = SCROLBOT + 1; y <= SCROLTOP - 2; y++)               hline(lx, rx, y, FORE);     }} /* scroll() *//* Draw the upper Pulldown Menu Bar */char *barlabs[] = {     "FILES",     "LAYOUT",     "OPTION",     "INSTRS",     " MIDI",     "TOOLS",     " GOTO",     "BLOCKS",     " PLAY",     "RANDOM",     ""   /* mandatory terminator */};/* 90/2/13 Improved to print leading blank as background */dmenbar() {     sexy xc, y;     char ch;     int  off;     register char *s;     yclear(SCORTOP + 1, 191, BACK);     for(y = SCORTOP + 1; y <= 191; y += 2)          hline(0, 639, y, -0x5555);/* Draw left & right arrows at ends 90/3/24 */     phrase(0, SCORTOP+2, " <--", TRUE);     phrase(79-3, SCORTOP+2, "--> ", TRUE);/* Type real menu bar labels */     for(xc = MENLEFT, y = 0; ; xc += MENWID, y++) {          if( !(ch = *(s = barlabs[y])) )               break;          off = (ch == ' ');          phrase(xc + off, SCORTOP + 2, s + off, TRUE);     }} /* dmenbar() *//* Draw pretty space-wasting side borders, which clear off Staff ends.*  Can trespass on Scroll Bar; it's drawn later and will win.*/mainbord() {     vpatdyn(0, SCROLTOP+1, SCORTOP, 0xA8);     vpatdyn(79, SCROLTOP+1, SCORTOP, 0x15);}/* Draw the Brush Rep at (brushx, brushy) *//* 90/2/19 changed to take CurCursor, not 'marker', as 2nd arg *//* 96-2-20 always saves bkgnd, bool 'save' param deleted. */void drbrush(nptr, cur)  NOTE    *nptr;    /* usually the brush */  short   cur;{    int  centery;    Get(brushx, brushy, REPRB, REPTOP, brushsave);    Clear(brushx, brushy,  REPRB, REPTOP);/* Show current note/rest size */    if( (cur==CBRUSH) || (cur==CSMASH) || (cur==CPLUS) ) {        centery = (nptr->slot == REST) ? TOOLHGT/2 : TOOLHGT-NOTEHGT;        drawnr(&brush, brushx + 1, brushy + centery, brushy + centery,          FALSE ,FALSE, FORE);    }/* Show a Marker tool, double hgt */    else if((cur >= CLEFTMARK) && (cur <= CIMARK))        dyna2(brushx+1, REPTOP-2, MARKHGT, imarks[cur - CLEFTMARK]);/* Show other tools single hgt, or Artics half-hgt */    else if((cur >= CTIE) && (cur <= CPARTFULL))        dyna2(brushx+1, REPTOP-8, ((cur >= CLEG) && (cur <= CSTAC)) ? 4 : 8,          cursors[cur].cimage);    boxc(brushx, brushy, REPRB, REPTOP);} /* drbrush() */void erbrush()      /* Erase Brush */{     Put(brushx, brushy, REPRB, REPTOP, brushsave);}/** End of Menu Graphics **/void bell() {     fprintf(stderr, "\007\n");}#ifdef ALERT/* Used only for debugging *//* alert()  To print text and number debugging info*    in the midst of graphic work.  Restores text/graphic mode after ENTER.*/#define ALRTWAIT    2    /* flash time in seconds */alert(msg, nargs, n1)   /* PLUS  n2, n3, n4, ..., n7 */  char *msg;   /* MUST be null-terminated; '\n' optional */  short nargs, n1;  /* AND n2, ... n7 */{    register short *sp;     /* Stack Pointer */    char  buff[16];    bool  mode;    wcreate(2, 180, 70, 3, 1, 1);    pat(msg);    nargs &= 7;    for(sp = &n1; nargs; nargs--) {  /* Portable?? */        sprintf(buff, " %d", *sp++);        pat(buff);    }    pat("\n...wait ...");    sleep(ALRTWAIT);    wkill();} /* alert() */#endif/* eof FCURSE.C */