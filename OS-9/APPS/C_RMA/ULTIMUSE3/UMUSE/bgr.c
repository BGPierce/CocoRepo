/*  bgr.c BGRAF.C  -10A-* CoCo-3 Level 2 VDG Grafix package for C UltiMusE.*  NOTE: Uses Y-axis positive UPwards.** 88/07/13  Converted for 1==Foreground, 0==Background* 88/11/07  Converted for Column X's*/#include <stdio.h>#include "wmuse.h"  /* General defns */#include "wcodes.h"#include "macros.h"/* #define PUTGET 0    /* turns on some unused (??) code */extern direct bool  halfstaf;extern direct char    /* format strings for talking thru the pipe */     *pct2, *pct3, *pct4, *pct5, *pct5, *pct6, *pct7, *pctn1;extern direct ubyte     printype,     arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9;/**************** Functions ****************************/#ifdef OLDVDG/* Allocate a "VDG" screen:  640x192x2 = 15,360 bytes. */makevdg() {     printf(pctn1, ALOV);}/* Release VDG graphics page.  Can be re-allocated later. */release() {     printf(pctn1, DALV);}#endiftext() {     printf(pctn1, HIDV);}/* Clear entire VDG screen to back(0) or fore(1) */pcls(keler)  int keler; {     printf(pct2, CLA, keler);}/* Palette color-changer -- even works on VDG screens */pal(slot, rgb)  byte    slot,     /* 0 or 1 are all we care about */          rgb;      /* 00 -- 63 color code, may be Composite too */{     printf(pct3, PAL, slot & 15, rgb & 63);     fflush(stdout);     /* was flush(); */}/* Draw a horizontal line of color c==1 (Fore) or c==0 (Back) *//* Non-Boolean c's give interesting (!) gray-pattern results. */hline(x1, x2, y, c)  int     x1, x2;  sexy    y, c;{     if(y < 0) y = 0;     printf(pct7, HLIN, *((char *)&x1), x1, *((char *)&x2), x2, y, c);}/* Draw vertical line */vline(x, y1, y2, c)  int     x;  sexy    y1, y2, c;{/*   printf(pct6, VLIN, *((char *)&x), x, y1, y2, c); */     arg0 = VLIN;     arg1 = *((char *) &x);     arg2 = x;     arg3 = y1;     arg4 = y2;     arg5 = c;     nfwrite(6);}/****** Data-structure updaters *****/dfstaff(st, clefnum, y)  sexy    st, clefnum, y;{     printf(pct4, DEFS, st, clefnum, y);}fgstaff(st)  sexy    st;{     printf(pct2, UDFS, st);}dfpart(p, s, hilo, noflags, norests, maxchord)  sexy    p, s, hilo, maxchord;  bool    noflags, norests;{     printf(pct7, DEFP, p, s, hilo, noflags, norests, maxchord);}fgpart(p)  sexy    p;{     printf(pct2, UDFP, p);}/* Draw a simple rectangular box.  Can't erase, just draw */box(xc1, y1, xc2, y2)  sexy    xc1, y1, xc2, y2;{     printf(pct5, BOX, xc1, y1, xc2, y2);     flush();}/* BYTBLT() series of rectangle Blit functions * to move the given rectangle to/from a  byte array 'where[].' * Usually called as more mnemonic macros. * Assumes that where[] is big enuf to hold it all! * Code has been optimized to hell and gone.*/bytblt(what, xc1, y1,  xc2, y2,  where)  sexy what;  /* 0=Get, 1=DynaPut, 2=Clear, 4=Blacken, 3=Invert, 5=OrPut */  sexy xc1, y1, xc2, y2;  sexy where; /* ArrayID, unused on Clear & Blacken */{     int n, color = 1;       /* Foreground */     if(y1 < 0)     y1 = 0;     if(y2 < 0)     y2 = 0;     arg1 = xc1;     arg2 = y1;     arg3 = xc2;     arg4 = y2;/* Choose which way to move what */     switch(what) {#ifdef PUTGET     case 0:   /* GET existing picture into a save array *//*        printf(pct6, GET, xc1, y1, xc2, y2, where); */          arg0 = GET;          arg5 = where;          n = 6;          break;     case 1:   /* PUT-Dynamite save-array onto graphics screen *//*        printf(pct7, PUT, xc1, y1, xc2, y2, where, DYNA); */          arg0 = PUT;          arg5 = where;          arg6 = dyna;          n = 7;          break;#endif     case 2:   /* CLEAR area to all-Background */          color = 0;     case 4:   /* PAINT to Foreground  *//*        printf(pct6, CLR, xc1, y1, xc2, y2, color); */          arg0 = CLR;          arg5 = color;          n = 6;          break;     case 3:   /* INVERT area *//*        printf(pct5, NBOX, xc1, y1, xc2, y2); */          arg0 = NBOX;          n = 5;          break;#ifdef PUTGET     case 5:   /* PUT-OR save-array onto graphics screen */          printf(pct7, PUT, xc1, y1, xc2, y2, where, DRAW);          arg0 = PUT;          arg5 = where;          arg6 = DRAW;          n = 7;          break;#endif      default:          /* alert("\007***Illegal BytBlt Code", 1, what); */          return;     } /* switch */     nfwrite(n);     flush();} /* bytblt() *//* Clear entire width of screen between two Y limits to given color. *//* New version ignores color, since Fran does already! 89/9/30 */yclear(y1, y2, paint)  short y1, y2, paint;{     Clear(0, y1, 79, y2, paint);  /* still send paint arg */} /* yclear() *//************************* Draw a 5-line staff whose bottom left corner   is at x,y.  Include left bar iff left==TRUE.   No Clef or right barline.*/staff(y, left, clef)     /* DIFFERENT from Umuse1/2 */  short y, clef;  bool left;{     if(y < 0) y = 0;/*   printf(pct4, DRS, y, left, clef); */     arg0 = DRS;     arg1 = y;     arg2 = left;     arg3 = clef;     arg4 = halfstaf;     nfwrite(5);     flush();}/* Abort-by-user cannot be made to work thru pipeline 89/5/15 */dump() {     char c;     if(yesno("Printer Ready?")) {          if(!printype) {     /* must have nonzero model Printer */               printset();               wkill();       /* for printset */               if(!printype)                    return;          }          printf("%c%c\n", DUMP, printype);/*        read(0, &c, 1);       /* just to hang Bill till user hits a key *//*        flush();              /* this can abort print */     }}/********** Text-printing fcns **********//* Type one phrase line of newline-term'ed text at given X, Y.*  Y is of ruler line; descenders go one below that;*    letters go from 4 above it.  Clears a line above that.*  If 'caps' is True, the line above and descender line are omitted.*/phrase(x, y, s, caps)  sexy    x, y;  char    *s;  bool    caps;     /* Capital letters only, for Menu Bar */{     printf("%c%c%c%c%s\n", PHRS, x, y, caps, s);} /* phrase() *//* End of grafix fcn bodies */#ifdef LOWLEVELS/* Compound vertical line(s) using given pattern instead of*    3:8 decode of x_fine.  Only coarse X is used.  Dynamites.*/vpatdyn(x, y1, y2, pat)  short   x, y1, y2;  ubyte   pat;      /* 8-bit pattern */{/* later */}/* New PUT fcns to draw objects that are one or two bytes wide;*  object image must be arrayed from Top Down.*/put1(x, y, h, what, draw)     /* one-byte wide */  short   x,   /* X in PIXELs, 0~640 */          y,   /* TOP's location */          h;   /* # lines of height */  byte    what;    /* the image to put */  bool    draw;     /* FALSE to erase */{later;}put2(xc, y, h, what, draw)     /* two-bytes wide */  short   xc,  /* X in PIXELS, 0~639*/          y,   /* TOP's location */          h;   /* # lines of height */  short  *what;     /* the image to put */  bool    draw;     /* actually assumes BACK==F, FORE==TRUE */{later;}/****** "Dynamite" Putters that use Overwrite logic and can't erase.*  Used for drawing digits and other small items that need*    to blast-out the area around themselves.*/dyna1(x, y, h, what)     /* one-byte wide */  short   x,   /* X in PIXELs, 0~640 */          y,   /* TOP's location */          h;   /* # lines of height */  byte    *what;    /* the image to put */{later;}dyna2(xc, y, h, what)     /* two-bytes wide */  short   xc,          y,          h,          *what;    /* the 2-byte image to put */{later;}dyna3(xc, y, h, what)     /* three-bytes wide */  short   xc,          y,          h;  ubyte   *what;    /* the 2-byte image to put */{later;}#endif    /* LOWLEVELS *//* eof ~Vm640/graf.c */