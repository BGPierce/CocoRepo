/* BARMENU.C  97/01/16  Fragged-out Barline Menu *//* acquired barinit() 98/4/3 */#define FRAG 1#include <stdio.h>#include "wmuse.h"#include "mencodes.h"#include "cursors.h"#include "windows.h"#include "vmem.h"#include "fcnptrs.h"#include "macros.h"extern direct Index    undind, lftind, gbarind, gind, xgoal;extern direct short     xgoal, numer, denom, nbars;extern direct bool     rfr_scr, tripper;extern EVENT     undevent, zevent;extern direct Time    length;extern direct sexy     nparts, dencodur,     curcurse;extern direct Etime dendur;extern char     *vols, filename[], pfdat1[];extern NOTE    qnote, qrest;extern PART    parts[NPARTS+1];bool evtenter(), barmenu();sexy hexc2i();/* Menu called by clicking BRUSH/PLUS cursor on a Barline or Inclusion.*   (Use expr brush ^ to insert other things)* It upgrades barlines to fancier types, or inserts* items that can occur only next to barlines.* All choices return directly, no recycling except on errors.*/bool barmenu(ind)   /* TRUE if anything gets done */  Index   ind;    /* of Barline or other Inclusion */{     char      buff[BUFFSIZE];     short     num;     bool      barinsrt;    /* if another Barline is to be added */     char      cm, c1;     sexy      btype /* , otype */ ;     Reg EVENT *evptr;    evptr = i2p(ind);/*  otype = evptr->show.INCTYPE; */     for( ; ; ) {          prmenu(MEN_BAR, NULL);          cm = (*ptextmen)(BAR_LCOL, BAR_TOPY, BAR_CWID, 1, 1, 16, TRUE);          wkill();          if(cm < 0)               c1 = -cm;          else               c1 = "\n12():nf  /kd$csl" [cm];          (*pputchar)(c1);          barinsrt = FALSE;          switch(c1) {          case '\n':               /* wkill(); */               return(FALSE);          case '1':               btype = SINGLEBAR;               break;          case '2':               btype = DOUBLEBAR;               break;          case 'f':               btype = FINE;               break;          case '(':               btype = BEGREPEAT;               break;          case ')':               btype = ENDREPEAT;               break;          case ':':       /* Replacement for old DUBREPEAT */               evptr->show.INCTYPE = BEGREPEAT;     /* will be 2nd item */               btype = ENDREPEAT;  /* to be 1st item and inherit Barno */               barinsrt = TRUE;       /* Put both a :|| and a ||: */               break;          case 'n': /* was 'e' long ago */               *buff = '\0';               if ( !(*pgetempty)(buff, "Ending No. (1, 2, ...): ", FALSE))                    continue;               evptr->show.REPENDN = atoi(buff);               btype = NTHENDING;               break;/* End of Barline types, begin hangers-on */          case '/':   /* Time Sig, after, may already exist */               (*pputchar)('\n');               ind++;               (*pgtsig)();               btype = TIMESIG;               break;          case 'k':   /* key sig, after, may already exist */               ind++;               btype = KEYSIG;               if(cm > 0)     /* clicked */                    num = (*pgksig)();               else {                    (*pgets)(buff);    /* arg given? */                    num = (*buff) ? atoi(buff) : (*pgksig)();               }               break;          case 'd':   /* D (C/S) {Senza Repitizione}, before */               btype = DACAPO + ((*pyesno)("\nDS, not DC?") <<1)                 + (*pyesno)("Skip repeats?");               break;          case '$':   /* segno sign $, after */               btype = SIGN;               ind++;  /* Insert it AFTER barline */               break;          case 'c':   /* coda entry, before */               btype = CODA;               break;          case 's':   /* white space */               btype = SPACE;               break;          case 'l': /* Label, before */               dialogue(FALSE);               (*pprintf)("Type a 1- or 2-char label: ");               (*pgets)(buff);               wkill();               if( ! *buff)                    continue;               btype = LABEL;               c1 = *buff;               cm = *(buff + 1);               break;          default:               bell();               continue;          } /* switch */          break;     } /* for( ; ; ) *//* Do it.  Insert new item if btype != Barline or barinsrt */     if(barinsrt || (btype > FINE)) {          if( !(evptr = (*pmakroom)(ind))) {  /* (covers i2p(ind) ) */               /* alert("**Outa space!", 0); */               /* wkill(); */               return(FALSE);          }     /* Some add-on items need extra parameters */          if(btype == KEYSIG)               evptr->show.KSN = num;          else if(btype == TIMESIG) {               evptr->show.TSNUMER = numer;               evptr->show.TSDENOM = denom;          }          else if(btype == LABEL) {               evptr->show.LCHAR1 = c1;               evptr->show.LCHAR2 = cm;          }     }/* Whether new or old index, patch in the fields */     evptr->part = 0;      /* needed for insert-afters */     evptr->show.INCTYPE = btype;     rfr_scr = TRUE;     /* wkill(); */     return(TRUE);} /*  barmen() */sexy barinit(indx, firstnum, nofbars, stime)  Index   indx;       /* where to start in events[] */  short   firstnum,   /* number to give first bar */          nofbars;    /* how many bars to make, we hope. */  Time    stime;      /* start time of 1st new bar */{    NOTE  notemp;    Index oldnev, trynev;    short bar, part, beat, lastbar, perbar;    Deltime    tdendur;    Reg EVENT  *evptr;/* Insure this many bars will fit; cut nofbars till they will. *//* Pre-test against both NEVENTS and currently available RAM */     (*pfindts)(indx);  /* includes free timesig() */     oldnev = nevents;     perbar = 1 + nparts * (tripper ? ((numer + numer) / 3) : numer);     for(;;) {          if(nofbars <= 0) {   /* Not even one bar! */               (*palert)("No more bars; out of memory!\n", 0);               return(0);          }          trynev = nevents + (nofbars * perbar) + 1;          if((trynev < NEVENTS) && i2p(trynev - 1))    /* OK to do */               break;         /* OK, go do 'em */          nofbars--;          /* Retry one less bar */     }/* Add at least one measure */     nevents = trynev;    /* Covers new plusplus() 89/1015 */     cpynote(&notemp, &qrest);     notemp.artic = NORMAL;   /* Is this really needed? 90/9/16 */     lastbar = firstnum + nofbars - 1;/* Leave old final event as-is IFF it's a barline */     evptr = i2p(indx);     if( (indx == oldnev - 1) &&       ( (evptr->part) || (evptr->show.INCTYPE > FINE) )) {          evptr = plusplus();      /* don't clobber */          indx = curind;           /* push indx past it */     }     if(tripper) {  /* 6/8, 9/8, 12/8, etc. */          notemp.dur = dencodur - 1;   /* double its size */          notemp.durmod = 1;      /* plus a Dot */          tdendur = 3 * dendur;     }     else {          notemp.dur = dencodur;          tdendur = dendur;     }     for(bar = firstnum; bar <= lastbar; bar++, indx++) {          evptr->part = 0;    /* DEFINES an "inclusion" */          if(indx != oldnev - 1)    /* leave old last bar */               evptr->show.INCTYPE = SINGLEBAR;          evptr->startime = (Etime) stime;          EvBarNo(evptr) = bar; /* Count from 1, not 0 */          evptr = plusplus();          for(beat = 1; beat <= numer; beat++) {               if(tripper && ((beat % 3) != 1) )                    continue;               for(part = 1;                 (part <= nparts) && (curind < NEVENTS); part++)               {               /* Don't fill plus-parts */                    if( !(parts[part].philo & NOFLAG)) {    /* 96-2-18 */                         cpynote(&evptr->show, &notemp);                         evptr->startime = (Etime) stime;                         evptr->part = part;                         evptr = plusplus();                    }               } /* parts */               stime += (Time) tdendur;          } /* beats */     } /* bar */ /* Final barline, only one if 0 nofbars requested. */    evptr->part = 0;    evptr->show.INCTYPE = SINGLEBAR;    evptr->startime = (Etime) stime;    EvBarNo(evptr) = bar;   /* ==lastbar + 1 *//* Following updates assume new bars are appended at end */    nevents = curind + 1;     /* Fine-tune, 1 for last barline */    length = stime;           /* does/shud NOT include final barline's dur */    nbars = lastbar;          /* was lastbar - 1  89/10/15 */    return(nofbars);          /* any success? */} /* barinit() *//* eof barmenu.c */