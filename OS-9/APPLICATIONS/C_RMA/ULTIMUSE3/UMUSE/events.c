/* EVENTS.C  from 91/9/15  Enter, edit, and store MIDI Events *//* Note: "Instant" is user's term for events typed right into score,*    or so it seems.  Long events may be invisibly*    strung off into a new memory array (not a "table").*  If so, it's called "outline."*  Instant events of <=3 (if Partwise) or <=4 (System) bytes are "inline"*    and stored in score object.*  Inlines are tagged with "minus" sign set in 0th byte.*  Partwise Inlines minus-tag the last byte (ANDed out before xmsn);*  System Inlines store (bytecount-1) in Byte0 upper nybble, << 1.*  Partwise events now store their Part in PARTNO field like other expressors.*  This part's Channel is substituted into low nyble of 1st byte.*  Outline Partwise strings will have Part's Channel substituted into low*    nybble of any byte whose Bit 7 is set (Status) and low nybble == 0.*/#include "wmuse.h"#include "vmem.h"#include "wcodes.h"#include "fcnptrs.h"#include "windows.h"#define UNIQUE /* Don't store duplicate strings 97/2/23 */extern char    pfdat1[]; /* dummy printf() data */extern bool    rfr_scr;extern EVENT   zevent;extern ubyte     *evtarray,     /* actually a pointer to base of malloc'ed */     *evtartop,     /* to last malloc'ed byte */     *evtarnxt;     /* to next (1st unused) byte *//* format strings for talking thru the pipe */extern direct char    *pct2, *pct3, *pct4, *pct5, *pct5, *pct6, *pct7,    *pctn1, *pctn2, *pctn3, *pctn4;bool evtenter(), barmenu(), instio();    /* pre-decs... */void reorder(), renumber();/* "Main()" Soowee dispatcher fcn */int main(what, arg1, arg2, nofbars, stime)    /* usually bool */  char    what;     /* selector */  int     arg1;     /* evtenter=clind; reorder=staf */  int     arg2;     /* reorder=cloneback, barinit=firstnum */  int     nofbars;  /* barinit */  Time    stime;    /* LONG, for barinit() */{     switch(what) {          case 'e': return(evtenter(arg1));          case 'o': return(reorder(arg1, arg2), TRUE);          case 'n': return(renumber(), TRUE);          case 'b': return(barmenu(arg1));          case 'i': return(instio(arg1, arg2));          case 'B': return(barinit(arg1, arg2, nofbars, stime));   /* int */     }     return(0);     /* ryecatcher */} /* main()  *//****** Function set to initialize and maintain the "outline" event array *//* ievtinit(cnt) is in bv.c */#ifdef UNIQUE/* Compare two byte arrays' 1st N bytes, ignoring NULL bytes *//* Return TRUE or FALSE, not -1, -, +1 */bytncmp(s1, s2, n)  ubyte   *s1, *s2;  int     n;{     Reg int   i;     for(i = n; --i >=0; )          if(*s1++ != *s2++)               return(FALSE);     return(TRUE);} /* bytncmp() */#endif/* Load bytes from external buffer.  Return offset. *//* Swaps in and out */int ievtload(from, cuenta)  ubyte   *from;  int     cuenta;{     int   remain, curinuse, i, lim;     Reg ubyte *bp;     if((cuenta <= 0) || (cuenta > 255))          return(0);     evtarray = (*pswapevts)(TRUE);     curinuse = evtarnxt - evtarray;  /* also the start offset for new entry */     remain = EVTARSIZ - curinuse;#ifdef UNIQUE/* Look for identical string already */     lim = curinuse - cuenta;      /* how many comparisons */     for(i = 0, bp = evtarray;  i < lim;  i++, bp++)          if(bytncmp(bp, from, cuenta))               break;     if(i < lim) {  /* Found a match */          (*pswapevts)(FALSE);          return(i);     /* No copy to store needed! */     }#endif     if(cuenta > remain) {          (*palert)("***Events out of room!", 0);          return(0);     }     for( ; cuenta > 0; cuenta--)          *evtarnxt++ = *from++;     (*pswapevts)(FALSE);     return(curinuse);     /* starting offset of this load */} /* ievtload() *//* return play-out read Pointer to one event, given offset & cuenta.*  Does not ouput any MIDI bytes, poorly named. *//* Swaps in but not out */ubyte *ievtplay(offset, cuenta)  int     offset;  int     cuenta;{     ubyte     *ubp;     cuenta &= 255;     evtarray = (*pswapevts)(TRUE);     ubp = evtarray + offset;     if((ubp + cuenta) > evtarnxt)         /* ain't got that many to give */          return(NULL);     return(ubp);} /* ievtplay() *//* Return no. of bytes currently in use; for diskio writes *//* ievtused() is now in diskio.c group *//* Print-display any NON-TABLE type of Event, in window already open *//* Swaps in and out  -- ievtplay() does the swap-in */void printevt(evp)  Reg EVENT     *evp; {     ubyte     bytemp;     ubyte     *ubp;     int       cnt;     char      *z2xs = "%02X ";     bytemp = evp->show.IEVTBYT0;      if(evp->show.INCTYPE == IPEVT) {     /* Partwise (Channel) event */          (*pprintf)("Instant ");     /* not Table */          (*pprintf)("on Part %d: ", evp->show.PARTNO);          if((char)bytemp < 0) {     /* InLine if Bit 7 set */               (*pprintf)("%02X %02X", evp->show.IEVTBYT0 & 255,                 evp->show.IEVTBYT1 & 127);               if((char)(evp->show.IEVTBYT1) >= 0)                    (*pprintf)(" %02X", evp->show.IEVTBYT2 & 127);          } /* partwise inline */          else {         /* Partwise Outline */               cnt = evp->show.IEVTBYT2 & 255;               ubp = ievtplay( *((short *)(&evp->show.IEVTBYT0)), cnt);               if( !ubp)                    return;               for( ; --cnt >= 0; )                    (*pprintf)(z2xs, *ubp++ & 255);               (*pswapevts)(FALSE);          }          (*pprintf)("\n");     }     else if(evp->show.INCTYPE == ISEVT) {     /* System (Fx) */          (*pprintf)("Instant System: ");          if((char)bytemp < 0) {     /* Inline -- same as Partwise flag */               (*pprintf)(z2xs, (bytemp | 0xF0) & 255);               if(bytemp &= 0x60) {     /* yes, '=' */                    (*pprintf)( z2xs, evp->show.IEVTBYT1 & 255);                    if(bytemp & 0x40) {                         (*pprintf)( z2xs, evp->show.IEVTBYT2 & 255);                         if(bytemp & 0x20) {                              (*pprintf)( z2xs, evp->show.IEVTBYT3 & 255);                         }                    }               }          }     /* Outline System -- same as for Partwise */          else {               cnt = evp->show.IEVTBYT2 & 255;               ubp = ievtplay( *((short *)(&evp->show.IEVTBYT0)), cnt);               if( !ubp)                    return;               for( ; --cnt >= 0; )                    (*pprintf)( z2xs, *ubp++ & 255);               (*pswapevts)(FALSE);          }          (*pprintf)("\n");     } /* Instant System */     else if( (evp->show.INCTYPE == TPEVT) || (evp->show.INCTYPE==TSEVT) )     {     /* Table event */          (*pprintf)( "Table, not yet.\n");     } /* end Table event */     else          (*pprintf)( "Type %d, Not an Event.\n", evp->show.INCTYPE);} /* printevt() *//* Fcn called by a Menu to enter an Event;*   returns TRUE iff an event gets changed or entered;*   caller uses return to refresh score screen.*/bool evtenter(clind, cloneback)  Index   clind;    /* clicked-on index */{     char      buff[256 * 3];     ubyte     bytes[256];     EVENT     evtemp;     Index     newind;     bool      partwise, inline;     int       clpart, eventype;     int       howmny, properno;     ubyte     temp;     ubyte     *ubp;     Reg EVENT *evp;          ubp = pfdat1;  /* just to get it linked */     strevent(&evtemp, &zevent);     /* clear */     evp = i2p(clind);     temp = evp->show.INCTYPE;     /* in case not note/rest */     newind = -1;/* If clicked on an Event (either type), ask whether Overwrite */     if( !evp->part && (temp >= IPEVT) && (temp <= TSEVT)) {          dialogue(TRUE);          (*pprintf)("You hit Event: ");          printevt(evp);/* Menu this someday, tho user needs keyboard anyhow */          (*pprintf)("\ntype Insert before, Add after, Replace,\n");          (*pprintf)(" or ENTER if just looking: ");          (*pcharmaus)(buff);          wkill();          if(*buff == 'r')               newind = clind;          else if(*buff == 'i')               newind == clind - 1;          else if(*buff == 'a')               newind == clind + 1;          else               return(FALSE);     }/* If on Note or Partwise Expression, save Part Num, as 1--16 */     if(evp->part)          clpart = evp->part;     else if( (temp==INSTR) || (temp==LEVEL) || (temp==MCHOP)       || (temp==IPEVT) || (temp==TPEVT) )          clpart = evp->show.PARTNO;     else          clpart = 0;         /* code for no part ==> System event *//* If an arg was typed (eg, "e3"), know it's Table.*  And if clpart >0, know it's Partwise.*  Otherwise prompt for Table Slot; take ENTER as Instant. *//* BUT FOR NOW, JUST PUNT Table Events! *//* Later, Ask whether Instant or Table *//* Instant: *//* Collect Bytes */     dialogue(TRUE);         /* Stays open throughout processing */     (*pprintf)("Type Hex bytes (1 or 2 digits each), separated by blanks:\n");     (*pgets)(buff);/* Compile (from ASCII to Hex) */     if( !*buff || !(howmny = compinst(buff, bytes, 255))) {          wkill();          return(FALSE);     /* nothing there, bail */     }/* Audit, warn of violations, fix *//* Store, fudging 1st Byte for Part No. if any, set hi bit re Partwise */     temp = bytes[0];     if( !(temp & 0x80)) {          (*pprintf)("First byte must be between Hex 80 and FF;\n");          (*pprintf)( " changing your %02X to %02X.\n",            temp, (temp | 0x80) & 255);          *bytes |= 0x80;          (*phit)();     }/* Is this Partwise? */     partwise = ((temp & 0x70) != 0x70);     eventype = ISEVT;     if(partwise) {          eventype = IPEVT;          if( !clpart) {               (*palert)     ("No; Partwise Event must go on Note, Rest, Partwise\n expression, or another Partwise Event.", 0);               wkill();               return(FALSE);          }          evtemp.show.PARTNO = clpart;     }     inline = (partwise && (howmny <= 3)) || ( (!partwise) && (howmny <= 4));/* Override howmny based on knowledge of MIDI, iff Inline */     if(inline)     {          temp &= 0x7F;          properno = howmny;          if(partwise) {                    if((temp >= 0x40) && (temp <= 0x5F))                    properno = 2;     /* C & D: common aftertouch & instr change */               else                    properno = 3;          }          else {              /* Fx */               switch(temp & 0xF) {               case 1:               case 2: properno = 3;     break;               case 3: properno = 2;     break;          /* Undefined F codes (later build in Alejandro codes) */               case 4:               case 5:               case 9:               case 13:properno = howmny;     /* Leave as-is */                         break;     /* All others take no extra args */               default:     /* meaning  6, 7, 8, 10, 11, 12, 14, 15 */                    properno = 1;               } /* switch */          }          if(properno < howmny) {               (*pprintf)("Extra bytes ignored.\n");               (*phit)();               howmny = properno;          }     /* If not enuf, don't adjust howmny (in case Table follows) */          if(properno > howmny) {               (*pprintf)(                 "\nNot enough data bytes;\n better re-do this Event.\n");               (*phit)();          }/* (Still in if(inline) ) *//* Load the score object */          howmny--;          if(partwise)    /* set Inline bit */               evtemp.show.IEVTBYT0 = (*bytes & 0xF0) | 0x80;          else               evtemp.show.IEVTBYT0 = (*bytes & 0x0F) | 0x80 | (howmny << 5);/* Load up to three more bytes */          for(ubp = bytes+1, temp = 1; temp <= howmny; temp++, ubp++) {               if(partwise) {                    if(*ubp & 0x80) {                         (*pprintf)("\fAll but first byte mustn't exceed $7F;\n");                         (*pprintf)( " changed your %02X to %02X.\n",                           *ubp & 255, *ubp & 0x7F);                         *ubp &= 0x7F;  /* maybe undone below, but need warning */                    }                    if(temp == howmny)                         *ubp |= 0x80;     /* Flag final Partwise byte */               }               if(temp==1)     evtemp.show.IEVTBYT1 = *ubp;               if(temp==2)     evtemp.show.IEVTBYT2 = *ubp;               if(temp==3)     evtemp.show.IEVTBYT3 = *ubp;          }     } /* if(inline) */     else {     /* OutLine *//* Load bytes into permanent array */          properno = ievtload(bytes, howmny);/* ASSUME above swapped score back in! *//* Set btye fields in object */          evtemp.show.IEVTBYT2 = howmny;          *((short *)(&evtemp.show.IEVTBYT0)) = properno & 0x7FFF;     } /* outline *//* At last, insert new goodie BEFORE, AFTER, or ON clicked item */     wkill();     evtemp.part = 0;     evtemp.show.INCTYPE = eventype;     evtemp.startime = evp->startime;     if(newind < 0)     /* Not next to or over an old event */          clind = (*penter)((*pfulltime)(clind), 0, eventype);     else if(newind < clind)         /* must be clind - 1 */          (*pmakroom)(clind);     else if(newind > clind)         /* must be clind + 1 */          (*pmakroom)(++clind);/* Below also covers overwrite case newind == clind. */     strevent(i2p(clind), &evtemp);/* Temp. checkout code */     dialogue(TRUE);     printevt(i2p(clind));     (*phit)();     wkill();     return(TRUE);} /* evtenter() */#ifdef TABLEVENTS     else {/* Table: */     /* Get Table Entry Num (like Instr) */     /* Prompt for Args 1 thru 3, after zeroing */     /* Store above, plus Part or else Arg #0 -- if Arg0 & 128,     *    it is taken not as Part but as value & 127. */     }#endif/* Translate an ASCII buffer of nybble-pairs into binary byte array;*    return how many you converted.* NOTE: Overwrites buff if any non-Hex char in it besides spaces!*/int compinst(buff, bytes, limit)  char    *buff;  ubyte   *bytes;  int     limit;{     int        count, acc, nyb;     char       *cp;     Reg ubyte  *bp;     for(bp = bytes + limit; bp >= bytes; )          * --bp = 0;     acc = -1;     /* meaning fresh virgin */     for(count = 0, cp = buff, bp = bytes; ; cp++) {          if( !*cp || (*cp==' ') || (*cp=='\n') || (*cp=='\t')) {               if(acc >= 0) {                    *bp++ = acc;                    acc = -1;                    count++;               }               if( !*cp || (count >= limit))                    return(count);               continue;          }          nyb = c2hex(*cp);          if(nyb < 0) {               (*psprintf)(buff, "\007Non-Hex Char '%c'; ignored all after.",                 *cp);               (*palert)(buff, 0);               return(count);          }          if(acc < 0)               acc = nyb;          else               acc = (acc <<4) + nyb;     } /* for */} /* compinst() *//* Char to hex-nybble converter.  Small letters only!*  Returns negative value if invalid char; faster that way.*  Not rated for 8-bit (ALT key) chars!*/int c2hex(ch)  Reg char     ch;{     if( (ch -= '0') <= 9)          return(ch);         /* may be valid or negative */     if( (ch -= ('a' - '0')) < 0)          return(ch);         /* invalid for sure */     if(ch <= 5)          return(ch + 10);/* valid for sure */}/***** Submenu to edit the Event Table ***/evtabmen() {     ;} /* evtabmen() *//*** Close window ***/wkill() {     (*pprintf)(pctn1, OWEN);}void dialogue(big)    /* Open a small Double window */  bool    big;{     wcreate(14, 110, 50, big ? 5 : 2, TRUE, WSDOUBLE);}/*** Open a Pat & Vanna overlay window ***/wcreate(leftcol, topy, colswide, rowshigh, dosave, style)  sexy    leftcol, topy, colswide, rowshigh, style;  bool    dosave;{     (*pprintf)(pct7, OWST, leftcol, topy, colswide, rowshigh, dosave, style);     (*pflush)();}bell() {  /* putc(7, stderr)  Known to work! */     char c;     c = 7;     write(2, &c, 1);}/*** Put up a stock menu *//* DO NOT take out the trailing '\n' w/out changing Fran's end */void menu(code)  sexy    code;{     (*pprintf)(pctn2, MENU, code);  /* no extra bytes, in case of menu args */}/* Fcn to print a menu plus "Choice:" and collect prompted response.*  Note: ENTER returns '\n', not '\0'.*  87/8/29 reads ONE char w/out ENTER; caller must get any more.*  88/1/2  no longer clears screen unless your 1st string has a ^L.*  89/10/13 Mouse click serves as an ENTER for default out of menus.*/prmenu(code, answer)  sexy    code;  char    *answer;  /* set to NULL to skip reading response */{     menu(code);     waitmouse();     (*pprintf)("  Choice: ");     alcurset(TRUE);     if(answer)          (*pcharmaus)(answer);}void alcurset(onoff)  bool    onoff;{     (*pprintf)(pctn2, ACUR, onoff);}/* Wait for mouse to be released.  No-op if not being held. */void waitmouse() {     int     x, y;     while((*pmouce)(&x, &y) != 0)          tsleep(4);     /* meaning 3 ticks */}/* EOF events.c */