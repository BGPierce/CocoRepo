/* file ~VM640/DISKIO.C   -13-    Disk I/O.98/3/14   DIR lets user click a file to CHD97/2/20   Extended Instrs and Titles.  Many subrs now in disksubs.c,            and instio.c is in Um3E.90/5/15+  This part fragged out90/3/17   Extensive rebuild for side info files (i, p, m, l)89/01/26  User can omit .ume and .ins in file names.*/#define WHERETO     1   /* Enable protection against larger scores */#define LISTLINES   24  /* max # lines of song titles allowed */#define NRECORDS    (3*LISTLINES)#define FRANRECS    42   /* Beyond which Fran can't save under window */#define LOOKLCOL    (77-52-5)#define LOOKTOP     (191-1)   /* was 191-7 */#define NAMELEN     24   /* was 25, but 24 fits in OSK names */#include <modes.h>#include "wmuse.h"#include "size.h"#include "wmenu.h"#include "mencodes.h"#include "windows.h"#include "cursors.h"#include "version.h"#include "vmem.h"#include "fcnptrs.h"#define FRAG 1      /* needed for soowee.h */#include "soowee.h"#include "macros.h"#include "wcodes.h"#include "titles.h"extern char pfdat1[];    /* to pull in d349 fakers */extern long    lseek();extern STAFF staves[NSTAVES];extern PART  parts[NPARTS + 1]; /* Parts are ORG 1, not 0! */extern short   instvals[NINSTRS];extern char    instnams[NINSTRS] [10],               filename[SFILENAME],               percsynth[24];extern ubyte   chans[NPARTS + 1],               levels[NLEVELS],               percmids[17];extern direct short    nparts, nstaves, scorelvl,    xgoal, nbars, nzones;extern direct Index     lftind, ritind, gind;extern direct sexy    curcurse, numer, denom, keysig, secmin, transp;extern direct Time    length;extern direct bool    scrclock, readonly, rfr_scr, rfr_tit, rfr_bar;extern ubyte     *evtarray, *evtartop, *evtarnxt;extern int read(), write(), strcmp();bool       diskio(), instio(), extest();char       *extent();/* Read directory and save all ".ext" filenames (up to NRECORDS)*    in given string array.*  Return count of how many found.*/int  diread(fnames, ext, invert)  char    *fnames,  /* MUST BE >= 26 * NRECORDS; caller's job! */          *ext;     /* R/O; includes '.' and must be all lowercase */  bool    invert;   /* If TRUE, then all files W/OUT the .ext */{     extern int errno;     char      buff[32],               name[30];      /* 29 chars plus \0 */     int       count, chan;     Reg char  *cp;     chan = open(".", 0x81);  /* 80==Dir, 1==Read only */     if(chan < 3) {          (*palert)("Can't open Dir, Error #", 1, errno);          return(0);     }     if( !invert)   /* Blow off .. and . */          skipread(chan, 64);/* Now the file entries */     for(count = 0; ; ) {          if( ( read(chan, buff, 32)) < 32)      /* probly EOF */               break;          if(!*buff)     /* old deleted entry */               continue;/* Copy filename and convert from OS9 to C format */          strhcpy(name, buff);/* Save filename iff it ends in .ext */          if( !(extest(name, ext) ^ invert) )               continue;          if( !invert)               *(name + strlen(name) - 4) = '\0';   /* delete .ext */     /*   if( !*name)    continue;      /* No null basenames! */          *(name + NAMELEN) = '\0';     /* in case no .ext deleted */          strcpy(fnames + (26 * count), name);          if(++count >= NRECORDS)               break;     }     close(chan);/* Not enuf code space for this ...     if(count > 1)          qsort(fnames, count, 26, strcmp);*/     if(count > 1) {     /* Bubble sort, re-use "chan" */          for(chan = count; --chan ; ) {               for(cp = fnames + 26 * (count - 1);  cp > fnames; cp -= 26) {                    if(strcmp(cp - 26, cp) > 0) {                         strcpy(buff, cp - 26);                         strcpy(cp - 26, cp);                         strcpy(cp, buff);                    }               }          }     }     return(count);}/* Show all filenames.EXT and Get a filename selection from user.*  This fcn gets to link in the d349 faker array.* dir == diread(), DIR with change, with wr == Invert option* !wr == Diread(), Quick-click with hand-enter option (Reads)* wr == Diread(), Click copies to window (or type), must click approval* wr && dir == Inverse (all but) DIR* Caller should test for buff empty ==> cancel operation.* Upgraded to 3, not 2, columns 95/3/21 (Happy B-day, J.S)*/fnamenu(buff, ext, wr, dir, del)  char    *buff, *ext;  bool    wr, dir, del;  /* wr && dir ==> Inverse dir */{     char fnames[26 * (NRECORDS+2)];    /* extra large!! */     int  nrecs, nlines, rec;     Reg char  *cp;     cp = pfdat1;/* Phase 1: Do the DIR *.EXT */     for(cp = fnames + 26*NRECORDS-1; cp >= fnames; )          *cp-- = '\0';     if( !(nrecs = diread(fnames, ext, dir && wr)) && dir) {          (*psprintf)(buff, "No %s%s files.\n",            (dir && wr) ? "non-" : "", ext);          (*palert)(buff, 0);          *buff = '\0';          return;     }/* Phase 2: Display the DIR listing *//* Size window to fit nrecs; if small enuf, make it saving */     wcreate(1, LOOKTOP, 78, nlines = 1 + ((nrecs + 2) / 3),       !(rfr_bar = rfr_scr |= (nrecs > FRANRECS)), WSDOUBLE);     (*pputchar)('\f');     for(rec = 0, cp = fnames; rec < nrecs; rec += 3) {          (*pprintf)("%-26s%-26s%-25s\n", cp, cp+26, cp+52);          cp += 78;     }/* Phase 3: Click a name to read/write, with type-in option *//* Following code lets user see selected name before committing*  by punching a [LOAD] target, or can click another file ad infinitum.*  Safer if mouse aim is jerky and he gets wrong file,*  so used for Writes.  Reads activate on Click name, or ENTER with *buff. */     (*pprintf)("%-26s   (CANCEL)",       del  ? "   (KILL FILE)" :       (dir ? "   (CHANGE DIR)" :       (wr ?  "   (WRITE FILE)" : "   (READ FILE)") ));      /* "(READ FILE)" can be del'ed to "" */                    /* Little window for selected filename */     wcreate(LOOKLCOL+8, LOOKTOP-7*nlines-4, 35, 1, TRUE, WSPLAIN);     alcurset(TRUE);     (*pprintf)("Click one, or type name: ");     cp = buff;     for( ; ; ) {          rec = (*ptextmen)(1, LOOKTOP, 26, 3, 0, nlines, TRUE);  /* Negative return is a typed character */          if(rec < 0) {               rec = (-rec) & 127;               if(cp==buff)                    (*pprintf)("\f\n");  /* clear window prompt */     /* check special chars */               if(rec=='\n') {                    *cp = '\0';                    break;    /* Exit loop with whatever in buff */               }               if(rec==8) {   /* BkSp */                    if(cp > buff)                         cp--;               }               else if((rec==Ctrl('u' )) || (rec==Ctrl('x'))) {                    rec = Ctrl('X');     /* Fran's vanna() uses ^X */                    cp = buff;               }               else if(rec==' ')   /* No blanks! */                    continue;               else                    *cp++ = rec;               (*pputchar)(rec);  /* (was pprintf %c) Echo */               (*pflush)();               continue;          } /* typed char */     /* Mouse click.  0 means off-menu */          rec--;     /* Allow for odd #files with blank bottom right column */     /* Plus the EXIT and LOAD "buttons" on bottom line */          if( (rec >= nrecs) && !(rec % 3) ) { /* "Do" the file, if any */               *cp = '\0';               break;          }          if((rec < 0) || (rec > nrecs)) {  /* Exit, no load */               *buff = '\0';           /* cancels */               break;    /* this loop */          }          else {         /* Copy picked name */               strncpy(buff, fnames + 26 * rec, NAMELEN+1);               cp = buff + strlen(buff);     /* allow editing */               (*pprintf)("\f\n%s", buff);               (*pflush)();               if(( !wr && !del) || (wr && dir))                    break;    /* instant actions; covers dir too */          }     } /* for */     wkill();  /* the little name window */     wkill();       /* big dir window */     if(rfr_bar)          clear();  /* entire screen */     return;} /* fnamenu() *//* Write Scores and/or other subsets to a file,  *   using caller's filename, which user input overwrites *   if we have to prompt. * Null fname or 'w' forces prompt; null response aborts whole call. * Unless over==T, Write won't clobber existing file w/out asking. *  wr && over ==> Save * !wr && over ==> DIR only (?) * * Reads now ask for new filename only if given null, *  so caller must clear name if new prompt is wanted. * * Open() failure prompts for new name; *  should also allow for new directory path (not yet). * 95/2/2  (wr && invert) kills given type of file * 94/4/1  (extype=='a') calls appendio() * 90/5/15 'invert' arg added to permit sub for fnamenu() calls. * 88/1/2 Tried fwrite() family, no speedup but 500 more bytes code!wr   over invert    Action:1    0    0         Write after prompt (save-as)1    1    0         Save1    -    1         Kill (new)0    1    0         Dir *.ume0    1    1         Dir all but *.ume0    0    -         Read after prompt (open)*/bool main(what, fname, wr, extype, over, invert)   /* really diskio() */  char    what;     /* selector, not used, req'd by SooWee */  char    *fname;  bool    wr,       /* TRUE==write, else read */          over,     /* Overwrite (Save) w/out checking */          invert;   /* "all but" for DIR; turns Write into Kill */  char    extype;     /* u, i, p, l, m; a; x */{     char      obuff[BUFFSIZE], buff[BUFFSIZE], *ext;     long      whereto;       /* corrects for too-long scores */     short     evtarsiz;      /* this means SHORT -- 2 bytes! */     bool      ok = TRUE,     /* innocent until ... */               append = FALSE,               kill;     byte      tlines;     sexy      page, onparts, onstaves;     int       tried, did, nevsleft, chan;     Reg int   (*disk)();     /* read() or write() */     if(extype == 'a') {          extype = 'u';          append = TRUE;     }     kill = (wr && invert);/* Combined file-openers */     if( !*(ext = extent(extype)))          return(FALSE);/* If over && !wr (silly), then just DIR and maybe CHD */     if(over && !wr) {          for( ; ; ) {               fnamenu(fname, ext, invert, TRUE, FALSE);               if( !*fname)                    break;               if( !chdir(fname))       /* ==0 is good */                    break;               (*psprintf)(buff, "Can't CHD to '%s'\n", fname);               (*palert)(buff, 0);               *fname = '\0';          }          return(FALSE); /* since no I/O attempted even on good CHD */     }/*  Real file I/O ... */     while(TRUE) {       /* Just to avoid GOTOs */          if( (wr && !over) || !*fname ) {               fnamenu(fname, ext, wr, FALSE, kill); /* diread getfile menu */               if(! *fname)          /* Null name ==> just forget it */                    return(FALSE);   /* indicate no I/O attempted */          }/* Append given .ext to name, if not already */          addext(fname, ext);                   if(append)               return(appendio(fname));          if(kill) {     /* Re-loop menu for multi-kills */               if(unlink(fname))                    (*palert)("***Can't kill file; read-only?  Error#",                      1, errno);               *fname = '\0';               continue;          }/* Write file-opening */          if(wr) {               disk = write;               if( (chan = open(fname, 1)) > 0) { /* exists already */                    close(chan);   /* just looking */                    if( !over) {                         (*psprintf)(buff, "OVERWRITE %s?", fname);                         if( !(*pyesno)(buff) ) {                              *fname = '\0';                              continue; /* NO! -- Get another name */                         }                    }               } /* already exists */               chan = creat(fname, S_IREAD | S_IWRITE);               if(chan > 0)                    break;          /* Good, leave loop */               (*psprintf)(buff, " Can't create:\n %s\n", fname);          } /* Write opening *//* Read file-opening */          else {               disk = read;               if( (chan = open(fname, 1)) > 0) {                    if(extype == 'u') {                         onparts = nparts;                         onstaves = nstaves;                         fgpart(1);                         fgstaff(0);                    }                    break;  /* Good opening */               }               (*psprintf)(buff, " Can't open:\n %s\n", fname);          }     /* No opening, try again */          (*palert)(buff, 0); /* covers 3 cases */          *fname = '\0';      /* Force a[nother] prompt */     } /* file-opener while *//* File is open, proceed. *//* Version type number is 1st Byte, packed in with nparts */     if(extype == 'u') {        /* not just specials */          if(wr) {  /* was (disk == write) */               scorelvl = (SCLEVEL <<8) + nparts;               write(chan, &scorelvl, 2);               scorelvl = SCLEVEL;  /* for later simplicity */               barswap();     /* 89/09/21 */          }          else {    /* Read used to kill all pages first */               read(chan, &scorelvl, 2);               nparts = scorelvl & 31;               scorelvl = *((char *) &scorelvl);               if(scorelvl && (scorelvl != SCLEVEL) ) {                    (*psprintf)(buff,                      "Score Version is %d; we're %d -- OK.",                      scorelvl, SCLEVEL);                    (*palert)(buff, 0);               }/* Thought that keysig was written/read, like numer/denom.  It ain't! */               keysig = 0;    /* 91/8/27 */               if(scorelvl < 7)                    transp = 0;          }          (*disk)(chan, &nstaves, 2);          if((nstaves < 0) || (nstaves > NSTAVES)) {               close(chan);               (*palert)("Odd file, punt!\n", 0);               nparts = onparts;   nstaves = onparts;               return(FALSE);          }          (*disk)(chan, &numer, 2);          (*disk)(chan, &denom, 2);          (*disk)(chan, &nevents, 2);          (*disk)(chan, parts, (nparts + 1) * sizeof(PART));          (*disk)(chan, staves, nstaves * sizeof(STAFF));/* In case not enuf RAM for whole score.  Overflow fixed 10/15/89 */          whereto = lseek(chan, 0L, 1) + (long)nevents * (long)SEVENT;#ifdef WHERETO/* In case reading big score written under later version UmusE: */          if(nevents > NEVENTS) {               (*psprintf)(buff, "WARNING:\n Score cut from %d to %d items!\n",                 nevents, NEVENTS);               nevents = NEVENTS;               (*palert)(buff, 0);          }#endif/* At last -- move some data, using intimate knowledge of paging system */          for(nevsleft = nevents, page = 1; nevsleft > 0; )          {               if( !(*ppswap)(page++)) {  /* makepage() if needed on read */                    page--;        /* error, put it back */                    nevents -= nevsleft;                    (*palert)("\007**Outa RAM, Score Cut!\n", 0);                    (*ppswap)(page - 1);    /* last successful page */                    ok = FALSE;                    break;               }               tried = (nevsleft > PNEVENTS) ? PNEVENTS : nevsleft;               did = (*disk)(chan, (ubyte *)database, SEVENT * tried) / SEVENT;               if(did != tried) {  /* some sort of disk error */                    ok = FALSE;                    break;               }               nevsleft -= did;          } /* for pages */          (*pgivebac)();          barswap();     /* Swabs Read-in, or un-swabs Written */          lseek(chan, whereto, 0); /* as if all events read */          if(ok || read)               nmpages = page - 1;/* More stuff, after events */          (*disk)(chan, &secmin, 2);     } /* if(extype == 'u') */     else          scorelvl = SCLEVEL; /* make all special files work *//* 'u' writes always save the orchestra (unlike the Titanic) *//* Reads of ancient scores lacking instrument tables keep previous. *//* 97/1/28 Keep 16 shorts of values, and 16 names, for back patly,*  hard-coding original NINSTRS=16 and INAMEL=10.*  But must work to Write back-pat 16x10 array!*/     if((extype=='u') || (extype=='i'))     {          char ibuff[10], *cp;          int  inst;          if( !wr)     /* Rule out mergers for now */               instinit();     /* Instvals[] is in shorts, not bytes */          ok &= ( (*disk)(chan, instvals, 2*16) == 2*16);          for(cp=instnams[0], inst=0;  inst < 16;  inst++, cp += INAMEL) {               if(wr) {                    strncpy(ibuff, cp, 10);                    ibuff[9] = '\0';     /* needed? */               }               ok &= ( (*disk)(chan, ibuff, 10) == 10);               if( !wr) {                    ibuff[9] = '\0';     /* just for safety */                    strncpy(cp, ibuff, 10);               }          } /* for */     } /* R/W back-pat Instr names *//* Channel Assignments Table */     if((extype=='u') || (extype=='m'))     {          ok &= ( (*disk)(chan, chans, sizeof(chans)) == sizeof(chans) );     }     if((extype=='u') || (extype=='l')) {/* Shareware scores have MIDI Levels here.  SCRLVL-3 should have! *  Some older Version 2 sharewares lack these, so give credit anyway. */          if((scorelvl==2) || (scorelvl > 3)) {               ok &= ( ((*disk)(chan, levels, sizeof(levels))==sizeof(levels))                 || (scorelvl==2) );          }     }     if(extype=='u') {/* Title/Info Banner *//* Pre-borrow any SHORT var here */          evtarsiz = (TLINES<<8) | TLENP1;          (*pswapevts)(TRUE);          if(wr || (scorelvl >= 3)) {               (*disk)(chan, &evtarsiz, 2);               if(evtarray) {                    if( !wr)                         titleclr();    /* helps 2nd half */                    ok &= ( (*disk)(chan, Titles, TLINES*TLENP1)                      == TLINES*TLENP1 );                    rfr_tit = ok & !wr;               }               else                    skipread(chan, TLINES*TLENP1);          }          else if(evtarray)               titleclr();          (*pswapevts)(FALSE);     }/* Level 6 Genvol Levels and Percussion MIDI note numbers *//* and L. 7 MIDI Transpose *//* NOTE: Stupid error -- genvols[] never used anywhere, just levels[] ! */     if(scorelvl >= 6) {          if(extype=='u') {               if(wr)                    write(chan, levels, 8);               else                    skipread(chan, 8);  /* 8 useless genvols[]s in score */          }          if((extype=='u') || (extype=='p')) {               (*disk)(chan, percmids, 17);               ok &= ( (*disk)(chan, percsynth, 24) == 24);          }          if(extype=='u') {               ok &= ((*disk)(chan, &scrclock, 1) == 1);/* 90/9/5 Save & load Transposer semitones */               if(scorelvl >= 7)                    ok &= ((*disk)(chan, &transp, 2) == 2);/* 93/4/18 Save & load "outline" Immediate Events array */               if(scorelvl >= 9) {                    if(wr) {                         if( (*pswapevts)(TRUE) != NULL)                              evtarsiz = ievtused();                         else {                              evtarsiz = 0;                              (*pswapevts)(FALSE);                         }                    }                    ok &= ((*disk)(chan, &evtarsiz, 2) == 2);                    if(ok && (evtarsiz > 0)) {    /* no negatives! *//* Following will zero evtarsiz if swapevts() fails, preventing disk read */                         if( !wr) {                              did = (*pievtinit)(evtarsiz); /* Re-init */                              if(did < evtarsiz) {     (*palert)("Outa RAM; Events List cut short!\n", 0);                                   evtarsiz = did;                              }                             (*pswapevts)(TRUE);                              evtarnxt = evtarray + evtarsiz; /* non-Parnas */                         }/* OK to read into evtarray steda it+1, since will read back the EA byte */                         ok &= ( (*disk)(chan, evtarray, (int)evtarsiz)                           == evtarsiz);                    }                    (*pswapevts)(FALSE);               } /* >= 9 */          } /* 'u' */     } /* level >= 6 */     if(scorelvl >= 11) {/* Expanded Title-box Lines */          if(extype=='u') {               (*pswapevts)(TRUE);     /* If Write, figure how many to put out; won't hurt if reading */               for(tlines = TOTLINES; --tlines >= 0; )                    if(*(Titles+TLENP1*tlines))  /* highest non-blank lines */                         break;               tlines += (1 - TLINES);               if((tlines < 0) || (wr && (evtarray==NULL)) )                    tlines = 0;     /* Common R/W code */               (*disk)(chan, &tlines, 1);               if(tlines) {                    if(evtarray)                         (*disk)(chan, Titles+TLINES*TLENP1, tlines*TLENP1);                    else      /* get here only on Read */                         skipread(chan, tlines*TLENP1);               }               (*pswapevts)(FALSE);          } /* 'u' extra Title lines *//* Expanded Instr tables.  Give OK credit on 'i' to avoid failure gripes*  on old .INS files. */          if( (extype=='u') || (extype=='i') ) {               ok &= (Instio(chan, wr) || (extype=='i'));          }     } /* level >= 11 */     close(chan);     if( !ok)          (*palert)(wr ? "**Disk Full?"            : "**Disk Read Short; Data bad?", 0);     /* audit(); */     return(TRUE);  /* meaning that I/O was attempted by user */} /* diskio() *//* <eof> diskio.c */