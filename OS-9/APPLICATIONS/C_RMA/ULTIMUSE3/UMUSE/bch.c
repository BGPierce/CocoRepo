/* file  BCH CHIPS.C  -3-   Chipper/Bomber for UltiMusE*  Originally two files, CHIP.C and REGEN.C until 87/8/26*  Adds and subtracts note durations artificial-intelligently.*  One of UltiMuseE's oldest programs, and one of its smartest,*  this could be dynamite for translating MIDI recordings of*  hand-playing into music score notation.*  CHIPS is basis of philosophy that new notes/rests can be*  laid only on top of existing ones.*/#define FXDOTSOK    FALSE     /* OK to fixup() with dotted rests? */#define CHDOTSOK    FALSE     /* OK to chip() into dotted rests? */#include <stdio.h>#include "wmuse.h"#include "vmem.h"extern NOTE         brush, qrest;extern direct bool  rfr_scr;extern direct Time  length;/* Statics to bind parse() to regen() and save states * between regen() calls: */extern direct sexy      rshift,       /* how far ...left has been shifted so far */      vslot;        /* victim's slot (note -vs- rest) */extern direct short      strleft,      /* Straight (x3) duration left */      trileft;      /* Triplet (x2) duration left */extern Deltime      durleft;      /* Total duration left, WITH multipliers */extern direct bool      tripnow;      /* Output triplets now */extern PART     parts[NPARTS+1];Time fulltime();Index chip(), qchip(), ghola();bool parse();Deltime bomb(), regen();/* Overseer fcn to make sure bomb doesn't exceed length of score.*  If it would, shortens it and recomputes Dur and DurMod.*  Always cleans up afterwards in case of barline straddles, etc.*/Index chip(victind, newnote, newdur, npart)  Index   victind;  NOTE    *newnote; /* body parts may get changed */  Deltime newdur;   /* ticks length of new note/rest */  sexy    npart;{     NOTE      vicfirst;     Index     lastind;     Time      vstime;     Reg EVENT *evp;     automouse(FALSE);/* Will new note/rest fit in score time frame? */     if( (vstime = fulltime(victind)) + (Time)newdur <= length) {          lastind = qchip(victind, newnote, newdur, npart);     }     else {    /* No, off end of score */     /* Construct new duration for note/rest */          newdur = (Deltime)(length - vstime);          bomb(victind, NULL, &vicfirst, (Time)newdur);          lastind = ghola(npart, newnote, newnote->durmod,            newdur, vstime, CHDOTSOK);     }     if(lastind >= 0)          fixup(victind, lastind, npart, FALSE);     return(lastind);    /* totally off by now, but... */} /* chip() *//* Find the next barline (or end) even if already sitting on one *//* 901028 "..even if.." actually implemented as "ind+1" */Index nextbar(ind)  Index   ind;{     Reg EVENT *evp;     if(ind < nevents) {          for(evp = i2p(ind + 1); curind < nevents; evp = plusplus())               if(anybar(evp))                    return(curind);     }     return(nevents - 1);}/* Clean up a region of a part.* Fix barline straddlers and fill in holes.* Use after partcopy or a splitting chip job.*/void fixup(lind, rind, part, doplus)  Index   lind, rind;  sexy    part;  bool    doplus;   /* fill in Rests for Plus-parts too */{     NOTE      restemp;     Time      bigbart;     Etime     partime, lpartime, lbartime;     Deltime   lpardur, gap;     sexy      lpdurmod;     Index     ghind, lbarind, lpartind, indiff;     Reg EVENT *evp;     automouse(FALSE);     if(! doplus)   /* if false, redefine to "not a plus-part" */          doplus = !(parts[part].philo & NOFLAG);     cpynote(&restemp, &qrest);/* Expand limits outward by one barline */     if(rind < lind)     /* 91/9/30 */          rind = lind;     if(lind > 0) {          for(evp = i2p(lind - 1); curind > 0; evp = decdec())               if(anybar(evp))                    break;          lind = curind;     }     rind = nextbar(rind);/* Now run the state machine.*  lbarind and lpartind are cleared whenever the "other" is encountered.*  At most one is valid at a time, whoever was last seen.*/     ghind = 0;     lbarind = lpartind = BADIX;     rind = nevents - rind;   /* moving target */     for(evp = i2p(lind); curind <= nevents - rind; evp = plusplus()) {          indiff = nevents - curind;    /* to restore curind after gholas */          if(evp->part == part) {  /* one of our boys */               partime = evp->startime;               if(doplus) {          /* Gap between parts? */                    if(lpartind >= 0) {                         if( (gap = partime - lpartime - lpardur) > 0) {                              ghola(part, &restemp, lpdurmod, gap,                                fulltime(lpartind) + (Time)lpardur, FXDOTSOK);                         }                    }          /* Gap from last barline to this part? */                    else if(lbarind >= 0) {                         if( (gap = partime - lbartime) > 0) {                              ghola(part, &restemp, 0, gap,                                fulltime(lbarind), FXDOTSOK);                         }                    }               } /* if(doplus) */               evp = i2p(nevents - indiff);               lbarind = BADIX;               lpartind = curind;               lpartime = partime;               lpardur = cod2raw(evp->show.dur,                 (lpdurmod = evp->show.durmod) );          } /* if one of our parts */          else if(anybar(evp)) {   /* a Barline */               lbartime = evp->startime;     /* don't need a 'bartime' */     /* Gap from last part to this barline?  Ignores Tacet bars. */               if((lbarind < 0) && (lpartind >= 0)) {                    gap = lbartime - lpartime - lpardur;                    if(doplus && (gap > 0)) {                         ghind = ghola(part, &restemp, lpdurmod, gap,                           fulltime(lpartind) + (Time)lpardur, FXDOTSOK);                         i2p(nevents - indiff);   /* restore curind */                    }     /* Note/rest straddling barline? */                    else if(gap < 0) {                         bigbart = fulltime(curind);                         bomb(lpartind, NULL, &restemp, (Time)lpardur);/* alert("Restemp's artic=", 1, restemp.artic); */                         restemp.durmod = 0;      /* feather it in */                         lpardur = lbartime - lpartime;                         lpartind = ghola(part, &restemp, lpdurmod,                           lpardur, bigbart - (Time)lpardur, FXDOTSOK);                         if(lpartind < 0)                              return;                         i2p(lpartind)->show.artic = TIED;                         i2p(nevents - indiff);   /* before 2nd half */                         lbarind = curind;        /* must save now */                    /* 2nd half must not affect moving-target adjustments */                         restemp.durmod = lpdurmod;                         ghind = ghola(part, &restemp, 0,                           -gap, bigbart, FXDOTSOK);/* alert("Fixup: ghind=",1,ghind); *//* alert("Now artic=", 1, restemp.artic); */                      /* if(ghind > 0)                              i2p(ghind)->show.artic = restemp.artic; */                         i2p(lbarind);  /* restore curind */                         cpynote(&restemp, &qrest);    /* back to Rest */                    }               }               lbarind = curind;               lpartind = BADIX;          /* Extend upper bound if ghola ran over it */               if(ghind >= nevents - rind) {                              rind = nevents - nextbar(ghind);                    i2p(lbarind);               }          } /* barline */     } /* main state machine loop */} /* fixup() *//* New 90/3 separate Bomber.  LONG bdur arg!* Copies given inote into given victim, except !inote ==> remove victim.*   use NULL inote to clear big areas for Part Copies.* Returns remaining duration of last bombing victim, or 0 if perfect fit.* Last victim's "note" is copied into onote.* Uses new bomb's_endtime vs victims'_startime scheme,*   which handles Tacetized bars and other holes in score.*/Deltime bomb(vind, inote, onote, bdur)  Index   vind;     /* who gets bombed */  NOTE    *inote, *onote;  Time    bdur;     /* that's Long */{     Time      betime,   /* End time of Bomb */               vetime,   /* and current victim */               vstime;   /* Victims' start times */     Index     savind;     Reg EVENT *evp;     betime = (vstime = fulltime(vind)) + bdur;     evp = i2p(savind = vind);     cpynote(onote, &(evp->show)); /* Save old note *//* alert("Bomb: 1st vicart=",1,onote->artic); *//* Put new note in old's slot; won't harm sortedness */     if(inote) {          if(inote->slot == REST)       /* 91/10/2 */               inote->artic = NORMAL;          cpynote(&(evp->show), inote);     }     vetime = vstime + (Time)cod2raw(onote->dur, onote->durmod);/* If new note is longer than old, must overlay it and maybe * its successors; called "Bombing" the block in Phila. */     while(betime > vetime) {     /* BOMBs away ... */          vind = next(savind);     /* Can cross time-bands if tacet */          if((vind <= 0) || ((vstime = fulltime(vind)) >= betime)) {               vetime = betime;    /* force return(0) */               break;          }     /* Must bomb at least part of this note/rest too */          cpynote(onote, &(i2p(vind)->show));  /* save latest victim *//* alert("Bomb: vicart=",1,onote->artic); */          vetime = vstime + (Time)cod2raw(onote->dur, onote->durmod);          remove(vind);     }     if( !inote)          remove(savind);     else if(vetime == betime) /* Ghola gets no chance to fix artic */          i2p(savind)->show.artic = onote->artic;/* Next is limited to one note's duration, so "can't" overflow */     return((Deltime)(vetime - betime));} /* bomb() *//* New 90/3 separate regenerator of surviving note fragments.*  Vicnote should include desired final Artic, and DurMod of last victim*    to guide the "ethnics" of regeneration.*  Return index of last note added.*/Index ghola(part, vicnote, bdurmod, raw, when, dotsok)  sexy    part, bdurmod; /* bomber's ethnics */  NOTE    *vicnote;  Deltime raw;      /* big enuf for one note */  Time    when;     /* Double startime */  bool    dotsok;   /* OK to create dotted rests */{     sexy vartic;     Deltime   fragdur, remdur;     Index     tind;     Reg EVENT *evp;     rfr_scr = TRUE;     if(vicnote->slot == REST)       /* fixed 91/10/2 */          vicnote->artic = vartic = NORMAL;     else {          vartic = vicnote->artic;          vicnote->artic = TIED;     }/* Insert chipped note fragment(s), beginning at 'when'. */     parse(raw, bdurmod, vicnote->durmod, vslot = vicnote->slot);     do {       /* while(remdur) */          remdur = regen( &vicnote->dur, &vicnote->durmod, dotsok);          fragdur = raw - remdur;          if((tind = enter(when, part, vicnote->slot)) < 0)               return(BADIX);          evp = i2p(tind);          cpynote(&evp->show, vicnote);          when += (Time) fragdur;          raw = remdur;     } while(remdur > 0);/* Last fragment note is not tied unless it was already */     vicnote->artic = evp->show.artic = vartic;     return(tind);} /* ghola() *//* Simple chip to call when new note's dur & durmod are known,*    as from smash(), and note will fit in score's length.*  No error checking of any kind!*  Fixup() can be called after to look for overhangs, etc.*  Args are new:  pass &brush in place of newdurmod.*  Return last index written or added to.*/Index qchip(vind, inotep, newdur, npart)  Index   vind;  NOTE    *inotep;  Deltime newdur;  sexy    npart;{     NOTE      vicnote;     Time      when;     Deltime   remdur;     sexy      bdurmod;  /* Bomber's ethnic */     bdurmod = inotep->durmod;     remdur = bomb(vind, inotep, &vicnote, (Time)newdur);     if( !remdur) {          return(vind);     }     when = fulltime(vind) + newdur;     return(ghola(npart, &vicnote, bdurmod, remdur, when, CHDOTSOK));} /* qchip() *//* The Ancient Intelligence begins here (vintage '86 or so)To regenerate note(s) with .dur and .durmodfrom raw fixed-point durations.     First call parse() with total duration and context info.     Then each call to regen() returns a .dur and .durmod and the remaining raw dur;  when that is zero, conversion is complete.Scaled for:    Breve Wh  Half Qut  8th  16th 32nd 64thStraight        384  192  96   48   24   12   6    3Triplet         256  128  64   32   16    8   4    2(after Divide)  128   64  32   16    8    4   2    1Cdur code         0    1   2    3    4    5   6    7rshift            7    6   5    4    3    2   1    0*//* To enumerate all the ways of splitting * a positive integer into two positive integers, * one a multiple of 2 and the other of 3. */bool  parse(rawdur, chiptyp, victyp, vicslot)  Deltime rawdur;   /* given duration time */  sexy    chiptyp,  /* durmod code of chipper/bomber */          victyp,   /* same for victim note */          vicslot;  /* victim's note/rest */{     short odd, rest;    /* the two multiples */     short strait, trip; /* and their multipliers */     short bods;         /* no. of notes needed to show */     short mindur, maxmin;    /* smallest notes of each type */     short bestbod, bestmin, bestmax;   /* best so far */     short smin, tmin;/* First reject impossible durations of 0 or 1 */     if( !rawdur || (rawdur == 1))          return(FALSE);/* OK.  Always retun the Chipper's type notes first: */     vslot = vicslot;    /* for Regen()'s use later */     tripnow = (chiptyp == 3);     durleft = rawdur;   /* also for Generator later */     rshift = 0;         /* ditto *//* If chipper and victim are same type, try to keep result same */     if((chiptyp < 3) && (victyp < 3)) {     /* Straights */          strleft = rawdur / 3;    /* Maybe, if it divides evenly */          trileft = 0;             /* Also maybe */           if( !(rawdur - 3 * strleft))      /* Can keep */               return(TRUE);     }     else if((chiptyp == 3) && (victyp == 3)) {   /* Triplets */          if( !(rawdur & 1)) {               /* Can be all Trips */               trileft = rawdur >> 1;               strleft = 0;   /* no straights at all */               return(TRUE);          }     }/* If chipper and victim were different types, * or their preference wouldn't divide evenly, * then must find the "best" way to represent the raw duration * as mixture of straight and triplet notes. * This means the fewest note bodies, and avoid tiny notes. * * Use brute-force enumeration method: * -- Just count up thru the multiples of 3 (straights), * subtracting from the rawdur, and trying to divide * the rest by 2 (triplets). * Result is in 'strleft' (Best Straight) when done. */     bestbod = 99;     bestmin = bestmax = 0;     strait = 0;    /* keep odd == 3 * strait */     for(odd = 0; odd <= rawdur; odd += 3) {          rest = rawdur - odd;          if(!(rest & 1)) {         /* if can divide by 2 */               trip = rest >> 1;    /* then divide it */          /* Compute rating qualities for this split */               smin = tmin = 999;               bods = nbods(strait, 0, &smin)                  + nbods(trip, 1, &tmin);               mindur = (smin < tmin) ? smin : tmin;               maxmin = (smin > tmin) ? smin : tmin;/* Pick the best so far, choosing by (most important first): * Least Body Count, Biggest Min.mindur, Biggest Max.mindur */               if(bods < bestbod) {     /* "Clearly Superior" */                    bestbod = bods;                    bestmin = mindur;                    bestmax = maxmin;                    strleft = strait;               }               else if(bods == bestbod) {    /* Tied for Body Cnt */                    if(mindur > bestmin) {   /* break tie */                         bestmin = mindur;                         bestmax = maxmin;                         strleft = strait;                    }                    else if(mindur == bestmin) {  /* tied again! */                         if(maxmin > bestmax) {   /* last chance */                              bestmax = maxmin;                              strleft = strait;                          }                          /* else if( --tie-- ) etc. would go here */                    } /* mindur */               } /* bods */          }          strait++;       /* now matches NEXT odd in 'for' */     } /* 'for' enumerator of splitting parses */     trileft = (rawdur - 3 * strleft) >> 1;     return(TRUE);}/* Helper subr for parse(); * Count # of note bodies needed for either type of number. * Peels from LSB (right) side, smallest first. * Keeps track of mindur in process. */short nbods(n, trip, min)   unsigned n;  short trip;           /* ==0 for straight, ==1 for trips */  short *min;           /* mindur collector */{     short bods = 0;     short weight, dec, dur;     weight = 3 - trip;      /* 2 for trips, 3 for straights */     while(n) {              /* until n is exhausted */          while( !(n & 1)) {      /* get (current) LSB into Bit 0 */               n >>= 1;               weight <<= 1;          }          bods++;     /* Classify up to 3 solid LSBits */          if( !trip) {               if(n & 2) {          /* ie, (n & 3) == 3 */                    dec = n & 7;    /* gives 3 or 7, NOT 5 */                    n -= dec;       /* Got at least one dot */                    dur = weight * dec;               }          /* Doing straights, but no dots available */               else {                    n--;                    dur = weight;               }          }     /* Doing triplets; no dots allowed */             else {               n--;            /* dupe'd the cheapest code */               dur = weight;          }        /* This can hit only on 1st pass thru outer while() */          if(dur < *min)               *min = dur;     } /* 'n' exhausted */     return(bods);}/* The Generator: outputs note fragments, one per call */Deltime regen( cdur, cdurmod, dotsok)  byte    *cdur,    /* duration code to return */          *cdurmod; /* duration mod to return */  bool    dotsok;/* Plus Static tripnow, durleft, strleft, trileft, rshift, vslot */{short     weight,     *useleft,      /* either strleft or trileft */     dec;     if( !trileft && !strleft) {   /* self-defense */          alert("***Regen: piles=0, DurLeft=", 1,durleft);          return(0);     }/* Which type are we supposed to do now? */sel: if(tripnow) {          weight = 2;          useleft = &trileft;     }     else {          weight = 3;          useleft = &strleft;     }/* Switch to other type if current choice is done */     if( ! *useleft) {          rshift = 0;         /* to begin other number */          tripnow = !tripnow; /* swap pointer & wght on re-select */          goto sel;     }/* Get LSB into Bit 0 */     while( !(*useleft & 1)) {          *useleft >>= 1;          rshift++;     }/* Pull out one note body */     if( !tripnow) {     /* doing Straights */          if( (dotsok || (vslot !=REST))             && (*useleft & 2)) { /* Note and 1 or 2 dots */               if( *useleft & 4) { /* Two dots */                    *cdurmod = 2;                    *cdur = 5 - rshift;                    dec = 7;               }               else {              /* just one dot avail */                    *cdurmod = 1;                    *cdur = 6 - rshift;                    dec = 3;               }          }          else {    /* Rest, or no dots available */               *cdurmod = 0;               *cdur = 7 - rshift;               dec = 1;          }     } /* end straight notes */          else {    /* Triplet, no dots allowed */          *cdurmod = 3;            /* Triplet */          *cdur = 7 - rshift;          dec = 1;     }/* Decrement *useleft and durleft */     *useleft -= dec;     dec <<= rshift;     /* recover "fixed point" value */     durleft -= (weight * dec);/* Always return remaining duration time; ==0 signals all done */     return(durleft);     } /* regen() *//* eof bch.c */