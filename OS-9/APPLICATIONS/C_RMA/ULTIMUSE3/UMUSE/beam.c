/* file BEAM.C  Coco Version started 3/31   BEAMING begun 97/3/6   To see about making Beaming a common fnc for Show and Print.    3/15 Put Clone drawing back up to show(), print()*/#include "wmuse.h"#include "vgraf.h"#include "wwidths.h"#include "vmem.h"#include "screen.h"#include "macros.h"#include "fcnptrs.h"#define MAXBEAM 16    /* Most notes allowed in a group */#define BPITCH   4    /* Y-separation of beams */#define BSOLO    1typedef struct {    Index   grind;    int     grx, gry, groff;    sexy    grdur;} GROUP;extern STAFF    staves[];extern ubyte    grafxes[];    /* 0 - 79 columns */extern ubyte    grafyes[];    /* 0 - 207 lines */extern direct sexy    numer, denom,    nparts,    nstaves;extern Etime    zonedur, dendur;extern direct int    xyoff,         /* index - xyoff = xyindex */    xgoal,         /* where gind's object should be shown */    gbar;          /* bar # containing gind */    extern direct Index    lftind, ritind;  /* edgemost indices shown */extern direct bool    tripper,    compact,      /* Squeeze as many notes as possible */    thick;/* Later add switches as needed */main(what)  char    what;{     beams();}/* The real fcn */beams() {    GROUP   group[MAXBEAM];    Etime   lbartime, bartime;    Deltime now;    int     part, nth;    Time    remdur;    short   staffy;    int     beat, oldbeat, beatoff, count, yoff, step, jack,        leftx, lefty, rightx, righty, slotsum,        deltx, delty, i, disc, maxhi, maxlo, lnumer, ldenom;    Index   indsave;    sexy    mindur, maxdur, hilo;    bool    solo, clozeup, stemdn, special;    int     notex, notey;    GROUP   *grptr;    Reg EVENT *evp;/* Get lefty latest TS and startime */    lbartime = 0;    for(evp = i2p(lftind); curind >= 0; evp = decdec()) {        if( !lbartime && anybar(evp))            lbartime = evp->startime;        if( !evp->part && evp->show.INCTYPE==TIMESIG) {            lnumer = evp->show.TSNUMER;            ldenom = evp->show.TSDENOM;            if(lbartime)                break;        }    } /* find TS and lbartime */    for(part = 1; part <= nparts; part++) {        numer - lnumer;        ldenom = denom;        timesig();        special = !tripper & (denom >= 8);        showstaff(part, &staffy, &hilo);    /* need both, must repeat */        if(hilo & NOFLAG)    /* Clones already done by show() */            continue;        solo = ( (hilo & (UPPER|LOWER))==SOLO);    /* Mid-staff part */        clozeup = FALSE;        count = oldbeat = beatoff = 0;        bartime = lbartime;/* In this loop, no relevant items "continue".*  Major events set 'clozeup' and push on thru loop. */        for(evp = i2p(lftind); curind <= ritind; evp = plusplus())        {            if(curind == ritind)    /* Last item on screen? */                clozeup = TRUE;            if(evp->part == part) {                if(evp->show.slot == REST) {    /* already drawn */                    clozeup = TRUE;             /* breaks beam group */                }                else {    /* One of our notes */                    notex = grafxes[curind - xyoff];                    notey = grafyes[curind - xyoff] & 255;                    stemdn = Stemway(hilo, evp->show.slot);        /* Keep bass note stems out of Menu */                    /* stemdn &= (notey > (SCROLTOP + 15)); */        /* Find current timezone */                    beat = (evp->startime - bartime) / zonedur;                    if(special)                         remdur = (evp->startime - bartime) - (beat * zonedur);        /* Is note beamable (8th or smaller)? */                    if(evp->show.dur < 4) {  /* No */                        clozeup = TRUE;                        (*pdrawnr)(&(evp->show), notex, notey, staffy, stemdn,                          FALSE, FORE);                    }                    else {    /* Yes! */                        if( !count) {    /* First one of group */                            grptr = group;                            slotsum = evp->show.slot;                            grptr->grx = notex;                            grptr->gry = notey;                            grptr->grind = curind;                            grptr->grdur = mindur = maxdur = evp->show.dur;                            count = 1;                            oldbeat = beatoff = beat;                        }                        else {    /* Group in progress */                            if( (beat == oldbeat)  /* Still within beat */                              || (special && ((count <= (beat-beatoff))                                || remdur)))                            {                                count++;                                grptr++;                                slotsum += evp->show.slot;                                grptr->grx = notex;                                grptr->gry = notey;                                grptr->grind = curind;                                grptr->grdur = evp->show.dur;                                if(grptr->grdur < mindur)                                    mindur = grptr->grdur;                                if(grptr->grdur > maxdur)                                    maxdur = grptr->grdur;                                if(count >= MAXBEAM)                                    clozeup = TRUE;                            }                            else {    /* Overtime, don't save in group */                                clozeup = TRUE;                                beatoff = beat;                                evp = decdec();  /* re-visit this note later */                            }                        } /* in group */                    } /* beamable note */                } /* our note */            } /* nonzero part *//* Inclusion or other part */            else if(anybar(evp)) {                bartime = evp->startime;                beat = beatoff = 0;                clozeup = TRUE;            }            else if(!evp->part && (evp->show.INCTYPE==TIMESIG)) {                numer = evp->show.TSNUMER;                denom = evp->show.TSDENOM;                timesig();                clozeup = TRUE;            }/* OK!  If 'clozeup' then time to draw a beam */            if( !clozeup)                continue;            clozeup = FALSE;    /* reset */            if( !count)                continue;            indsave = curind;    /* save before diddling */            if(count==1) {                grptr = group;                evp = i2p(grptr->grind);            /*  notex = grptr->grx;        notey = grptr->gry; */                stemdn = Stemway(hilo, evp->show.slot);                /* stemdn &= (notey > (SCROLTOP + 15)); */                (*pdrawnr)                  (&(evp->show), grptr->grx, grptr->gry, staffy, stemdn,                  FALSE, FORE);                count = 0;                i2p(indsave);    /* restore */                continue;            }/* Two or more notes, so Beam me up! */            if(solo)    /* Stemway(slotsum / count) */                stemdn = (slotsum > (count * 4));            grptr = group;                /* left, #1 */            leftx = grptr->grx;            lefty = grptr->gry;            grptr->groff = 0;            grptr = group + (count-1);    /* right */            rightx = grptr->grx;            righty = grptr->gry;            grptr->groff = 0;/* If >2 notes, check for those above and below the beam,*  to jack it up or down so no stems are too short. */            maxhi = maxlo = 0;            if(count > 2) {                deltx = rightx - leftx;        /* always positive */                delty = righty - lefty;        /* may be negative */                for(i = 1, grptr = group+1; i < count-1; i++,grptr++) {                    notex = grptr->grx;        notey = grptr->gry;                    disc = deltx * (notey-lefty) - delty * (notex-leftx);                /* Best NOT to round off ! */                    disc /= deltx;            /* distance ABOVE the beam */                    grptr->groff = disc;                    if(disc < maxlo)    maxlo = disc;    /* neg */                    if(disc > maxhi)    maxhi = disc;    /* pos */                }            } /* >2 notes *//* Jack up the beam if needed.  Then stemups' groffs are all <=0. */    /* Extra jack if 32nd or 64th notes, even in 2-note group */            jack = (maxdur >5) ? (BPITCH * (maxdur-5) - 2) : 0; /* 5 == 16th */            if(stemdn)                maxhi = maxlo - jack;            else                maxhi += jack;            lefty += maxhi;        righty += maxhi;/* Jack loop also converts x's from cols to pixels,*  AND draws ALL beamed notes! */            for(i = 0, grptr = group; i < count; i++,grptr++) {                evp = i2p(grptr->grind);                notex = grptr->grx;        notey = grptr->gry;                /* stemdn &= (notey > (SCROLTOP + 15)); */                (*pdrawnr)(&(evp->show), notex, notey, staffy, stemdn,                  TRUE, FORE);                grptr->groff -= maxhi;                grptr->grx = notex = (notex * 8) + (stemdn ? 1 : 9);                if(i==0)                    leftx = notex;                if(i==count-1)                    rightx = notex;            }            if(stemdn) {                yoff = -13;                step = BPITCH;    /* 2--4 for multi beams */            }            else {                yoff = 13;                step = -BPITCH;            }/* Draw stem extensions.  X's are now in Pixels. */            for(i = 0, grptr = group; i < count; i++,grptr++) {                notex = grptr->grx;                notey = grptr->gry + yoff;    /* stem's endpt */                if( !grptr->groff)                    continue;                if(stemdn)        /* don't trust Fran's safety code? */                    vline(notex, notey - grptr->groff, notey, FORE);                else                    vline(notex, notey, notey - grptr->groff, FORE);            }/* Draw multiple beams depending on mindur == largest note */            lefty += yoff;            righty += yoff;    /* First beam, dur==4 */            if(thick && stemdn)                bline(leftx, lefty-1, rightx, righty-1);            else                bline(leftx, lefty, rightx, righty);    /* Rest of beams */            for(delty = step, i = 5; i <= mindur; i++) {                bagnline(delty);                delty += step;            }/* Finish with partial beams and solo tick-flags.*  Maybe later merge this with some of above.*  Algorithm is mini copy of the main one.*/#define RFL    7    /* Right flag tick lenth */#define LFL 7            {int    ldur, durcnt, sti, endi;                for(ldur = mindur+1; ldur <= maxdur; ldur++, delty += step) {                    durcnt = 0;    /* like 'count' */                    clozeup = FALSE;    /* re-use */                    for(i=0, grptr = group; i < count; i++, grptr++) {                        if(i == (count-1)) {    /* No "else" after this */                            clozeup = TRUE;                        }                        if(grptr->grdur < ldur) {    /* note not in */                            clozeup = TRUE;                        }                        else {                            endi = i;                            if(durcnt == 0)                                sti = i;                            durcnt++;                        }                        if(clozeup) {                            clozeup = FALSE;                            if( !durcnt)                                continue;                            deltx = group[sti].grx;                            if(durcnt > 1) {    /* sub-beam */                                bsegline(delty, deltx, group[endi].grx);                            }                            else {    /* Alone; which way to flag? */                                if(sti==0)                                    bsegline(delty, deltx, deltx + RFL);                                else if(sti == count-1)                                    bsegline(delty, deltx - LFL, deltx);        /* Aim flag towards longer time difference */                                else {                                   Etime pretime, curtime, postime;                                   curtime = i2p(group[sti].grind)->startime;                                   pretime = i2p(group[sti-1].grind)->startime;                                   postime = i2p(group[sti+1].grind)->startime;                                   if((curtime-pretime) > (postime-curtime))                                       bsegline(delty, deltx - LFL, deltx);                                   else                                       bsegline(delty, deltx, deltx + RFL);                                }                            }                            durcnt = 0;                        } /* clozeup */                    } /* group loop */                } /* dur loop */            } /* funny cars *//* Closeup MUST always execute this cleanup code! */            i2p(indsave);    /* restore */            count = 0;            clozeup = FALSE;        } /* index loop */    } /* part loop *//* End Beaming Phase Two.  Thank you, Scotty. */} /* beams() *//* eof BEAM.C */