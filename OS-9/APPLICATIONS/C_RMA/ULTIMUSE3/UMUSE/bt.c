/* BT.C  (Bmuse Tools)  Fcns to implement 2nd level additions*  to the main Score Menu toolbox.*/#include <stdio.h>#include "wmuse.h"#include "cursors.h"#include "wmenu.h"#include "vmem.h"#include "macros.h"/* Limits are place()'s slot limits, -15 thru +16 + 4, NOT sacred, *  but these avoid creating un-editable notes. * Used by tranpart(). */#define MAXSLOT     20#define MINSLOT     (-11)extern direct bool  rfr_scr, rfr_rep, rfr_men;extern direct sexy  nparts, curcurse;extern direct Index undind;extern direct Time  length;extern PART         parts[];extern NOTE         brush;extern ubyte   chans[NPARTS+1];extern char    instnams[NINSTRS][INAMEL];extern STAFF   staves[];extern CLEF    clefs[];/* New non-direct globals */extern sexy    pcfromp;extern int     tooly;Time fulltime();    /* MUST do this! */bool ispwexpr();char *volspell(vol)  sexy    vol;{     return("ppp\0pp \0p  \0mp \0mf \0f  \0ff \0fff"       + ((vol & 7) << 2) );}char *artspell(art)  sexy    art;{     return("Tied    \0Legato  \0(legato)\0Marcato \0Staccato"       + ((art & 7) * 9) );}/* Core routines pulled back from frag modules*  for use by core w/out "soowee."  May later revert to soowee.*//* Actual work of transposing a part's "slots" (staff lines) *//* Used by +8 and -8 tools, Block's Transpose, bt's Partcopy too. */void tranpart(partn, diff, stex, endex)  sexy    partn, diff;  Index   stex, endex;{     sexy      old, new;     Reg EVENT *evp;     for(evp = i2p(stex); curind <= endex; evp = plusplus() ) {          if(evp->part == partn) {               if( (old = evp->show.slot) == REST)                    continue;               new = old + diff;     /* Limits are place()'s slot limits, NOT sacred,     *  but these avoid creating un-editable notes. */               while(new > MAXSLOT)          /* too high */                    new -= 7;           /* so down an 8ve */               while(new < MINSLOT)         /* too low */                                   new += 7;               evp->show.slot = new;          }     }} /* tranpart(), was fixslot() *//* For all clone/plus parts betwen p1 and p2,*  assign them same MIDI Channel as their matching FLagship parts.*  Flagships are not restricted by p1, p2.*/void clonemid(p1, p2, where)  sexy     p1, p2;  ubyte     where[];{     sexy chilo, fhilo, dummy;     sexy cstaff, clone, flag;     if(p2 > nparts)          p2 = nparts;     if(p1 <= 0)          p1 = 1;     for(clone = p1; clone <= p2; clone++) {          cstaff = partstaff(clone, &dummy, &dummy, &chilo);          if( !(chilo & NOFLAG))               continue;          for(flag = 1; flag <= nparts; flag++) {               if( (partstaff(flag, &dummy, &dummy, &fhilo) == cstaff)                 && !(fhilo & NOFLAG)                 && !((fhilo ^ chilo) & (UPPER|LOWER)) )                    where[clone] = where[flag];          }     }} /* clonemid() */ /*** END of frags-to-Core pullbacks *//* Power-Toolbox routines *//* Print info about event clicked on.*  Find prevailing "weather" from nearest to left */squawk(ind)  Index   ind;{     ubyte chanz[NPARTS+1];     ubyte chinsts[16];     sexy inst, midinst, num, den, key, vol, genvol, chan, defart, thisart;     int  tempo;     sexy vpart, vpartno, slot, vslot, p;     Reg EVENT *evp;     defart = thisart = NORMAL;     for(chan = 16; --chan >= 0; )          chinsts[chan] = -1;     for(vpart = nparts; vpart > 0; vpart--)          chanz[vpart] = chans[vpart] & 15;     vpart = (evp = i2p(ind)) ->part;     vslot = slot = evp->show.slot;     vpartno = evp->show.PARTNO;   /* for partwise exprs */     dialogue(TRUE);     if(vpart)          printf(" Part %d, ", vpart);     flush();/* Find General Volume & Tempo & Sigs in any case.* If victim is a Part, find Vol, Instr, MIDI channel, ... */     tempo = 120;     num = den = 4;     key = 0;     inst = -1;     genvol = vol = 4;    /* mf *//* Main loop */     for(evp = i2p(0); curind <= ind; evp = plusplus()) {          if(p = evp->part) { /* one '=' */               if(p != vpart)                    continue;     /* Simulate Play's defaulting of artics */               if(evp->show.artic != NORMAL) {                    thisart = evp->show.artic;                    if(thisart != TIED)                         defart = thisart;               }               else                    thisart = defart;               continue; /* save tabs on Inclusion code */          }/* Inclusion, has most of the goodies */          switch(slot = evp->show.slot) {/* Even if target is not a Note/Rest, find these: */          case GENVOL:               genvol = evp->show.LEVELNO;               continue;          case NUTEMPO:               tempo = evp->show.TEMPONO;               continue;          case KEYSIG:               key = evp->show.KSN;               continue;          case TIMESIG:               num = evp->show.TSNUMER;               den = evp->show.TSDENOM;               continue;          } /* switch1 *//* Now only part-specific items */          if( !vpart)     /* our target's part, not evp's */               continue;          p = evp->show.PARTNO;    /* redefine */          switch(slot) {          case INSTR:    /* Track all current instruments */               chinsts[chanz[p]] = evp->show.INSTRNO;               if(p == vpart)                    inst = evp->show.INSTRNO;     /* "Says" */               continue;          case MCHOP:               chanz[p] = evp->show.INSTRNO;     /* yes, artic */               continue;          case LEVEL:               if(p == vpart)                    vol = evp->show.LEVELNO;               continue;          } /* switch2 */     } /* loop */     evp = decdec();     /* for TIE fix below *//* Figure out final chan, inst, and effective midinst */     if(vpart) {          chan = chanz[vpart];          printf("Channel %d  %s  %s\n", chan + 1, volspell(vol),            artspell(thisart) );          midinst = chinsts[chan];          printf(" Instr: ");          if(inst != midinst)               printf("says ");          printf((inst < 0) ? "none" : "%d=%s", inst, instnams[inst]);          if(inst != midinst) {               printf("; but plays ");               printf((midinst < 0) ? "none" : "%d=%s", midinst,                 instnams[midinst] );          }          putchar('\n');     }     else if(ispwexpr(vslot)) {          printf("Applies to Part %d.\n", vpartno);     }/* Print rest of report */     printf("Environment:  ");     printf(" %d/%d at %d  %s  ",       num, den, tempo & 255, volspell(genvol));     printf((key < 0) ? "%d flats\n" : "%d sharps\n",       (key < 0) ? -key : key);     printf("   Index %d at %u Ticks\n", ind, evp->startime);     hitenter();     wkill();} /* squawk *//* Block-copy a section of one part over another part *//* 'vind' must be a note/rest index */void partcopy(what, vind)  char    what;  Index   vind;{     char      buff[81];     NOTE      savenote;     EVENT     event;     Index     lind, rind;     Index     orignvts, firstind, lastind, oldnvts, srcind, destind;     sexy      dmod, npart, diff;     Deltime   remdur;     Time      srclen, srcend, srcstart, srcnow, destart, destnow;     sexy      vpart;    /* victim part */     Reg EVENT *devp;     if(what == 'q') {   /* Quit, back to normal */          rfr_men = rfr_rep = TRUE;     /* _men was _scr 96-2-20 */          return;     }/* Can't do anything (besides Quit) without [ ] *//* Check [] here, in case user deleted one while on CPARTCOPY */     fmarks(&lind, &rind, &lastind);    /* lastind ignored */     if(((rind | lind) < 0) || (rind <= lind)) {          alert("Missing [ or ], or ] [ backwards!", 0);          return;     }     if(what == 'i') {   /* Initialize */          drtools(2, 0);      /* open tool window */          printf("Click anything in Part\n  to Copy FROM:");          wkill();          return;     }/* else assume 'f' for "found an object" */     vpart = i2p(vind)->part;     if(!vpart) {          alert(" Must target a note or rest.", 0);          return;     }     if(curcurse==CPARTCOPY /* !pcfromp */ ) {          pcfromp = vpart;          curset(CPARTFULL);          rfr_rep = TRUE;          sprintf(buff, " Ready to Copy\n   from Part %d.", pcfromp);          drtools(2, 0);          printf(buff);          wkill();          return;     }/*   if(curcurse != CPARTFULL) return;    /* how'd we get called?!? *//* pcfromp defined, assume ready to copy to a victim */     if((pcfromp==vpart) && (vind >= lind) && (vind <= rind)) {          alert(" Can't copy the Same Part\n  to Inside of Block.", 0);               return;     }/* need clefs (not Perc) and bnotes */     {    sexy fclef, vclef;  /* funny-car vars */          fclef = staves[ parts[pcfromp].pstaff ].clef_no;          vclef = staves[ parts[vpart].pstaff ].clef_no;          if( (fclef==4) || (vclef==4) )     /* Perc */               diff = 0;          else               diff = clefs[fclef].bnote - clefs[vclef].bnote;     }     srcstart = fulltime(lind);     srcend = fulltime(rind);     srclen = srcend - srcstart;     destart = fulltime(vind);     if( (destart <= srcstart) && (destart + srclen > srcstart)       && (vpart == pcfromp) ) {          alert("Would overwrite Source part!", 0);          return;     }     if(destart + srclen > length) {          alert("Would run off end of score!", 0);          return;     }/* At last, get to work */     patience();     rfr_scr = TRUE;     firstind = lastind = vind;     remdur = bomb(vind, NULL, &savenote, srclen);     if(remdur)          lastind = ghola(vpart, &savenote, 0, remdur, destart+srclen, FALSE);/* Re-locate [ and ] after bomb & ghola */     fmarks(&lind, &rind, &vind);    /* vind ignored */     srcind = pnext(lind, pcfromp);     for( ; ;) {          if(srcind < 0)               break;          srcnow = fulltime(srcind);    /* VERY inefficient */          if(srcnow >= srcend)     /* RMark's startime is of Next */               break;          destnow = destart + srcnow - srcstart;          strevent(&event, i2p(srcind));          destind = enter(destnow, vpart, event.show.slot);          if(destind < 0)               break;          if(destind <= srcind)    /* follow moving source */               srcind++;     /* Keep track of highest index entered, for fixup */          if(lastind < destind)    /* if it beats ghola()'s */               lastind = destind;          devp = i2p(destind);          cpynote( &(devp->show), &(event.show));          srcind = next(srcind);     } /* copy loop */     fixup(firstind, lastind, vpart, FALSE);/* Translate to new clef 96-2-20 */     if(diff)          tranpart(vpart, diff, firstind, lastind);     wkill();  /* patience */     rfr_scr = TRUE;} /* partcopy *//* Grab, place a note to change all such notes in one part */void movenote(vind)   Index   vind;     /* clicked note/rest */{     NOTE      tnote;     Index     lind, rind, tind;     sexy      newpmod, newslot, oldpmod, oldslot, mypart;     Reg EVENT *evp;/* The victim 'vind' is not permanently changed unless inside the block *//* First make sure it's a Note, nothing else counts! */     evp = i2p(vind);     if( !(mypart = evp->part))          return;/* Pickup existing note, always */     cpynote( &tnote, &(evp->show));     if( (oldslot = tnote.slot) == REST)          return;     oldpmod = tnote.pitmod;/* drag to new note slot */     if( !place(vind, evp, &tnote, FALSE)) { /* DRAG new note */          rfr_scr = TRUE;          return;     }     undind = -1;             /* invalidate undo */     newslot = tnote.slot;    /* Get place()'s results */     newpmod = tnote.pitmod;/* Check markers and user's wishes */     rfr_scr = FALSE;     if(fixmarx(&lind, &rind, &vind)) {     /* OK, do it! */          for(evp = i2p(lind); curind <= rind; evp = plusplus() ) {               if( (evp->part == mypart) && (evp->show.slot == oldslot)                 && (evp->show.pitmod == oldpmod) )               {                    rfr_scr = TRUE;                    evp->show.slot = newslot;                    evp->show.pitmod = newpmod;     }    }    }     if( !rfr_scr)          alert("Nothing moved.", 0);     rfr_scr = TRUE;     /* for Tools & Rep */} /* movenote() *//* Fcn to "smash" all the rests in a new bar's part with some*  (usually smaller) rest (maybe allowed to be a note).* Starts from rest clicked, until can't fit any more in bar.* Refuses to chip/bomb any Notes, even if killer is a note.* Will not work in Tacet or Cleared bars of a prt (what would you hit?),*   but is ideal for resizing Refilled bars.* Usage: get the desired size Rest on brush first.* Then "smasher" chisel becomes your cursor once selected.*//* Caller should verify that Brush Rep is appropriate */void smash(vind)  Index   vind;     /* Start hitting here */{     NOTE      rest;     Deltime   timeleft, restdur;     sexy      hilo, part;     Reg EVENT *evp;/* Part number of vind must be note or rest */     if( !(part = (evp = i2p(vind))->part))          return;     patience();     cpynote(&rest, &brush);  /* makes code smaller, really! */     if(rest.slot != REST) {      /* Note; place height on staff */          hilo = parts[part].philo;          rest.slot = 4 + (Roffset(hilo) >> 1);     }/* Find time remaining till next Barline, or same-part Note, or End */     timeleft = evp->startime;     /* any type violation here? */     for( ; curind < nevents; evp = plusplus()) {          if(anybar(evp))               break;          if((evp->part == part) && (evp->show.slot != REST))               break;     }     timeleft=((curind==nevents) ? (Etime)length : evp->startime) - timeleft; /* Bombs away, Chips ahoy */     restdur = cod2raw(rest.dur, rest.durmod);     while((timeleft -= restdur) >= 0) {          qchip(vind, &rest, restdur, part);          rfr_scr = TRUE;     /* only if something happened */          vind = next(vind);          if(vind < 0)   /* in case last measure and no barline */               break;     }     wkill();  /* patience() */     if( !rfr_scr)          alert(" Nothing changed.", 0);} /* smash() *//* Join a note/rest to the next item in its part,*    if there is no time gap between them.*  This really could demand tied & same pitch, etc.,*    But for now let 'em play with loaded guns.* Returns TRUE iff it did anything -- assign to rfr_scr. */bool join(vind)  Index   vind;{     NOTE      savenote;     Time      fstart;     Deltime   raw1, raw2;     Etime     start1;     sexy      part, slot1, durmod1;     Index     nextind;     Reg EVENT *evp;     evp = i2p(vind);     if( !(part = evp->part))          return(FALSE);     start1 = evp->startime;     slot1 = evp->show.slot;     raw1 = cod2raw(evp->show.dur, durmod1 = evp->show.durmod);     if( (nextind = next(vind)) < 0)    /* last event of its Part */          return(FALSE);     evp = i2p(nextind);     if(evp->startime != (start1 + raw1))    /* Tacet gap between */          return(FALSE);     raw2 = cod2raw(evp->show.dur, evp->show.durmod);/* Bomb saves copy of 2nd note/rest */     fstart = fulltime(vind);     bomb(vind, NULL, &savenote, (Time)(raw1 + raw2));     savenote.slot = slot1;   /* Extend the 1st one's pitch! */     nextind = ghola(part, &savenote, durmod1, raw1 + raw2, fstart, TRUE);     fixup(vind, nextind, part, FALSE);   /* dead vind shud be close enuf */     return(TRUE);} /* join() *//* eof bt.c */