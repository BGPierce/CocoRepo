/* file BIN/BINIT.C   -13-    User's initializations; Layout Menu.    Prime candidate for swapping out in Coco III.** Version = 2-bits Level, 3-bits Score, 3-bits Revision* Level -- radical, like 640 screen.* Score -- older scores are invalid, tho probably compatible.* Revision -- new features, cleaned up code, etc.*/#define ZONES 1     /* enable nzones & zonedur in timesig() */#define PROMPTS 1   /* Back by popular request 90/9/5 */#include <stdio.h>#include <os9.h>#include <modes.h>#include "wmuse.h"#include "wmenu.h"#include "mencodes.h"#include "windows.h"#include "version.h"#include "vmem.h"#include "fcnptrs.h"#include "soowee.h"#define BILLPRY   140    /* Bill's task priority (higher in Play) */#define TOPFUDGE 0  /* Extra room for top staff, if nonzero *//* None of these arrays is R/O: */extern STAFF staves[NSTAVES];extern PART  parts[NPARTS + 1]; /* Parts are ORG 1, not 0! *//* This IS Read-Only! */extern CLEF  clefs[];extern EVENT zevent;extern sexy    instvals[NINSTRS];extern char    instnams[NINSTRS][10];extern char    filename[SFILENAME],               percsynth[24];extern ubyte   chans[NPARTS + 1],               levels[NLEVELS],               genvols[NLEVELS],               percmidis[17];extern bool    partens[NPARTS + 1],               chanens[16];extern direct Index     lftind, ritind, gind;extern direct short    nparts, nstaves,    xgoal, nbars, nzones;extern direct sexy    numer, denom, keysig, dencodur, secmin, transp, velo;extern direct ubyte    midinnmax, midinnmin;extern direct Time    length;extern direct Deltime     dendur, zonedur;extern NOTE    rep, qnote, qrest;extern direct bool    readonly, hires,    pldebug, rfr_scr, rfr_tit, tripper, compact, midiser, midipak;extern bool  /* Pick-filters 96-2-18 */     pickrest, picknote, pickplus, pickflag, pickupper, picklower, pickmid;bool      diskio(), timesig();      /* pre-dec */char      *index();/* Pre-decs of fcns for ptrs */char      keymouse(), inkey(), menukey(), charmaus(), gets();sexy      findstaff();int       printf(), sprintf(), owrite(), nfwrite(), gksig(), textmenu(),          soowee(), ievtinit(), addbars(), addclone(), repart(), pluspart();void      flush(), alert(), gtsig(), hitenter(), putmidi(), mflush(),          giveback(), findts(), fmarks(), menu(), fixup(), smfwrit(),          play(), tranpart(), drawnr(), clonemid(), partline();bool      pswap(), fixmarx(), yesno(), place(), parse(), mouce(), getempty(),          exprmenu();ubyte     *swapevts();Deltime   regen(), cod2raw();Index     enter(), remove(), chip();Time      fulltime(), figurst();EVENT     *makroom();/********** Fcns to open a new Official L2 window *//* #define NEEDINIZ 1 /* iff must INIZ a new WIndow */#ifdef NEEDINIZ/* Convert an OS9 minus-terminated string to C style, in-place */void stros92c(str)  char    *str;{     while(*str++ > 0)   /* '>' forces stop on \0 if already C */          ;     *(str - 1) &= 0x7F; /* un-minus last char */     *str = '\0';        /* for C */}#endif/* Open the next available Window as Type 5,*    switch stdin and stdout to it, select it */void windopen() {     /* char line[40]; */     struct registers regs;     int  path, cnt;     Reg char *who;/* Unrelated, but first make sure GrfDrv is loadable */     regs.rg_a = 0xC1;             /* 6809 System module */     regs.rg_x = who = "GrfDrv";     /* Try to LOAD the module, but without linking to it. */     if( _os9(F_NMLINK, &regs) != 0) {     /* 1st try Linking */          regs.rg_x = who;    /* must restore */          if( _os9(F_NMLOAD, &regs) != 0) {               puts("Need GrfDrv!");               exit(221);          }     }/* Open next free Window */     path = open("/W", 3);     if(path < 0) {          puts("Can't open /W, quit!");          exit(errno);     }#ifdef NEEDINIZ     strcpy(line, "iniz ");/* Get window's name ("Wn") into line + 5 */     regs.rg_a = path;     regs.rg_b = 0x0E;    /* SS.DevNm. p.8-115 */     regs.rg_x = line + 5;     _os9(0x8D, &regs);  /* GetStat */     stros92c(line + 5);     system(line);#endif/* New 95/9/12 stuff to use Real L2 Type 5 Window *//* Last 3 bytes are Fore, Back, and Border palettes */     if(write(path,"\x1B\x20\005\000\000\x50\x18\000\001\001\f",11) != 11)     {          /* puts("Can't DWSet!"); */          exit(1);     }/* Move stdio to new path while SELECTing new window.*  Must first select the old one, while straddling the I/O line*  with one foot in each set of paths (old & new). */     close(0);     dup(path);     if(write(1, "\x1B\x21\n", 3) != 3) { /* Must re-select old first */          /* puts("Can't plant foot!"); */          exit(2);     }     if(write(0, "\x1B\x21\f", 3) != 3) { /* New StdIn, not 'path' */          /* puts("Can't Select New!"); */          exit(3);     }     close(1);     dup(path);     close(2); /* stderr */     dup(path);     close(path);}/********* OS9 System Setups -- windows, pipes, etc. *****/void sysup() {    int     fpid, instd, inpipe;   /* for forking Fran *//* Open "real" buffer window.  Windopen() exits if no GrfDrv */     windopen();     /* puts("Forking Fran..."); fflush(stdout); *//* Diddle the pipes and spawn off Fran *//* Replace StdIn with Pipe */     instd = dup(0);     close(0);     inpipe = open("/pipe", 3);    /* read & write *//* Now we resemble Fran's desired state */     fpid = os9fork("Fran", 1, "\n", 1, 1, 0);     if(fpid < 0) {          puts("Can't fork Fran!");          sleep(2);          exit(37);     }/* Reverse the I/O redirections */     close(1);           /* stdout */     dup(inpipe);        /* Shud be 1.  Mustn't let pipe die! *//* Now both Std In & Out are the Pipe */     close(0);           /* inpipe */     dup(instd);         /* shud be 0 */     close(instd);       /* no longer needed *//* Now in own Umuse3 state -- StdOut == Pipe */     group = getpid();     setpr(group, BILLPRY);} /* sysup() *//* Only purpose is to give a target for frags' (*pputchar)() */void charput(ch)  char    ch;{     putchar(ch);}/* Quickie barinit() for end of score */int addbars() {     int  res;     gind = nevents - 1;     xgoal = 20;    /* 1/4 across screen */     res = Barinit(nevents-1, nbars+1, 3 + (4/numer), length );     if( !res)          alert(" No new bars!\n", 0);     else          rfr_scr = TRUE;     return(res);} /* addbars() *//********** Prompt user and initialize the basics */uinit() {     system("tmode -echo -pause");   /* tried 89/11/18, good *//* Fcn ptrs for use by Fragged swap-in subrs.*  These cannot be init'ed by cstart.r from bdp.c,*   nor can this code be "fragged" out (think about it :-) */     pmenukey = menukey;     pfixup = fixup;     pcharmaus = charmaus;     pfmarks = fmarks;     pfindts = findts;     pgivebac = giveback;     ptextmen = textmenu;     /* pfigurst = figurst; */     pputchar = charput;     pmflush = mflush;     pputmidi = putmidi;     psmfwrit = smfwrit;     pkeymaus = keymouse;     pgetempty = getempty;     pgets = gets;     pinkey = inkey;     ppswap = pswap;     pievtinit = ievtinit;     pswapevts = swapevts;     pflush = flush;     pprintf = printf;     psprintf = sprintf;     powrite = owrite;     pnfwrite = nfwrite;     pmouce = mouce;     pyesno = yesno;     palert = alert;     phit = hitenter;     pfixmarx = fixmarx;     pparse = parse;     pregen = regen;     penter = enter;     premove = remove;     pgtsig = gtsig;     pgksig = gksig;     pfulltime = fulltime;     pmakroom = makroom;     pplay = play;     ptranprt = tranpart;     pclonmid = clonemid;     psoowee = soowee;     paddbars = addbars; /* begin KP Editor */     paddclone = addclone;     pdrawnr = drawnr;     ppluspart = pluspart;     prepart = repart;     pchip = chip;     pcod2raw = cod2raw;     pexprmenu = exprmenu;     ppartline = partline;     pfindstaff = findstaff;     pickrest = picknote = pickplus = pickflag = pickupper       = picklower = pickmid = TRUE;    pldebug = FALSE;    compact = TRUE;    nevents = 0;    /* this is before main() fixes it to 1 */    secmin = 60;    velo = transp = 0;    setmouse();    vinit();/* Now done by newscore(FALSE) from bmuse.c *//*  ievtinit(EVTARSIZ - 2);    /* 93/4/16 */    gind = xgoal = 0;/* 90/02/11 */     strcpy(percsynth, "no synth named.");} /* uinit() *//* Major function to reset almost everything & start new score */void newscore(new)  bool    new; /* really make one, don't just init */{     Reg EVENT *evptr;     nevents = 1;     if(i2p(0))          strevent(curevp, &zevent);    /* formerly done in main() */     numer = denom = 4;     nparts = nstaves = keysig = 0;     secmin = 60;   /* OOPS!  added 90/5/5 v4.6.0A */     velo = transp = 0;    /* 90/9/5 *//* Don't re-init midinn-max/min here */     giveback();    /* save one page */     fgpart(1);     fgstaff(0);/* MUST init Events Page before clearing Titles in it! 96/2/20 */     ievtinit(EVTARSIZ - 2);     titleclr();    /* does NOT clear the Instrs table */     if(!new)          return;     *filename = '\0';   /* formerly done before the return */#ifdef PROMPTS     if(yesno("Would you like some Prompts\n  to begin score layout?"))          staffinit();#endif     Laymen(FALSE);      /* Graphics screen */     timesig();/* (Laymen() tells Alpha about your parts & staves) *//* Init events to Dth Rests in bars of N/D */     nbars = Barinit(0, 1, 8, (Time)0);/* Note: the new Grafix Setup Menu defines Time and opt'ly Key Signatures,*  but does not insert them into score.  That's our job here. *//* Put visible Time Sig right after 1st bar */     evptr = makroom(1);     evptr->startime = (Etime)0;     evptr->part = 0;     evptr->show.INCTYPE = TIMESIG;     evptr->show.TSNUMER = numer;     evptr->show.TSDENOM = denom;/* If initial non-zero Key Sig, throw that in too */     if(keysig) {          evptr = makroom(2);          evptr->startime = (Etime)0;          evptr->part = 0;          evptr->show.INCTYPE = KEYSIG;          evptr->show.KSN = keysig;     }} /* newscore() *//* Process time signature as given in numer and denom; * return judgment of its legality, and set values of * dendur, nzones (old nbeats), zonedur, and tripper. * Tripper is TRUE iff 6/8, etc. * All communication is via Global variables -- sorry!*/bool timesig(){     switch(denom) {     case 2:  dencodur = 2;   break;     case 4:  dencodur = 3;   break;     case 8:  dencodur = 4;   break;     case 16: dencodur = 5;   break;     default: return(FALSE);  /* Invalid denom */     }     dendur = 192 / denom;     tripper = (dencodur >= 4) && (numer >= 6) && !(numer % 3);     if(tripper) {          zonedur = 3 * dendur;          nzones = numer / 3;     }     else {          nzones = numer;          zonedur = dendur;     }     return(TRUE);   /* Valid denom */} /* timesig() *//* Also Called from Staves frag by fcn ptr */int gksig() {     char buff[BUFFSIZE];     wcreate(40-16-4, 120, 32, 4, TRUE, WSDOUBLE);     printf("Type number of Sharps (1 to 7)\n");     printf("  or negative  Flats (-1 to -7)\n");     printf("  or ENTER for neither: ");     gets(buff);     keysig = atoi(buff);/*   printf("%c%c\n", SKS, keysig); */     wkill();  flush();     return(keysig);}/* Also Called from Staves frag by fcn ptr *//* Prompt timesig from user; check its validity */void gtsig(){     char      buff[BUFFSIZE], c;     Reg char  *cp;     wcreate(40-16-4, 120, 32, 5, TRUE, WSDOUBLE);     printf("Time Sigs are written N/S\n");     printf("  N is Number of beats per bar\n");     printf("  S is note_Size of a beat.\n");     while(TRUE) {          printf("\nYour Time Sig N/S: ");/* Hand-job next line, to avoid linking bulky scanf() code *//* scanf("%d/%d", &numer, &denom);  getchar(); */          gets(buff);          if(*buff) {               numer = atoi(buff);               if(numer <= 0)  numer = 1;               if(numer > 31) numer = 31;               if( !(cp = index(buff, '/')) )                    continue;               denom = atoi(cp + 1);          }/* Even if just ENTER, make sure old values are good */          if(timesig())               break;          bell();          printf("S must be 2, 4, 8 or 16.\n\n");     }     wkill();  flush();}/* Tell Fran about all "new" parts in range given */void dfalprts(from, to)  sexy    from, to;{     sexy p, s, sty, hilo, lownote;     for(p = from; p <= to; p++) {          s = partstaff(p, &sty, &lownote, &hilo);          dfpart(p, s, hilo, FALSE, FALSE, 0);     }}/* Likewise tell about staves in range */void dfalstvs(from, to)  sexy    from, to;{     sexy s;     for(s = from; s <= to; s++)          dfstaff(s, staves[s].clef_no, staves[s].staffY);}#ifdef PROMPTS/* Old Setup-Prompts sequence for U compatibility */staffinit() {     char buff[BUFFSIZE];     PART  *partptr;     short npg,          /* no. part [group]s for a staff */          n, p,          cn,            /* clef no. */          ppg,           /* part within a group */          vn;            /* voice no. */     Reg STAFF *stptr;/* User-specified custom setup */    text();    while(TRUE) {   /* loop to repeat setup if rejected */          nparts = 0;          stptr = staves;          partptr = parts + 1;          for(nstaves = 1; nstaves <= NSTAVES; nstaves++,stptr++) {               cn = askclef(nstaves);               if(cn < 0)                    break;    /* setup tentatively done */               stptr->clef_no = cn;/* Straight one part == one voice code.* here npg = "no. parts given" for this staff. */               printf("1, 2, or 3 Parts on Staff #%d? ", nstaves);               if( !(npg = onehex() & 3) )                    npg++;               for(vn = 1; vn <= npg;  vn++, partptr++) {                    if(++nparts > NPARTS)                         goto toomany;                    partptr->pstaff = nstaves - 1;          /* Code set up for 1 - 3 part groups.  SOLO == MIDDLE */                    partptr->philo = (npg==1) ? SOLO                      : (vn==1) ? UPPER                      : (vn==npg) ? LOWER : SOLO;               } /* vn loop */          } /* nstaves loop */          if(nstaves > NSTAVES)               printf("\n(All %d Staves used.)\n", NSTAVES);          nstaves--;    /* always will be one too high */        toomany:  if(nparts > NPARTS) {               printf("\n**Over the %d-Part Limit.\n", NPARTS);               nparts--;    /* this is normally correct */          }/* Adjust Y-spacings for various numbers of staves. */          styinit();/* Print summary of staff-part setup */          showlay();          if(yesno("Is this setup OK? "))               break;     } /* setup attempts while loop */     wkill();  /* grafix(); */} /* staffinit() *//* Subr to select a Clef for staff s.*  Auto'ly figures out how many Clef types there are in clefs[].*  The c listed to user and typed by him is 1 greater*  than that returned and used to index the array.*  Therefore ENTER returns -1, meaning invalid.*/short askclef(s)  sexy s;{    short c, u;    char ch;    Reg char *str;    putchar(014);   /* CLS */    for(c = 0; ; ) {        if( ! *(str = clefs[c++].clefname) )            break;        printf("%3d - %s\n", c, str);    }    while(TRUE) {        printf("\nClef for Staff #%d: ", s);        u = onehex();        putchar('\n');        if(u <= c)            return(u - 1);        printf("  Off list, try again;\n");    }}/* Adjust Y-spacings for various numbers of staves.*  Later fix this to consider  # parts on each staff, etc.*/void styinit() {    sexy  n, dy;    Reg STAFF *stptr;    dy = (SCORTOP-SCORBOT-TOPFUDGE-(nstaves < 4 ? 20 : 0)) / (nstaves + 1);    for(n=0, stptr=staves; n < nstaves; n++)        (stptr++)->staffY = (SCORTOP -TOPFUDGE - 8) - (n + 1) * dy;} /* stinit() *//* List parts, groups and staves */showlay() {     sexy      p, s, hilo, lownote;     short     y;     char      c;     printf("\014S Hgt  Clef    Parts up/mid/dn\n");     printf(    "- --- ------   ---------------\n");/*               s yyy Guitenor Pu Qm Rd Tu Vm *//*              %d %3d %-8s       %c%c     */     for(s = 0; s < nstaves; s++) {          printf("%d %3d %-8s",  s + 1, staves[s].staffY,            clefs[staves[s].clef_no].clefname);          for(p = 1; p <= nparts; p++) {               if(s == partstaff(p, &y, &lownote, &hilo) ) {                    c = (hilo & LOWER) ? 'L' : ((hilo & UPPER) ? 'U' : 'M');                    if(hilo & NOFLAG)                         c += ('a' - 'A');        /* make lower case */                    printf(" %c%c", i2hexc(p), c);               }          }          putchar('\n');     } /* for s */} /* showlay() */#endif    /* PROMPTS *//* eof BIN/BINIT.C */