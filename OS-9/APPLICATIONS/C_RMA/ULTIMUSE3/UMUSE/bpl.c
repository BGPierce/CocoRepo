/* BPL.C  Place() and related fcns to mouse-in a note.*  Got too big for old BS.C 960303.*/#include "wmuse.h"#include "keys.h"   /* for find() */#include <stdio.h>#include "vmem.h"#include "wmenu.h"#include "macros.h"#include "cursors.h"/* None of these arrays is R/O: */extern STAFF staves[NSTAVES];extern PART  parts[NPARTS + 1]; /* Parts are ORG 1, not 0! *//* This IS Read-Only! */extern CLEF  clefs[];extern direct short     xyoff, nparts,     numer, denom, nbars, nstaves;extern direct Index     lftind, ritind, lastclik;extern STAFF   staves[];extern ubyte    grafxes[], grafyes[], chans[];extern direct bool     rfr_rep, rfr_scr, aborted, pitcarry;extern sexy     pickpart;extern bool    /* Filters -- not direct */     pickrest, picknote, pickplus, pickflag,     pickupper, picklower, pickmid;extern direct Deltime     dendur;extern direct sexy     curcurse;extern short durtable[4];extern bool    partens[];/* Some exter fncs, some pre-decs: */bool      mouce(), anybar(), place(), markin(), doit();Time      fulltime(), figurst();Index     finder(), enter(), next(), pnext();Deltime   cod2raw();/***** Normalize Naturals to 4, and Nothings to 0 **/sexy pmodfix(pm)  sexy    pm;{     pm &= 7;     if(pm == 1)          return(0);     if(pm == 5)          return(4);     return(pm);}/**** Decide whether a note can have another note pulled out of it* by the CPLUS cursor 95/5/22, 96-2-20;* If so, return winning pat number, else 0 (FALSE).*/sexy pluspart(ind)  Index  ind;  /* Coco MUST pass Index, not ep */{     sexy      part, staffno, dummy, hilo, pi, opart, ohilo, ostaffno;     Etime     now;     Deltime   mydur;     Reg EVENT *evp;/* Must find a no-flag part on same staff with same stem direction,*  such that nothing in that part would overlap new note. */     evp = i2p(ind);     part = evp->part;     now = evp->startime;     mydur = cod2raw(evp->show.dur, evp->show.durmod);     staffno = partstaff(part, &dummy, &dummy, &hilo);     for(pi = 1; pi <= nparts; pi++) {          if(pi == part)               continue;          ostaffno = partstaff(pi, &dummy, &dummy, &ohilo);          if( !(ohilo & NOFLAG) || (ostaffno != staffno)            || ((ohilo ^ hilo) & (UPPER | LOWER)) )               continue;     /* Test for room in this part.  Not easy! */     /* Look left, to 1st note/rest *//* Re-use 'evp' for scout, have all its desired info */          for(evp = i2p(ind - 1); curind > 0; evp = decdec() )               if(evp->part == pi)                    break;          if( (curind > 0)            && (cod2raw(evp->show.dur, evp->show.durmod) + evp->startime >now))               continue;     /* failed, try next part */     /* Look right */          for(evp = i2p(ind + 1); curind < nevents; evp = plusplus() )               if(evp->part == pi)                    break;          if( (curind < nevents)            && ( (now + mydur) > evp->startime) )                 continue;     /* failed */          return(pi);          /* Scored! Blow loop and fcn! */     }     return(0);          /* ran out of loop, failed */} /* pluspart() *//* Install a new, Cloned Part, subject to user's desire*  and availability.  Return new part no. or 0 if failed. */sexy addclone(staf, hilo)  sexy     staf;  sexy     hilo;{     sexy     nupart;     if( !yesno("Out of Clone parts; Add another?"))          return(0);     if(nparts >= NPARTS) {          alert("Sorry, out of Parts!", 0);          return(0);     }     nupart = ++nparts;     parts[nupart].pstaff = staf;     parts[nupart].philo = hilo | NOFLAG;     partens[nupart] = TRUE;     clonemid(nupart, nupart, chans);     return(nupart);} /* addclone() *//* Given an index, part, and ptr to a pitmod, find immediately preceding* (to left) note (not rest) of given part, and return its slot and pitmod.* If hit 0, return Rest and Null.* Separate index and part in case cloning has advanced part via pluspart().* Use for carryover and keypad 'R' command. */sexy repart(ind, p, pmodp)  Index     ind;  sexy     p, *pmodp;{     bool hitbar = FALSE;     Reg EVENT     *bep;     if(p) {          for(bep = i2p(ind-1);  curind >=0;  bep = decdec() ) {               if( !bep->part && (bep->show.slot <= FINE))                    hitbar = TRUE;               if( (bep->part == p) && (bep->show.slot != REST) ) {                    *pmodp = hitbar ? bep->show.pitmod : 0;                    return(bep->show.slot);                    }          }     }/* Failure */     *pmodp = 0;     return(REST);} /* repart() *//******** Mouse abort tester and screen-state switcher.* Abort-option if mouse dragged to lower left corner.* Must be used inside a while(mouce()) loop.* Voodoo bug in C compiler (?) often jams TRUE into Bool return,*  so just call void-ed fcn and use global 'aborted'. 91/9/29  */void abortest(x, y)  short   x, y;{     if((x < 6) && (y < 6)) {          if( !aborted)               givabort(aborted = TRUE);     }     else {          if(aborted)               givabort(aborted = FALSE);     }/*   return(aborted);    /* illegal in Haiti and N.O. */}/********* Place a note on staff by dragging mouse.* If new note is a Rest, skip mouse action.* Return note's slot & pitmod inside the given note*.** 87/3/6  Added preservation of slot & pitmod.* 95/2/27 Add CPLUS, treat it like CBRUSH if Brush is note and Victim is Rest.* 95/6/17 Add new Part if needed for CPLUS.*         Also carry over previous note pitch (option).*/bool place(ind, ep, brnote, doplus) /* TRUE if not aborted */  Index   ind;      /* ASSUME same as *ep */  EVENT   *ep;      /* Event to be changed */  NOTE    *brnote;  /* To hold changes, usually Menu's Brush_Rep */  bool    doplus;   /* Really do act like CPLUS cursor */{     EVENT    evtemp;    /* for creating Plus-part */     bool     stemdn;     sexy     ourstaff;     sexy     notex, notey, whyte, owhyte, staffy, grind;     sexy     vslot, nuslot, whoff, initpmod, pitx, opitx, pitoff, diffy;     sexy     part, nupart, botnote, hilo, mx, my;     aborted = FALSE;     CopyObjP(&evtemp, ep);   /* victim */     vslot =  ep->show.slot;  /* victim's *//*   doplus= (curcurse==CPLUS) && ((vslot != REST) || (brnote->slot!=REST)); */     grind = ind - xyoff;     notex = grafxes[grind];     notey = grafyes[grind] & 255;     part = ep->part;     ourstaff = partstaff(part, &staffy, &botnote, &hilo);     stemdn = Stemway(hilo, vslot);/* Erase existing note/rest by drawing in BACKground color */     drawnr(&ep->show, notex, notey, staffy, stemdn, hilo & NOFLAG, BACK);/* If Plus, restore it and do lots of other stuff */     if(doplus) {          drawnr(&ep->show, notex, notey, staffy, stemdn, hilo & NOFLAG, FORE);          if( (nupart = pluspart(ind)) ) {               part = nupart;      /* for most-recent note carryover */               hilo |= NOFLAG;     /* in case pulled out of a flagship */          }          else {               rfr_scr = FALSE;               nupart = addclone(ourstaff, hilo);               if( !nupart)                    return(FALSE);               alert("Part added.  Now try it.", 0);               return(FALSE);     /* user will try again */          }          ep = i2p(ind); /* restore after pluspart() */     } /* doplus */     /* If new one is Rest, get to leave early */     if(brnote->slot == REST) {          if(doplus)               return(FALSE);          notey = staffy + Roffset(hilo) + 8;          drawnr(brnote, notex, notey, staffy, FALSE,FALSE, FORE);          flush();          while(mouce(&mx, &my))     /* Abort option */               abortest(mx, my);          if(aborted) {               givabort(FALSE);               return(FALSE);          }          grafyes[grind] = notey;          return(TRUE);     }/* New event on brnote is a Note *//* 'whyte' indexes a range of 32 notes where 15 is center line of any staff. * But 'slot' is 0 at bottom staff line, so less by 11.** Optionally init slot & pitmod to most recent note in part,*   if laying note over rest or note over pluspart 95/6/17.*/     opitx = owhyte = 0;     /* force 1st drawing *//* Read mouse to init Pitoff and Slotoff */     mouce( &mx, &my);     pitx = mx >>4;      /* Was 3 */     initpmod = ep->show.pitmod;     /* Victim's, may change below */     if(doplus || (vslot == REST) ) {          if(pitcarry) {     /* Look up most recent pitch of that part */               vslot = repart(ind, part, &initpmod);               ep = i2p(ind); /* restore */          }          if(vslot==REST)     /* includes repart()'s failure */          /* just start note in rest's position */               vslot += (4 + (Roffset(hilo) >> 1));     }     whyte = vslot + 11;      /* init */     whoff = (whyte - (my >>2) ) & 31;  /* Constant thruout call */     pitoff = (initpmod - pitx) & 7;   /* Mod 8 */     getnback();    /* Save surrounding scenery *//* MAIN LOOP *//* Read mouse for new note; quit if fire button released */     while(mouce(&mx, &my)) {       /* Check for pitx or sloty (whyte) changes */          whyte = ((my >>2) + whoff) & 31;          pitx =  mx >>4;     /* Was >>3 */          if((whyte == owhyte) && (pitx == opitx))               continue;          opitx = pitx;       owhyte = whyte;          abortest(mx, my);          if(aborted)               continue;/* Update Pitch Modifier */          brnote->pitmod = pmodfix((pitoff + pitx) & 7);/* Restore original scenery (erasing last position), draw new note */          putnback();          nuslot = whyte - 11;     /* pre-do for Macro below */          stemdn = Stemway(hilo, nuslot);          notey = staffy + nuslot + nuslot;          drawnr(brnote, notex, notey, staffy, stemdn, hilo & NOFLAG, FORE);          flush();     } /* main loop */          if(aborted) {         givabort(FALSE);         return(FALSE);     }/* Done.  Update 'brnote' and return */     brnote->slot = whyte - 11;  /* in case nuslot never computed */     rfr_rep = TRUE;/* If Plus, must insert new note and update it;*  set rfr_scr so show() will update grafxhes[].* Coco3: Later don't update rfr_scr, zap graxyes[] urself.  */     if(doplus) {          ind = enter(fulltime(ind), nupart, brnote->slot);          if(ind < 0)               return(FALSE);          CopyNoteP(&(i2p(ind)->show), brnote);/* To avoid annoying screen redraws while cloning chords,* sneak a cloned note into grafx/yes[] without rfr_scr:* already know 'notex', and have 'notey' from the placer loop.* Have new 'ind' from enter(); find the 'grind' for that.* From new index to ritind, bubble up grafx/yes[], then ritind++.* Slip new note's x and y into grafx/yes[new_grind.* Recycle 'whoff' for temp grind variable.*/          grind = ind - xyoff;          for(whoff = ritind - xyoff; whoff >= grind; whoff--) {               grafxes[whoff+1] = grafxes[whoff];               grafyes[whoff+1] = grafyes[whoff];          }          ritind++;          grafxes[grind] = notex;          rfr_scr = FALSE;     } /* doplus */     grafyes[grind] = notey;  /* in case showall() unused */     return(TRUE);} /* place *//* eof bpl.c */