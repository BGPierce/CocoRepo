/* file ~Vm640/BMUSE.C  -2-*  Main prog for UltiMusE MIDI Score Editor* 90/2/19  Bi-level Toolbox*/#define SHARE 1#include <stdio.h>#include "wmuse.h"#include "wmenu.h"#include "vgraf.h"#include "cursors.h"#include "screen.h"#include "wwidths.h"#include "tools.h"#include "vmem.h"#include "macros.h"#include "soowee.h"/* Mouse click timing thresholds */#define QUICK       7         /* was 9 960302 */#define PICKWAIT    QUICK     /* n/60 sec for Pickup-->Place() *//* #define TOOLWAIT 15        /* n/60 sec for Rep to drag Tools */#define LONGWAIT    13        /* was 15 960302 */#define SLIDEWAIT   LONGWAIT  /* MM/1 uses QUICK */#define DUBCLICK    10        /* Time threshold, 1/3 sec at 30 samples/sec */#define REPEATWT    50        /* To bypass mouse release */#define CLEFLEFT    2    /* 1st char col of clefs */#define UPARROW     12   /* Coco3 keyboard byte codes */#define DNARROW     10extern int     tooly;extern EVENT     zevent,        /* initial Barline 0 */     undevent;      /* saves deletands for "undo" */extern STAFF   staves[];extern PART    parts[];extern ubyte        grafxes[], grafyes[];extern direct ubyte midinnmin, midinnmax;extern direct byte  accentwt;extern direct sexy     forergb, backrgb,   /* palette settings */     uptime, dntime,     /* mouse click timers */     curcurse,           /* current cursor type */     broke;              /* BREAK intercept control */extern direct short      nstaves;  /* must stay 16 bits */int  breaker();          /*   and interceptor fcn */char barmice();bool inrect();sexy addbars();extern direct Index     gind, lftind, ritind, undind;extern direct int     xgoal, xyoff,     nbars, numer, nzones, denom;extern direct Deltime     dendur;extern direct Time     length;extern NOTE     brush, qnote;extern direct bool     hires, left, midiser, midipak, mididev, instren, clocken, midievts,     readonly, automon, aborted, snap,     rfr_rep, rfr_scr, rfr_men, rfr_bar, rfr_tit; /* refresh/redraw flags */extern bool     toolson;extern char     filename[];extern byte     bcluzis[];Time figurst();/* bool exprmenu(), barmen(); */main(argc, argv)  int     argc;  char    **argv;{    char    buff[SFILENAME+1], *cp;       /* for main menu */    NOTE    notemp;    int     flashtime = 0;    sexy    mtype;    Index   thisind, mind;   /* event indices */    Etime   thistime;    sexy    thispart;        /* parts (voices) */    Deltime newdur, tdur, oldmin;    /* raw duration times */    sexy    newkeys, oldkeys;   /* SHIFT, CTRL stuff */    sexy    hilo, botnote;      /* for artic re-drawings */    bool    stemdn, doplus;    sexy    brushx, brushy, mxc, oldcurse;    short   i, staffy;    int     oldx, oldy, fire, dumxy, mx, my;   /* mouse stuff */    char    char1;    NOTE    *brp;    Reg EVENT   *thiseptr;/* Phase 0 inits *//* Enable BREAK and ^C interception ASAP */     broke = 1;     intercept(breaker);     stdout->_flag |= _RBF;    /* faster pipe? */     /* fprintf(stderr, "Um3...\n"); /* draw BREAKS to self */     sysup();       /* spawn off Fran *//* Turned off following 95/3/21 *//*   system("load Um3Play");   /* reduces crash odds? *//* Phase 1 inits -- clears and Defaults */CopyRt:        /* Total Restart comes here */     instinit();     *filename = *buff = '\0';/* Anything in Pref Init File must be init'ed here, plus other items */     instren = midievts = clocken = midiser = readonly = TRUE;     automon = rfr_tit = midipak = mididev = FALSE;     midinnmin = 13;     /* 32' C */     midinnmax = 108;    /* top of piano */     accentwt = 12;     left = hires = -1;  /* funny Bool to mean not yet defined */     forergb = 0x01;     /* Navy Blue */     backrgb = 0x18;     /* Medium Cyan *//* Phase 2 -- Read User Preferences file 1st, so Args can override it */     prefio('r');        /* currently in randmen.c */     pal(0, backrgb);    /* Colors aren't cmd-line spec'able */     pal(1, forergb);/* Phase 3 -- Process cmd line args.  Flags can have own '-' or share some. */     for(i = 1; i < argc; i++) {          cp = *(argv + i);          if(*cp == '-') {  /* Collect the goodies */               while(char1 = *++cp) {                    switch(char1) {/*                    case 'h':                         hires = TRUE;                         break;                    case 'l':                         hires = FALSE;                         break;                    case 'L':                         left = TRUE;                         break;                    case 'R':                         left = FALSE;                         break;*/                    case 'p':                         midiser = FALSE;                         midipak = TRUE;                         break;                    case 'r':                         readonly = TRUE;                    }               }          }          else {     /* no '-' in arg; assume filename */               if(! *filename) {                    strcpy(filename, cp);               }               else {                    strcpy(buff, cp);               }          }     } /* argc loop.  Got all the cmd args *//* Phase 4 -- user score defaults */    uinit();   /* this Zeroes nevents */    newscore(FALSE);     /* DON'T permit empty data 89/10/02 */#ifdef SHARE     if( !curcurse)          hitenter();    /* make 'em stare at begging */#endif    wkill();   /* Fran's autonomous SignOn/Copyright menu */    yclear(0,HM1);/* Phase 5 -- read score if given as arg, else Startup Menu */     curset(CARROW);     if(*filename)  {    /* at least one file arg */          if(Diskio(filename, FALSE, 'u', FALSE, FALSE)) {               reinit();               if(*buff) /* 2nd file name */                    strcpy(filename, buff);          }          else {    /* can't read that file, start from scratch */               *filename = '\0';               iomen();          }     }     else {    /* No filename, use Startup Menu */          iomen();     }/* Phase 6 (Final) -- On to the Score Screen, you've earned it */    curset(CBRUSH);    brp = &brush;    cpynote(&brush, &qnote);    toolson = rfr_rep = rfr_scr = rfr_men = rfr_bar = TRUE;    undind = BADIX;    brushx = TOOLRGHT;     tooly = brushy = SCROLTOP;/* MAIN LOOP -- draw, read mouse, re-draw, ... */     for(;;)     {          if(rfr_scr) {               rfr_men = rfr_rep = TRUE;               wkill();     /* grafix();   /* for after BREAKs (?) */               dfalstvs(0, nstaves-1);     /* tired of phantom staves */               Showall('s');       /* now includes the yclear() */               mainbord();         /* Screen pretty border */               scroll();           /* 88/1/22 Update Scroll Bar */          }/* One-shot Title Banner on freshly read-in score */          if(rfr_tit)               titlesho();/* Draw top Menu Bar */          if(rfr_bar)               dmenbar();/* Draw the "ToolBox" Menu/Palette */          if(rfr_men && toolson)               drtools(brp->slot == REST, brp->durmod == 3);/* Refresh the "Representative Note/Rest", always saving bkground */          if(rfr_rep && toolson)               drawrep(brushx, brushy);/* Flash the Rep, short or long */          if(flashtime) {               if((curcurse==CBRUSH)||(curcurse==CSMASH)||(curcurse==CPLUS)) {                    drawrep(mxc - 1, clamp(oldy - REPHGT/2, 2, HM1-REPHGT));                    tsleep(flashtime);                    erasrep();               }               flashtime = 0;          }/* Dues paid, consume all flags */          rfr_scr = rfr_rep = rfr_men = rfr_bar = rfr_tit = FALSE;/***************************************************** Screens all refreshed, wait for keys or mouse click.* But first make user release mouse from last usage,*   or let him out after REPEATWT.*/        while(mouce(&oldx, &oldy))            if(dntime > REPEATWT)                break;/* "Held down but hitting nothing" loops thru here *//* Draw initial cursor, to be instantly erased below */slide: cursor(oldx, oldy);   /* draw *//* Ground-State Loop: Push cursor around while awaiting the mouse button */          automouse(TRUE);          newkeys = 0;          do {               oldkeys = newkeys;               newkeys = keysense();               fire = mouce(&mx, &my);               if(snap) {     /* Magnetic Cursor-Snap */                    int       tempy;    /* funny car */                    if((mind = find(mx, my, 0, TRUE)) >=0) {                         mx = grafxes[mind - xyoff] <<3;                         tempy = grafyes[mind - xyoff] & 255;                         if(tempy) {     /* Note or partwise, hit rt edge */                              my = tempy;                              mx += 7;                         }                         else               /* General, hit middle */                              mx += 3;                    }               } /* end cursor snap */               mxc = mx >> 3;          /* Column-wise mouse_x */               if((mx != oldx) || (my != oldy)) {                    cursor(oldx, oldy);        /* erase */                    cursor(mx, my);          /* draw */                    oldx = mx;    oldy = my;               }/* Keyboard char for Main Menu?  "else" keeps up cursor speed. */               else if(char1 = inkey()) {                    cursor(oldx, oldy);     /* new erase */                    goto topmen;               }               else                    tsleep(3);   /* Give other procs a shot */          } while(!fire);       /* Fall out when button pushed *//* Later classify click type here *//********** What is clicked mouse pointing to? *********//* New "universal" cursor erase, so cases can change type.* BELOW THIS LINE, CURSOR IS NOT SHOWING!*  All old cursor erases are retained inside comments.*/          cursor(oldx, oldy);   /* new erase */    /*** Inside Brush_Rep?  No Double-Clicks here. */          if(toolson && inrect(mxc,my, brushx,brushy, REPRB, REPTOP))          {               tsleep(LONGWAIT+1);  /* Quick or drag click? */               if(mouce(&dumxy, &dumxy))    /* Long click, still holding */               {/* Drag toolbox */                    int diffy;                    diffy = my - tooly;                    Clear(TOOLEFT, tooly, REPRB+2, REPTOP+1);                    while(mouce(&mx, &my)) {                         if(my == tooly + diffy)                              continue;                         Clear(TOOLEFT, tooly, REPRB+2, REPTOP+1);                         tooly = clamp(my - diffy, 2, HM1-4-REPHGT);                         brushy = tooly;                         box(TOOLEFT, tooly, REPRB, REPTOP+1);                    }                    rfr_scr = rfr_bar = TRUE;                    brushx = TOOLRGHT;               } /* drag toolbox */               else /* if(dntime <= LONGWAIT) */ {     /* Quick click */     /* Turn off Tools and Rep */                    toolson = FALSE;                    rfr_bar = rfr_scr = TRUE;               } /* quick click */               continue;          } /* clicking on Rep */                /*** Inside ToolBox? ***/        else if(toolson && inrect(mxc,my, TOOLEFT,tooly, TOOLRGHT,TOOLTOP))        {            i = (mxc - (TOOLEFT+1)) / PALW;      /* Which standard Cell? */            if(i >= NTOOLS)              /* off the menu, ignore */                goto slide;            rfr_rep = TRUE;            if(i >= TOOLBOXS) {        /* Marker pickup */                if((curcurse==CPARTCOPY) || (curcurse==CPARTFULL))                    partcopy('q');     /* 90/2/19 "Power Tools" on lower deck */                oldcurse = curcurse;                if(oldcurse==CPLUS)                    rfr_men = TRUE;     /* show truth, not brush */                if((my < TOOLHALF) && (i <= CSCREEN)) {                    curset(i + (CNTB-TOOLBOXS));                    if(curcurse==CPARTCOPY) {                         rfr_men = rfr_scr = FALSE;                         partcopy('i');      /* Init */                    }                    if(curcurse==CSCREEN) {                         curset(oldcurse);                         rfr_men = FALSE;                         filtmen();                    }                    continue; /* 97/4/4 */                }                else {     /* Upper deck, CPLUS and older stuff */                    curset(i + (CLEFTMARK-TOOLBOXS));                    if(curcurse==CPLUS) {    /* alternate the two */                       rfr_men = TRUE;                       if(oldcurse==CPLUS)                          curset(CBRUSH);                    }tie:                if(curcurse==CTIE)                       brp->artic = TIED;                }            }            else if(i==NRIO) {           /* toggle Notes -vs- Rests */rest:           brp->slot = (brp->slot==REST) ? 1 : REST;                rfr_men = TRUE;                curset(CBRUSH);            }            else if(i >= DMODS) {               if(my > TOOLHALF) {           /* a Durmod click */dots:                brp->durmod = i - DMODS;                     rfr_men = TRUE;         /* for triplets retention */                     curset(CBRUSH);               }               else {     /* Reserved Artics' space below Durmods */                    brp->artic = i - (DMODS-1);     /* TIED==0, count from 1 */                    curset(CLEG-1 + brp->artic);               }            }            else if(i <= NRPE) {   /* a Note Body click */body:           curset(CBRUSH);                brp->dur = i;        /* 'i' == .dur selected by user */                if(brp->durmod != 3)   /* Kill dots on new body */                    brp->durmod = 0;            }            else               continue;/* 88/1/7 Restrict dots on too-small or too-large notes */            if(brp->durmod != 3) {        /* Anyone can have triplets */                if((brp->dur==0) || (brp->dur==7))    /* Breve or 64 has */                    brp->durmod = 0;                  /*   no dots! */                if(brp->dur==6)           /* 32nd has  */                    brp->durmod &= 1;       /*   no double dots */            }/* for all the above, re-draw the Representative Note: */            rfr_rep = TRUE;            continue;        } /* inside ToolBox *//*********** Top Menu Bar ************//* Dupes bottom bar's <- and -> 90/3/23 */        else if( (my > SCORTOP+1) && (mxc > MENLEFT) && (mx < RBARP) ) {            if( char1 = barmice(mx) )                goto topmen;            goto slide;        }/***** SCROLL_BAR calls Main Menu or moves screen 100% left/right *****//* Click inside scrollbar for fast viewport jump */        else if( (my < SCROLTOP) && (mx > LBARP) && (mx < RBARP) ) {            gind = ((long)nevents * (mx - LBARP)) / (RBARP - LBARP);            xgoal = COLS/2;            rfr_scr = TRUE;            continue;        }/* Corner shuttles */        else if( (my > SCORTOP+1) || (my < SCROLTOP) ) {            if(mx < LBARP) {      /* Screen Full Left */fulleft:        gind = lftind;                xgoal = COLS;   /* right edge */                rfr_scr = TRUE;                continue;            }            if(mx > RBARP) {     /* Screen Full Right */fullrit:        gind = ritind;                xgoal = 0;    /* Add bars if pushing screen off Right end */                if(ritind >= nevents - 1) {                    addbars();                }                rfr_scr = TRUE;                continue;            }    /* if neither of the above, try Top Menu after some specials */            char1 = '\0';topmen:     rfr_rep = TRUE;     /* Set Markers and X-out from keys */               if(char1=='[') {                    curset(CLEFTMARK);                    continue;               }               if(char1==']') {                    curset(CRGHTMARK);                    continue;               }               if(char1=='^') {                    curset(CTOMARK);                    continue;               }               if(char1=='x') {                    curset(CXOUT);                    continue;               }               if(char1=='|') {                    curset(CBARLINE);                    continue;               }               if(char1=='&') {                    curset(CIMARK); /* Expressors */                    continue;               }               if(char1=='@') {                    curset(CSQUAWK);                    continue;               }               if(char1=='!') {                    curset(CSMASH);                    continue;               }               if(char1=='%') {                    curset(CJOIN);                    continue;               }     /* Toggle toolbox on 't' from barmice() */               if(char1=='t') {                    if(toolson = rfr_men = rfr_rep = !toolson) {                         tooly = brushy;     /* turn on & couple up */                         brushx = TOOLRGHT;                    }                    else {    /* Turn off tools, brush (already done above) */                         rfr_bar = rfr_scr = TRUE;                    }                    continue;               }/* Cheap version of keyboard note-body & other changes */     /* Durmod zaps 8 + code: Dot, Blank=Straight, and 3=Triplets */            if(char1 == '>')                goto fullrit;            if(char1 == '<')               goto fulleft;            flashtime = 20;     /* revoked if no gotos taken */            if((char1==8) || (char1==9)) {   /* Left or Right Arrow */                mx = (char1==8) ? 0 : 639;                goto half;            }            if((char1==UPARROW) || (char1==DNARROW)) {                i = ( ( ((char1==UPARROW) ? 1 : -1) + brp->durmod) & 3) + DMODS;                goto dots;            }            if((char1=='.') || (char1==' ') || (char1=='3')) {                i = (char1=='.') ? (DMODS+1)                  : ( (char1=='3') ? (DMODS+3) : DMODS);                goto dots;            }            if((char1=='0') || (char1==0xD))                goto rest;            if((char1 >= '1') && (char1 <= '8')) {                i = "12636574"[char1 - '1'] - '0';                goto body;            }            if((char1=='+') || (char1 == '=') ) {               curset((curcurse==CPLUS) ? CBRUSH : CPLUS);               rfr_rep = TRUE;               continue;            }            if((char1=='_') || (char1=='-')) {               if(curcurse==CTIE) {                  brp->artic = NORMAL;                  curset(CBRUSH);                  rfr_rep = TRUE;                  continue;               }               curset(CTIE);               goto tie;            }            flashtime = 0;    /* revoke it, no gotos taken */            if(mainmen(char1))                break;            /* exit out of Main Loop */            continue;        }/* If hard against either side, move screen by 1/2 */half:   if( (lftind && (mx < 2)) || (mx >= 629) ) { /* 629 for LoRes mouse */            if(mx >= 629)                gind = ritind;            else {                if(lftind)                    lftind--;                gind = lftind;            }            xgoal = 40;      /* center */            rfr_scr = TRUE;            cursor(oldx, oldy);    /* redraw */            continue;         }/* Score items are only thing left -- find one */          thisind = find(mx, my, oldkeys | newkeys, !snap);          if(thisind < 0) {      /* Hit nothing *//* Move a staff if hitting its Clef  89/2/11 *//* GOOD THING TO MOVE OUT TO BT.C */               if((mxc >= CLEFLEFT) && (mxc < CLEFLEFT+CLEFWID-1)) {                    int  s, diffy, clf; /* funny cars */                    if((s = findstaff(my)) < nstaves) {   /* Success */                         staffy = Ystaff(s);                         clf = staves[s].clef_no;  /* Parnas ain't lookin */                         diffy = my - staffy;                         Clear(1, staffy - 7, 78, staffy + 16 + 4);                         while(mouce(&mx, &my)) {                              if(my == staffy + diffy)                                   continue;                              Clear(1, staffy - 7, 78, staffy + 16 + 4);                              staffy = my - diffy;                              staffy = clamp(staffy, 8, HM1-16-8);                              staff(staffy, TRUE, clf);                         }                    /* Update official StaffY */                         Ystaff(s) = staffy;      /* works with macro! */                         dfstaff(s, clf, staffy);                         rfr_scr = rfr_men = rfr_bar = TRUE;                         continue;                    }               } /* drag staff *//* Hit Absolutely Nothing, period! *//* Classify Click as Quick, Double, or Long Drag */               if(dntime >= SLIDEWAIT)    /* already been here, dragging */                    goto slide;               tsleep(LONGWAIT+1);      /* or QUICK?? */               if(mouce(&mx, &my)) {     /* still held, or re-clicked */                    if(uptime > DUBCLICK)    /* held, get outta here */                         goto slide;    /* old "eek" */                    /* else double */               }          /* else released, tho maybe quick-doubled *//* Turn Tools & Rep on iff Double Click; flash Rep if Single Quick */               if((uptime + dntime) >= LONGWAIT) {  /* Single click, Flash */                    if((curcurse==CBRUSH) || (curcurse==CPLUS)                      || (curcurse==CSMASH)) {                         flashtime = 18;                    }               }               else {    /* Double Click; bring up Toolbox here */                    brushy = tooly = clamp(oldy - REPHGT/2, 2, HM1-REPHGT);                    rfr_scr = toolson;  /* if relocating existing tools */                    toolson = rfr_rep = rfr_men = TRUE;                    brushx = TOOLRGHT;               }               continue;          } /* in score but hit nothing *//************* Hit an existing score item.  Keep target in same spot */        gind = thisind;        thiseptr = i2p(thisind);        thispart = thiseptr->part;        thistime = thiseptr->startime;        xgoal = grafxes[thisind - xyoff];/* Actions on score item, depending on "Brush" (Rep) *//* If brush is Marker, insert it or delete something */          if(curcurse==CIMARK) {      /* Inserter, special fcns */               if(rfr_scr = exprmenu(thisind)) {                    undind = BADIX;               }          }    /* [De-] Articulate Notes; does not reflect in the Rep */          else if((curcurse >= CTIE) && (curcurse <= CSTAC)) {               if( !thispart || ((i = thiseptr->show.slot) == REST) ) {                    bell();                    continue;               }       /* Agonize to get Artic symbol opposite note's stem */               partstaff(thispart, &staffy, &botnote, &hilo);               mxc = grafxes[thisind - xyoff];    /* "borrow" mxc, my */               my = grafyes[thisind - xyoff] & 255;               stemdn = Stemway(hilo, i)                 & (my > ( SCROLHGT + 15) );       /* Flip between artic'ed and "normal" */               drawart(BACK, mxc,my, thiseptr->show.artic, stemdn); /* erase */               if(thiseptr->show.artic == brp->artic) {                    thiseptr->show.artic = NORMAL;               }               else {                 drawart(FORE,mxc,my, thiseptr->show.artic=brp->artic, stemdn);               }          }/* 96/2/29 Deletes non-flag (clone) notes & rests;*  demotes flag notes to rests; won't delete flag rests. */          else if(curcurse==CXOUT) { /* delete Notes or Inclusions */               CopyObjP(&undevent, thiseptr);               rfr_scr = TRUE;               undind = thisind;               if( !thispart || (parts[thispart].philo & NOFLAG) ) {                    remove(thisind);     /* save for undo */               }               else {  /* Flagship Note -- special cases */                    if(thiseptr->show.slot == REST) {                         if(yesno("Really delete a Flagship Rest?"))                              remove(thisind);                         else                              rfr_scr = FALSE;                    }                    else {    /* Flagship Note -- convert to Rest */                         thiseptr->show.slot = REST;                         thiseptr->show.artic = NORMAL;     /* Do sort-notes on its clone group 98/7/29 */     /* This does prevent an UnDo, unforch. */                         for( ; curind != 0; thiseptr = decdec() )                              if(thiseptr->startime != thistime)                                   break;                         mind = curind + 1;                         for(thiseptr = i2p(thisind);                           curind < nevents; thiseptr = plusplus() )                              if(thiseptr->startime != thistime)                                   break;                         Notesort(parts[thispart].pstaff+1, mind, curind - 1);                    }               } /* flagships n/r */          } /* CXOUT *//* Insert a Marker, if legally non-slicing a chord */          else if((curcurse >= CLEFTMARK) && (curcurse <= CTOMARK)            && markin(thisind, curcurse + (LMARK-CLEFTMARK)) )                undind = BADIX;  /* markin() may also set rfr_scr */    /* New Tools */          else if(curcurse==CSMASH) {               smash(thisind);          }          else if(curcurse==CUPDOWN) {     /* If "staccato" click, ignore movenote */               tsleep(PICKWAIT+1);               if(mouce(&dumxy, &dumxy))   /* still holding, commit */                    movenote(thisind);          }          else if(curcurse==CSQUAWK)               squawk(thisind);          else if(curcurse==CJOIN)               join(thisind);          else if((curcurse==CPARTCOPY) || (curcurse==CPARTFULL))               partcopy('f', thisind);          else if(curcurse==CBARLINE)               markin(thisind, SINGLEBAR);/* Below here, only Brush (old Arrow) cursor (note/rest) */        if( (curcurse != CBRUSH) && (curcurse != CPLUS))            continue;/* Inclusion?  Give appropriate menu for further action */        if(!thispart) {            rfr_scr = anybar(thiseptr) ? Barmenu(thisind) : exprmenu(thisind);            if(rfr_scr)                undind = BADIX;            continue;        }/* Note or Rest *//* If "staccato" click, do Pickup, else Drag & Place *//* CPLUS always picks up even on Drag; unless Rest, then acts like CBRUSH */        tsleep(PICKWAIT+1);        if( ( (curcurse==CPLUS) && (thiseptr->show.slot != REST) )              || !mouce(&dumxy, &dumxy)) {     /* PICKUP, released already */            cpynote( &brush, &(thiseptr->show));         /* tsleep(5);   /* Lengthen cursor off-flash for user feedback */            rfr_men = rfr_rep = TRUE;         /* brp->artic = (brp->slot==REST) ? NORMAL : brp->artic; */            brp->artic = NORMAL;            brp->pitmod = 0;        /* keep these out of Rep *//* 960229 Flash Rep briefly to score good pickup */            if( !mouce(&dumxy, &dumxy)) {    /* if quick click */                flashtime = 4;     /* Really quick! */                continue;         /* even if CPLUS */            }        } /* pickup || CPLUS *//* Holding mouse, so drag new note type *//* Treat CPLUS like CBRUSH if Brush has note and victim is Rest. *//* Later allow small Brush rests to chip bigger victims? */          doplus = (curcurse == CPLUS)            && ((thiseptr->show.slot != REST) || (brp->slot == REST));          brp->artic = thiseptr->show.artic;          if( !place(thisind, thiseptr, &brush, doplus)) { /* DRAG new note */               rfr_scr = aborted;   /* redraw as-was if aborted */               brp->artic = NORMAL;               continue;          }          if( !doplus) {               newdur = cod2raw(brp->dur, brp->durmod);     /* Re-draw all if chip is not exact replacement */               rfr_scr =                 (newdur != cod2raw(thiseptr->show.dur,thiseptr->show.durmod));/* Rightward bomb/chip the chosen victim */               cpynote(&notemp, &brush);               chip(thisind, &notemp, newdur, thispart);          }          brp->artic = NORMAL;      /* un-Tie after each use */          brp->pitmod = 0;        /* don't distract user */          undind = BADIX;    }    /* for(ever) main loop */    argc = 1;    goto CopyRt;    /* 100% restart */ } /* main *//* Translate mouse hit on top Menu Bar into equivalent character.*  Must align this with barlabs[].*  NULL char means "never saw it"; Blank means Main Menu.*/char barmice(mousex) /* Convert menu bar mouse X into Main Menu char */  int     mousex;   /* in pixels */{    sexy    i;    i = (mousex - 8*MENLEFT) / (8*MENWID);    return( "floimt\007bpr" [i]);  /* note CTRL-G. */}/* eof ~Vm640/BMUSE.C */