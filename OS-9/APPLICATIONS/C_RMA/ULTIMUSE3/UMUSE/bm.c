/* BM.C  Marker-insertion fcn markin(), from BS.C */#include "wmuse.h"#include <stdio.h>#include "vmem.h"#include "wmenu.h"#include "macros.h"#include "cursors.h"/* None of these arrays is R/O: */extern STAFF staves[NSTAVES];extern PART  parts[NPARTS + 1]; /* Parts are ORG 1, not 0! *//* This IS Read-Only! */extern CLEF  clefs[];extern direct short     xyoff, nparts,     numer, denom, nbars, nstaves;extern direct Index     lftind, ritind;extern STAFF   staves[];extern ubyte    grafxes[], grafyes[], chans[];extern direct bool     rfr_rep, rfr_scr, aborted, pitcarry;extern sexy     pickpart;extern bool    /* Filters -- not direct */     pickrest, picknote, pickplus, pickflag,     pickupper, picklower, pickmid;extern direct Deltime     dendur;extern direct sexy     curcurse;extern short durtable[4];extern bool    partens[];/* Some extern fcns, some pre-decs: */bool      mouce(), anybar(), place(), markin(), doit();Time      fulltime(), figurst();Index     finder(), enter(), next(), pnext();Deltime   cod2raw();/********** Insert a Marker (L, R, T), given the index of the item* "found" by the Mouse.  Return TRUE if successful.  Rules:*   L and T Markers go to Left of item, R to Right.*   If item is Inclusion, that's simple.*   If item is Note|Rest, all Parts must start/end an event*     at the edge that the Marker goes on, i.e., a Marker*     may not "slice up" any Notes|Rests.*     The Marker goes to the left/right of the first/last*     note|rest of that startime.* 90/3 Patched to insert Single Barlines, as if Tmarks.* 91028 Barlines may Slice, and get fixup()'ed.*/bool markin(ind, mtype)  Index   ind;  short   mtype;{     bool      sliced;     Etime     stime;     Deltime   dtime;    /* temp, just to force Signed compares */     sexy      prt, realtype;     Index     ist, ubi;     Reg EVENT *evp;     if((realtype = mtype) == SINGLEBAR)          mtype = TMARK;     else {     /* Delete old marker (but not BAR) if any */          for(evp = i2p(ist = 0);  curind < nevents;  evp = plusplus() )               if( !evp->part && (evp->show.INCTYPE == mtype)) {                    remove(ist = curind);    /* also does the nevents-- */                    if(ist < ind)                         ind--;    /* Adjust index for deleted item */                    rfr_scr |= ((ist >= lftind) && (ist <=ritind));                    break;               }     }     evp = i2p(ind);     /* also inits the [ and ] loops later *//* Find where ("ubi") to put Marker, and is it legal? *//* If item is an Inclusion, can do */     if( !evp->part)          ubi = ind + (mtype==RMARK);/* Note|Rest, gotta work */     else {          stime = evp->startime;/* [, | or ] ? */          if((mtype==LMARK) || (mtype==TMARK)) {     /* Look Left for leftmost note/rest of this startime,      * or rightmost non-note.  Put its index in 'ubi'. */               for( ; curind >= 0;  evp = decdec() )                    if(!evp->part                      || ((dtime = evp->startime - stime) <0) )                         break;               ubi = curind + 1;      /* for the insertion */          }          else {  /* assume RMARK */     /* Look Right, find first event of greater startime.      * Save that startime for the test. */               for( ; curind < nevents;  evp = plusplus() )                    if((dtime = evp->startime - stime) > 0)                         break;               ubi = curind;               stime = (curind >= nevents)                 ? (Etime) figurst(nevents - 1) : evp->startime;          } /* left -vs- right markers *//* Test that no part has a note before 'ubi' whose endtime * is later than stime of new marker, so would get "sliced" */          sliced = FALSE;          for(prt=1; prt <= nparts; prt++) {               for(evp = i2p(ubi - 1);  curind >= 0;  evp = decdec() ) {                    if(evp->part != prt)                         continue;                    if( (dtime =  (Deltime)(stime - (evp->startime                      + (Etime)cod2raw(evp->show.dur, evp->show.durmod)))) < 0)                    {/* Barline or Marker will slice.  Now OK on Markers 960303, but risky --*  slicing Markers are much more dangerous than Barlines! */                         sliced = sliced || yesno( (realtype==SINGLEBAR)     ? " Barline will slice notes\n   and/or rests; Insert anyway?"     : " DANGER!  Marker will Slice\n   notes/rests!  Insert anyway?");                         if( !sliced)                              return(FALSE);                    }                    else                         break;    /* this part passed */               } /* inner for */          } /* outer for */     } /* inclusion -vs- note/rest *//* Insert it, making sure events[] has room */     if( !(evp = makroom(ubi))) {    /* does stime and nevents++ */       /* alert("\007**Out of Space!\n", 0); */          return(FALSE);     }/* evp should now point to events[ubi] */     evp->part = 0;     evp->show.INCTYPE = realtype;     if(realtype==SINGLEBAR) {          EvBarNo(evp) = 0;   /* doesn't show till renumbered */          if(sliced)               for(prt = 1; prt <= nparts; prt++)                    fixup(ubi, ubi, prt, FALSE);     }     return(rfr_scr = TRUE);} /* markin() *//* eof BM.C */