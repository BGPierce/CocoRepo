/* REORDER.C  begun 960305* Final capstone in the "plus/clone parts" package,*   this re-orders (re-numbers) Parts so that flagship*   parts precede their clone brothers.* Also parts on top staff come first, etc.*/#include "wmuse.h"#include "vmem.h"#include "macros.h"#include "fcnptrs.h"extern STAFF   staves[NSTAVES];extern PART    parts[NPARTS+1];extern ubyte   chans[NPARTS+1];extern bool    partens[NPARTS+1];extern direct sexy     nparts, nstaves;               /* Renumber Staves so #1 is on top, #2 next down, etc. */void renumber() {     STAFF     tstaff;     int       bs, ss, p;     Reg PART  *pp;     for(bs = 0; bs < nstaves; bs++) {          for(ss = bs+1; ss < nstaves; ss++) {               if(staves[bs].staffY > staves[ss].staffY)                    continue;               strdn(&tstaff, staves + bs, sizeof(STAFF));               strdn(staves + bs, staves + ss, sizeof(STAFF));               strdn(staves + ss, &tstaff, sizeof(STAFF));               for(pp = parts + nparts; pp > parts; pp--) {                    if(pp->pstaff == bs)                         pp->pstaff = ss;                    else if(pp->pstaff == ss)                         pp->pstaff = bs;               }          }     }} /* renumber() *//* Re-order (and renumber) parts so lowest nos on highest staff *//* Give choice of just one staff or all.  Later maybe stems up, or down *//* Interface between phases 1 and 2 & 3 is a simple permutation array --*  indexed by old partno, reads out new partno. */void reorder(sta, cloneback)  sexy sta;    /* Staff (0-7, not human) to reorder parts on.  -1, do all. */  bool cloneback;   /* Segregate clones to back of the bus (higher part nos) */{     PART     tparts[NPARTS+1];     ubyte    tchans[NPARTS+1];     bool     tpartens[NPARTS+1];     sexy     perms[NPARTS+1], old2news[NPARTS+1];     EVENT    tempbevt, tempsevt;     sexy     bp, bst,          /* "Base" part vars */              sp, sst,          /* "Scout" par vars */              vbp, vsp;          /* Virtual/Viewport part nos */     int      brate, srate;     /* "Ratings" for sort */     ubyte    hilos;     Etime    now;     Index    basex, sindex;     Reg EVENT  *evp;/* Phase 1 -- sort parts by staff, stem up/mid/down, flagged. */  /* Init the virtual viewpath perms[] array */     for(bp = nparts; bp; bp--)          perms[bp] = bp;/* Base vars must be updated inside inner loop since perms[bp] * changes dynamically.  Looks wasteful, but needed. */     for(bp = 1; bp < nparts; bp++) {          for(sp = bp + 1; sp <= nparts; sp++) {               vbp = perms[bp];               vsp = perms[sp];               bst = parts[vbp].pstaff;               sst = parts[vsp].pstaff;               if((sta >=0) && ((sta !=bst) || (sta !=sst))) /* skip this staff */                    continue;/* To do 3-level lexical sort, compute a "rating" for each part*  where lower values go with lower part nos,*  so rate stem-up and flag-having as lower, since better.*  Clone weight is most important if 'cloneback' is on, else least */               hilos = parts[vbp].philo;               brate = (bst << 3)                 | ((hilos & UPPER) ? 0 : ((hilos & LOWER) ? 4 : 2));               if(hilos & NOFLAG)                    brate += (cloneback ? 128 : 1);               hilos = parts[vsp].philo;               srate = (sst << 3)                 | ((hilos & UPPER) ? 0 : ((hilos & LOWER) ? 4 : 2));               if(hilos & NOFLAG)                    srate += (cloneback ? 128 : 1);               if(brate > srate) {          /* Compare ratings */          /* Exchange the two parts: bp and sp, within perms[] */                    brate = perms[bp];                    perms[bp] = perms[sp];                    perms[sp] = brate;               }          } /* inner, scout loop */     } /* outer, base loop */     /* OK.  Perms[] now maps new part nos into old,*  but we want to lookup old to get new, so invert perms[]. */     for(bp = nparts; bp; bp--)          old2news[perms[bp]] = bp;/* Phase 2 -- Update (permute) tables like parts[], chans[], partens[] */     strdn(tparts, parts, sizeof(parts));     strdn(tchans, chans, sizeof(chans));     strdn(tpartens, partens, sizeof(partens));     for(bp = nparts; bp; bp--) {     /* bp represents old part no */          vbp = old2news[bp];               /* vbp represents new one */          chans[vbp] = tchans[bp];          partens[vbp] = tpartens[bp];          strdn(parts+vbp, tparts+bp, sizeof(PART));     }/* Phase 3 -- in score, update parts and partwise expressors *//* Rewrite loop for 6809 */     for(evp = i2p(0); curind < nevents; evp = plusplus() )     {          if( (bp = evp->part) )               evp->part = old2news[bp];          else if( (evp->show.INCTYPE == LEVEL)            || (evp->show.INCTYPE == INSTR)            || (evp->show.INCTYPE == MCHOP)            || (evp->show.INCTYPE == IPEVT)            || (evp->show.INCTYPE == TPEVT)          )               evp->show.PARTNO = old2news[evp->show.PARTNO];     }/* Phase 4 -- re-sort score objects by part within time domains */     for(basex = 0; basex < nevents; basex++) {          evp = i2p(basex);          if( !(bp = evp->part))               continue;          now =evp->startime;          for(evp = i2p(basex+1); curind < nevents; evp = plusplus() ) {               if(evp->startime != now)                    break;               if( !evp->part)                    continue;               if(evp->part < bp) {     /* swap 'em */                    bp = evp->part;                    sindex = curind;                    CopyObjP(&tempsevt, evp);                    CopyObjP(&tempbevt, evp = i2p(basex));                    CopyObjP(evp, &tempsevt);                    CopyObjP(evp = i2p(sindex), &tempbevt);               /* now evp == i2p(sindex) and curind = sindex */               }          }     }} /* reorder() *//* eof reorder.c */