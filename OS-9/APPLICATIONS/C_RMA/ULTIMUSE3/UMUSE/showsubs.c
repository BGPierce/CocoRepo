/* ~VM640/SHOWSUBS.C  Subrs for fragged ShowAll() and Print() 89/6/5*//* #include <stdio.h> */#include "wmuse.h"#include "wcodes.h"#include "vmem.h"#include "macros.h"#include "screen.h"#include "fcnptrs.h"#define Print  (*pprintf)#define Write  (*pnfwrite)extern short durtable[4];extern direct sexy     nstaves, nparts;extern STAFF   staves[];extern CLEF    clefs[];extern PART    parts[];extern ubyte   grafxes[], grafyes[];extern direct char  *pctn1, *pctn2, *pctn6, *pct7;extern direct bool  halfstaf, dosqueez, doesff, automarg;extern ubyte   printype;/* "ArgBox" for faster piping to Fran.*  These MUST be kept contiguous and in order! */extern direct ubyte     arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7;/* Crap needed to force RLINK to link in pfdat347.r */extern char pfdat1[];char *pfdum() {   /* Just to link in pfdat stuff */     return(pfdat1);}bool ispwexpr(slt)  sexy    slt;{     return( (slt==INSTR) || (slt==LEVEL) || (slt==MCHOP)       || (slt==IPEVT) || (slt==TPEVT) );} /* Tests for any type of Barline; == testbar(evp, FALSE) */bool anybar(evp)  EVENT *evp;{    return( (!evp->part) && (evp->show.INCTYPE <= FINE) );}#ifdef NOPDRAW/* Pipe-optimized 90/5/26 to cut data rate from 6, 11 to 5, 6.*  Originals are in frags/*//********************************************************* Draw a note, of style passed in structure,* at coordinates XC and Y. * Does not fudge Rests' Y; that's showall()'s job.*/drawnr(what, gxc,gy, staffy, stemdn, noflags, color)  NOTE  *what;      /* the note to draw */  sexy  gxc,gy,      /* where to draw it */        staffy;  bool  stemdn,     /* stem direction: TRUE==down */        noflags,    /* Don't draw the flags on stem */        color;      /* T==draw or F==erase */{/** DUR: Br,1,2,4,8,16,32,64. Limit=0-7* DurMod: Null  .  ..  Triplet.  Limit=0-3* Slot: -11 to 20; 32==Rest* PitMod: as in PRE$ array* Artic: see above array.  0==Tied*//* These bounds tests are PHYSICAL, just avoid blowing up OS9 */     if((gxc < 2) || (gxc > COLS-2) || (gy < 5) || (gy > HM1-5)       || (stemdn && (gy < 12)) || (!stemdn && (gy > HM1-12)) )          return;          /* out of bounds, save time */     arg1 = color;     arg2 = gxc;     arg3 = gy;     arg4 = (what->dur << 2) | what->durmod;     if(what->slot == REST) {          arg0 = DRST;          Write(5); /* stdout arg supplied elsewhere */     }     else {          arg0 = DNOT;          arg1 |= what->pitmod << 3;          arg4 |= what ->artic << 5;          arg5 = staffy;           if(stemdn)     arg1 |= 2;          if(noflags)    arg1 |= 4;          Write(6);     }} /* drawnr() */#endif/**************** Draw Time Signature ******/drawts(notexc, numer, denom)  sexy  notexc, numer, denom;{/*   Print(pct4, DATS, notexc, numer, denom); */     arg0 = DATS;     arg1 = notexc;     arg2 = numer;     arg3 = denom;     Write(4);}/**** Draw Individual Inclusions -- any of the following: *//* Draw instrument/patch "I3" etc before its Part only. *//* Draw MIDI channel hop "M3" etc before its Part only. *//* Draw volume levels (mf, ppp, etc) as for instruments. *//* Draw Partwise Event as for Instrs */short drindiv(francode, notexc, prt, num)    /* returns noteY */  sexy    francode, notexc, prt, num;{     sexy hilo;     short y;       /* can't be Register due to &y call below */     if((prt < 1) || (prt > NPARTS))          return(HM1);        /* invisible, at top */     showstaff(prt, &y, /* &bn, */ &hilo);     y += 8 + Roffset(hilo);     arg0 = francode;    /* Note no special Fran code */     arg1 = notexc;     arg2 = y;     arg3 = num;     Write(4);     return(y);}/**** Draw GLobal Inclusion (at score top)  */drawgli(what, notexc, param1)  short   notexc;  sexy    what, param1;{     arg0 = DGLI;   /* actually has its own Fran code! */     arg1 = notexc;     arg2 = what;   /* GENVOL, NUTEMPO, CLOCKON, xSEVT, ACCENT, ... */     arg3 = param1;     Write(4);}drawlab(notexc, evp)     /* 940127 */  sexy    notexc;  EVENT   *evp;{     arg0 = DLAB;     arg1 = notexc;     arg2 = evp->show.LCHAR1;     arg3 = evp->show.LCHAR2;     Write(4);}drawcres(xc, level, beats, which)  sexy    xc, level, beats, which;{     arg0 = DCRS;     arg1 = xc;     arg2 = level;     arg3 = beats;     arg4 = which;     Write(5);}/******************** Convert dur & durmod codes to raw durations, using small table.* Raw durations of Breve: straight, dotted, double-dot, triplet.*/short cod2raw(cdur, cdurmod)  sexy    cdur, cdurmod;      /* cdur==0-7, cdurmod==0-3 */{     return(durtable[cdurmod] >> cdur);}/******************************** * Put given Inclusion code type on all staves. * Then draw BCD number with it if bcd nonzero. * For ordinary barlines, BCD is offset 0, -6 to go under staff; * but if NTHENDING, offset by +0,+20 to go above staff. * Putalst() is responsible for figuring what image(s) to use, *  where, how many byes wide, logic, etc.* CAUTION: BCD is 16 bits, sends two bytes as of 89/9/22.*/putalst(xc, type, bcd)  sexy    xc, type;  short   bcd;{/*   Print(pct5, DIAS, xc, type, *((char *) &bcd), bcd); */     arg0 = DIAS;     arg1 = xc;     arg2 = type;     arg3 = *((char *) &bcd);     arg4 = bcd;     Write(5);}/*************************** Draw key signature on each staff */drawks(notexc, ksn)  sexy    notexc, ksn;    /* # of sharps, negative for flats */{/*   Print(pct3, DAKS, notexc, ksn); */     arg0 = DAKS;     arg1 = notexc;     arg2 = ksn;     Write(3);}/* Type one phrase line of newline-term'ed text at given X, Y.*  Y is of ruler line; descenders go one below that;*    letters go from 4 above it.  Clears a line above that.*  If 'caps' is True, the line above and descender line are omitted.*/phrase(x, y, s, caps)  sexy    x, y;  char    *s;  bool    caps;     /* Capital letters only, for Menu Bar */{     Print("%c%c%c%c%s\n", PHRS, x, y, caps, s);} /* phrase() *//*** Open a Pat & Vanna overlay window ***/wcreate(leftcol, topy, colswide, rowshigh, dosave, style)  sexy    leftcol, topy, colswide, rowshigh, style;  bool    dosave;{     Print(pct7, OWST, leftcol, topy, colswide, rowshigh, dosave, style);     /* flush(); */}/*** Close above window type ***/wkill() {     Print(pctn1, OWEN);     (*pflush)();}alcurset(onoff)  bool    onoff;{     Print(pctn2, ACUR, onoff);     (*pflush)();}/* Clear entire width of screen between two Y limits to given color. *//* Actually Fran ignores the color, but needs the arg count */yclear(y1, y2, paint)  short y1, y2, paint;{     if(y1 < 0)     y1 = 0;     if(y2 < 0)     y2 = 0;/*   Print(pct6, CLR, 0, y1, 79, y2, paint); */     arg0 = CLR;     arg1 = 0;     arg2 = y1;     arg3 = 79;     arg4 = y2;     arg5 = paint;     Write(6);} /* yclear() *//****** Draw all staves, using Fran's copy of data structures **/drstaves(xc, leftline)  sexy    xc;  bool    leftline;{/*   Print(pct2, DAS, leftline); */     arg0 = DAS;     arg1 = leftline;    /* yes, swapped order */     arg2 = xc;     arg3 = halfstaf;     Write(4);}/* Make Fran squeeze her current screen */squeeze() {     if(dosqueez)          (*pprintf)(pctn1, SQZ);     (*pflush)();}/* This also slips dosqueez and printer params to Fran */void sqdump(what)  char    what;{     if( !printype && (what != 'b'))          return;     (*pprintf)(pctn6, DMPS , what, printype, dosqueez, doesff, automarg);     (*pflush)();   /* 4/97 */}/* Parnasian interface; given Part No., returns the other items *//* Stripped down version of partstaff(), no lownote or istaff return */void showstaff(part, sty, /* lownote, */ hilo)  sexy  part;       /* INput; rest are OUTputs: */  short *sty;       /* staffY *//* sexy  *lownote;  /* clef.bnote */  sexy  *hilo;      /* indicators */{/*  sexy            istaff; */    register PART   *ptptr;    if((part < 1) || (part > nparts)) {        (*palert)("Partstaff: Bad Part=",1, part);        part = nparts;     }    *hilo =  (ptptr = parts + part) -> philo;    *sty =  staves[ptptr->pstaff].staffY;/*  *lownote = clefs[stptr->clef_no].bnote; *//*  return(istaff); */}/************************* * Find min-duration event within one measure, * given pointer to first or last event in it (NOT a barline) * and which way to go (TRUE => right to left )  */Deltime barmin(edge, semitic)  Index   edge;  bool    semitic;{    Deltime    bmin, dt;    Reg EVENT  *ep;     if(edge >= nevents)          edge = nevents - 1;      /* shut up MapBuff() errors */     for(bmin = 96, ep = i2p(edge);     /* Set to Half Note */       (curind < nevents) && (curind >= 0);       ep = semitic ? decdec() : plusplus() )     {          if( !ep->part) {               if(ep->show.INCTYPE <= FINE)   /* Barline, done */                    break;               continue;                     /* Inclusion, ignore */          }/* The comparison */          if( (dt = cod2raw(ep->show.dur, ep->show.durmod)) < bmin) {               if(dt < 2) {       /* < Triplet 64th? */                    /* (*palert)("barmin: bogus dt at", 2, dt, curind); */                    dt = 6;      /* Fake a 32nd note */               }    /* Fudge 8th-or-shorter Rests to save screen space */               if ( (ep->show.slot==REST) && (ep->show.dur > 3)) {                    dt <<= 1;      /* x2, maybe x1.5 later */                    if(dt < bmin)   /* re-test */                         bmin = dt;               }               else                /* Note, as-is */                    bmin = dt;          }     }     return(bmin);} /* barmin() *//****** Search backwards from given point for key sig.* This version DOES NOT update global keysig. */sexy findkey(ind)  Index   ind;{     Reg EVENT *eptr;     for(eptr = i2p(ind) ; curind >= 0; eptr = decdec() ) {          if( !(eptr->part) && (eptr->show.INCTYPE == KEYSIG)) {               return(eptr->show.KSN);          }     }     return(0);    /* fell out of loop, default key of C */} /* findkey() *//****************************  89/10/5* Given an index, return the leftmost*   (or rightmost if right==T) index with the same startime. */Index sametime(ind, right)  Index   ind;  bool    right;{     Etime     when;     Reg EVENT *evp;     when = (evp = i2p(ind)) -> startime;     for( ; ; evp = right ? plusplus() : decdec() ) {          if(curind < 0)           return(0);          if(curind >= nevents)    return(nevents - 1);          if(evp->startime != when)               return(curind + (right ? -1 : 1));     }}/* eof ~Vm640/showsubs.c */