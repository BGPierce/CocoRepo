/* file ~Wm640/FSTAVES.C  --12--   begun 6/14/86Handles multiple Parts and Staffs for Fran.    staffinit(), askclef(), parstaff(), getstaff, staff(),    prtnote(), showlay(), laymen()Includes data structures for staves,plus functions for storing and retrieving infoabout the connections between parts and staves.*/#include <stdio.h>#include "../wmuse.h"#include "../vgraf.h"#include "../wmenu.h"extern short   iclefs[NCLEFS][CLEFHGT];extern direct short               nparts, nstaves, nevents;/* None of these arrays is R/O: */STAFF staves[NSTAVES];PART  parts[NPARTS + 1]; /* Parts are ORG 1, not 0! *//* CAUTION: Same type in flay.c must agree!!! *//* Don't simplify any further, in case Fran takes over showlay() job */typedef struct {    /* like CLEF but no clefname string */  /* char      *clefname; */     ubyte     *fclimg;} FranCLEF;/* Botnotes are White keys above 16' C==01.  Mid C ==22. *//* This IS Read-Only! */FranCLEF  clefs[NCLEFS+1] = {    { /* "Treble", */      iclefs[0]  },    { /* "Bass", */      iclefs[1]  },    { /* "GuiTenor", */     /* Treble but octave lower */      iclefs[2]  },    { /* "Dbl-Bass", */      /* Bass but octave lower */      iclefs[3]  },     { /* "Percussn", */      iclefs[4]  },#define MORECLEFS 1#ifdef MORECLEFS    { /* "Alto", */        /* Violist's penance */      iclefs[5] },    { /* "Tenor", */       /* Trombonist's nitemare */      iclefs[6] },#endif    { /* "", */ NULL}             /* Null name ends array */};/* *********** Functions ******* */dfstaff(s, clefnum, y)  sexy    s, clefnum, y;{     STAFF     *stptr;     if(s >= NSTAVES)          return;     if(s > nstaves - 1)          nstaves = s + 1;     stptr = staves + s;     stptr->clef_no = clefnum;     stptr->staffY = y;}/* Remember, staves[] is ORG 0 but parts[] is ORG 1,* and both nstaves and nparts are ORG 1.*/fgstaff(s)  sexy    s;{     if(s >= nstaves)          return;     nstaves = s;}/* Add other fields later, tho probably part of philo */dfpart(p, s, hilo, noflags, norests, maxchord)  sexy    p, s, hilo;  bool    noflags, norests, maxchord;{     PART *partptr;     if( !p || (p > NPARTS) )          return;     if(p > nparts)          nparts = p;     partptr = parts + p;     partptr->pstaff = s;     partptr->philo = hilo;}/* Forgetting a part just decrements nparts,*  since Bill will re-define affected parts. */fgpart(p)  sexy    p;{     if( !p || (p > nparts) ) /* DEE-fense! */          return;     nparts = p - 1;}/* More Parnas; given index of a staff, gives staffY and draw_image */getstaff(i, sty, img)  short   i,        /* staff index INput */          *sty;     /* staffY OUTput */  ubyte   *(*img);  /* image OUTput */{    if(i >= nstaves)        i = nstaves - 1;    /* trap to bottom staff */    *img = clefs[ staves[i].clef_no ] . fclimg;    *sty = staves[i].staffY;}/* Parnasian interface; given Part No., returns the other items */sexy grafstaff(part, sty, /* lownote, */ hilo)    /* Returns staff # */  sexy  part;       /* INput; rest are OUTputs: */  short *sty;       /* staffY *//* sexy  *lownote;   /* clef.fbnote */  sexy  *hilo;      /* indicators */{    sexy            istaff;/*  register STAFF  *stptr; */    if((part < 1) || (part > nparts)) {/*      alert("Partstaff: Bad Part=",1, part); */        part = nparts;     }    istaff = parts[part].pstaff;    *hilo =  parts[part].philo;    *sty =  ( /* stptr = */ staves + istaff) -> staffY;/*  *lownote = clefs[stptr->clef_no].fbnote; */    return(istaff);}#ifdef FSHOWLAY/* List parts, groups and staves */showlay() {     char      buff[40];     short     y;     sexy      p, s, hilo, lownote;     char      c;     pat("\nS Hgt  Clef    Parts up/mid/dn\n");     pat(    "- --- ------   ---------------\n");/*               s yyy Guitenor Pu Qm Rd Tu Vm *//*              %d %3d %-8s       %c%c     */     for(s = 0; s < nstaves; s++) {          sprintf(buff, "%d %3d %-8s",  s + 1, staves[s].staffY,            clefs[staves[s].clef_no].clefname);          pat(buff);          for(p = 1; p <= nparts; p++) {               if(s == grafstaff(p, &y, /* &lownote, */ &hilo) ) {                    c = (hilo & LOWER) ? 'L' : ((hilo & UPPER) ? 'U' : 'M');                    if(hilo & NOFLAG)                         c += ('a' - 'A');        /* make lower case */                    sprintf(buff, (hilo & PERC) ? " *%c%c" : " %c%c",                      i2hexc(p), c);                    pat(buff);                }          }          vanna('\n');     } /* for s */} /* showlay() */#endif/* eof FSTAVES.C  "WM640" */