/* ~Wm640/FMENUS.C  88/12/15  Stock-Menu Displayer *//* #define SHARE 1*/#include <stdio.h>  /* for getchar() */#include "../wmuse.h"#include "../wmenu.h"#include "../mencodes.h"#include "../screen.h"#include "../windows.h"#include "buttons.h"extern direct byte     arg0, arg1;#ifdef SHAREchar *signon[] = {  /* 13 lines, 43 col */  "\f              Welcome  to\n\n",  "          ___ UltiMusE-K ___\n",  "       the ULTImate MUSic Editor\n\n",  "        Copyright (c) 1991, 1997\n",  "          by Michael J. Knudsen\n\n",  " Please Copy and Distribute this SHAREWARE!\n",  "    If you like it, please send $25 to\n",  "         Mike Knudsen\n",  "         940 Washington St.\n",  "         Bath, ME USA  04530\n\n",  ""};#elsechar *signon[] = {"\f\n\n        Welcome  to\n\n",      "    __ UltiMusE-III __\n\n",      " the ULTImate MUSic Editor\n\n",      "  Copyright (c) 1989, 1996\n",      "    by Michael J. Knudsen\n",      "    All Rights Reserved.\n",     ""};#endifchar *keypdprs[] = {  /* 25w x 14d MEN_KPM */  ". KeyPad Input/Edit Modes",  "%b O auto-Octave mode",  "%b P auto-Pickup (Edit)",  "%b Y note pitch carrYover",  "%b Clone/Chords mode",  "%b Auto-clone mode",/*  ".On entry to KPad, go to:",  "%r2K last Keypad loca",  "M last Mouse click",  "%b Screen view can move",*/  ".On hitting barline, move:",  "%r3Horizontal  (partwise)",     "Vertically  (chordwise)",     "Back & down (Bar-wise)",  ">Instant-Commands Help",  ">Notestring help",  ">Expression insert...",  "ENTER back to keypad",    ""}; /* keypdprs[] */char *kpchelps[] = { /* 26w, 14d  Command helps, text, R/O MEN_KPH */  " KeyPad Input INSTANT Cmnds\n",  " use CAP letters except k:\n",  "\n",  "M get Modes Menu\n",  "k exit bacK to mousing\n",  "ENTER Modes Menu\n",  "\n",  "C enter Clone/Chord mode\n",  "B Brush mode, leave Clone\n",/*  "\n", */  "P Pick up note to defaults\n",  "D Duplicate default note\n",  "\n",  "H refresH screen\n",  "<,> move view one screen\n",  "arrow keys -- as marked\n",  "SPACE advances cursor\n",  "CTRL-U undoes last move\n",  "\n",  "GM goto last Mouse click\n",  "GK goto last Keypad exit\n",  "GA goto last keypad Action\n",  "GE goto keypad Entry screen\n",/*  "\n", */  "L,R Lines connect notes/Rests\n",  "?  show current defaults",  ""}; /* kpchelps[] */char *kpnhelps[] = { /* 34w 8d  Notestring cheatsheet, text, R/O MEN_KPN */  "All Notestring Items are Optional,\n",  "  but must have at least One:\n",  "\n",  "Duration:  1,2,4,8,16,32,64 or v,w,h,q\n",  "Dura Mod:  ., .., /3, _\n",  "Pitch:     a,b,c,d,e,f,g, r\n",  "Pitch Mod: Fp, #Sz, x, N=\n",  "Octave:    o, then 0-7 or u, n\n",  "Articulate: t, l, n, m, s\n",  ""}; /* kpnhelps[] */char *colorprs[] = {  ".  COLORS",  " O.K., Keep",  "%r2Foreground",  "bAckground",  "%b red",  "%b RED",  "%b green",  "%b GREEN",  "%b blue",  "%b BLUE",  ""};char *blkprs[] = {/* These need at least Lmark and Rmark */    " Delete",    " Copy",    " Move",    " Play",    "[ Fixup",    "[ Transpose",    "[ Sort notes",    ". ",    "insert cOda",     /* needs only a Tmark */    "Unmark score", /* needs nothing */    ""};char *barprs[] = {/* These are for actual BarLine types */"\014 CHANGE BARLINE TO\n",    "1  Single Bar\n",    "2  Double Bar\n",    "(  begin repeat\n",    ")  end repeat\n",    ":  back-back )(\n",    "Nn Nth Ending\n",    "F  Fine.\n",  "\n  INSERT A NEW\n",/* These are not Barline types, but * make sense only next to one. */    "/  Time Sig\n",    "Kn Key Sig\n",    "D  DS, DC al Fine\n",    "$  Sign\n",    "C  Coda label\n",    "S  Space\n",    "L  Label\n\n",    ""      /* Required terminator */};char *exprprs[] = {    /* Up-arrow stuff */  "\f PART'S EXPR:\n",  "Instrument\n",  "Volume ppp-fff\n",  "Midi chan hop\n",  "Event (MIDI)\n",  "\n GENERAL EXPR:\n",  "Tempo change\n",  "General volume\n",  "midi drum Clock\n",  "< cresc  > dim\n",  "Accel / Ritard\n",  "^ accent\n",  "- Layoff\n",  "Event (MIDI)\n\n",  ""};/* Note: no \n in Pushbutton Menu strings */char *randprs[] = {  "Play all",  "play Window",  ">Keypad editor",  /* 98/1/30 */  "Screen redraw",  "reNumber bars",  "Undo X-out",  ">Finder-filter",   /* 96-2-19 */  "Hard copy",  "[os9 command",  "? status",  "Restart over",  "   QUIT!",  ""};/* NOTE: Set MIDI_NITEMS to 13 + all lines below */char *midiprs[] = {    /* NOT a pushbutton */  "\n Omni range   Ith -->Ith\n",  " Window play  Play all\n",  " Update       Restore\n",  " Klone chans  Never mind\n",  " Tutti        Quiet all\n",  " + chan on    - chan off\n",  " Modes...     Levels...\n",  "\n#part-->#chan    assign\n",  "#part--> +       part on\n",  "#part--> -       part off\n",  ""};char *mmodeprs[] = {     /* new MIDI Modes *//*   ". MIDI OUTPUTS", */  "%b Rear serial",  "%b MIDI-Pak",  "%b /midi Device",  "%b std midi File",  ". PLAYING MODES",  "%b Instr changes",  "%b Clocks enable",  "%b Events enable",  "%f Volumaster =",  "%f miN note no=",  "%f maX note no=",  ". SCORE MODES",  "%b Use clocks",  "%f Transpose  =",  "%f Seconds/Min=",  "%f Accent wght=",  ""};/* Dummies -- routines that  generate their own stuff */char *dummyprs[] = { "" };/*char *instprs[] = { "" };char *levelprs[] = { "" };char *layprs[] = { "" };*/char *glayprs[] = {  "[Staves...",  "reOrder Parts",  "voice Ranges",  "<+8va part",  "<-8va part",  "<reFill part",  "<Tacetize part",  "<Clear part",  "BACK TO SCORE",  ""};char *setuprs[] = {/*   "Prompt me...", */  "[Staves...",  "[Time sig.",  "[Key  sig.",  "    READY.",  ""};/* Some lines lack \n since hard against right edge of window */char *gotoprs[] = {  "g Number  go to Numbered Bar\n",  "G Number  to Special barline\n",  "g SPACE   Repeat last goto\n",  "g. or gu  Undo last goto\n",   "\n    Universal Command form is:",  "g Sign Number What\n    Sign and Number optional;\n",  "    'What' choices include:\n",  "[ Left marker     ] Right\n",  "! To-marker       * End score\n",  "x any eXpression  k Key sig\n",  "i Instr           v Vol level\n",  "t Tempo           / Time Sig\n",  "n Nth eNding      f Fine.\n",  "o Coda            s Sign\n",  "g Gen'l level     m Midi chan\n",  "a Articulation    _ Tie\n",  ": Repeats         d DC or DS\n",  "p# Part # ... ... P# no rests\n",  "<> Cresc/Dim      r Rit/Accel\n",  "c Clock on/off    e Event\n",  "^ Accent/layoff   l Label\n",  " value# may follow ivgm<>tr\n",  " p# may follow pPivm.\n",  ""};char *startuprs[] = {  ".   STARTUP MENU",  ">make a New score",  "Read in a score",  "%b read-Only mode",  ">Instrs, etc...",  "Dir non-scores",  "[Present dir",  "[CHange dir",  "ENTER score screen",  "Quit!",  ""};char *fileprs[] = {  ">New score",  "Read score file",  "Append to memory",  "Save score file",  "Write new file",  "[ File name?",  "%b read-Only mode",  ">Instrs, etc...",  "Dir non-scores",  "[Present dir",  "[CHange  dir",  "> Title editor",  "Kill disk file",  "Quit!",  ""};char *fsubprs[] = {  "%r4Instruments",  "Percussions",  "Midi chans",  "Vol Levels",  ". ",  "   Read",  "   Write",  "   Dir",  "   Kill",  ""};char *optprs[] = {  "%b Note carryover",  "%b snAp cursors",  "%b stIcky Instr tools",  ">Screen colors...",  "%b Grey staff lines",  "%b Compact display",  "%b Beam note-groups",  "%b Thick beams",  ">Printer setup...",  "%b Debug playing",  "%b Hi-res mouse",  "%b Left mouse port",  "File the options", /* 16 chars */  "Restore options",/* "Auto_renumber", */  "[/? status info...",  ""};char *prtrprs[] = {  ". PRINTERS:",  "%r80 (none)",  "1 DMP-105",  "2 DMP-130",  "3 CGP-220",  "4 Epson Wide",  "5  '' Normal",  "6 IBM Pro",  "7 Gemini 10X",  "%b FormFeeds work",  "%b Top/bot Margins", /* 18 ch */  ""};char *filtprs[] = {  /* " nraofp uml" */  ".  FIND-FILTER",  " Everything",  "%b Notes",  "%b Rests",  "%r2All parts",  "One part",  "%b Flagged",  "%b +Clone parts",  ".",  "%b Upper stems",  "%b Middle stems",  "%b Lower stems",  ""};char *fpartprs[] = {  "%rg1",  "2",  "3",  "4",  "5",  "6",  "7",  "8",  "9",  "A 10",  "B 11",  "C 12",  "D 13",  "E 14",  "F 15",  "G 16",  ""};typedef struct {     bool isgrafix;     ubyte          mlcol,          mtopy,          mcwid,          mlines;     char **mprompts;} Menu;Menu Menupars[MEN_MAX+1] = {#ifdef SHARE{FALSE, 39-22, 170, 44, 18, signon},   /* 0 MEN_SIGNON */#else{FALSE, 39-15, 170, 30, 13, signon},   /* 0 MEN_SIGNON */#endif{TRUE, RAND_LCOL, RAND_TOPY, RAND_CWID, RAND_NITEMS, randprs},{FALSE,BAR_LCOL, BAR_TOPY, BAR_CWID, BAR_NITEMS, barprs},{FALSE,EXPR_LCOL, EXPR_TOPY, EXPR_CWID, EXPR_NITEMS, exprprs},{TRUE, BLK_LCOL, BLK_TOPY, BLK_CWID, BLK_NITEMS, blkprs},{FALSE,MIDI_LCOL, MIDI_TOPY, MIDI_CWID, MIDI_NITEMS, midiprs},{FALSE,INST_LCOL, INST_TOPY, INST_CWID, INST_NITEMS, dummyprs},  /* 6 INSTRS*/{TRUE, 0, 0, 0, 0, dummyprs},      /* 7 LAYOUT */{FALSE,LVL_LCOL, LVL_TOPY, LVL_CWID, LVL_NITEMS, dummyprs},{FALSE,35, HM1-4, 30, 26, gotoprs},{TRUE, FILE_LCOL, FILE_TOPY, FILE_CWID, FILE_NITEMS, fileprs},   /* 10 */{TRUE, OPTS_LCOL, OPTS_TOPY, OPTS_CWID, OPTS_NITEMS, optprs},{TRUE, 0, 0, 0, 0, setuprs},{TRUE, STRT_LCOL, STRT_TOPY, STRT_CWID, STRT_NITEMS, startuprs}, /* 13 */{TRUE, PRTR_LCOL, PRTR_TOPY, PRTR_CWID, PRTR_NITEMS, prtrprs},{TRUE, MMOD_LCOL, MMOD_TOPY, MMOD_CWID, MMOD_NITEMS, mmodeprs},  /* 15 */{TRUE, CLRS_LCOL, CLRS_TOPY, CLRS_CWID, CLRS_NITEMS, colorprs},  /* 16 */{TRUE, FSUB_LCOL, FSUB_TOPY, FSUB_CWID, FSUB_NITEMS, fsubprs},{TRUE, FILT_LCOL, FILT_TOPY, FILT_CWID, FILT_NITEMS, filtprs},{TRUE, FPART_LCOL, FPART_TOPY, FPART_CWID, FPART_NITEMS, fpartprs}, /* 19 */{TRUE, KPM_LCOL,  KPM_TOPY,  KPM_CWID,  KPM_NITEMS,  keypdprs},  /* 20 */{FALSE, 27, HM1-10, 30, 24, kpchelps},  /* MEN_KPH 21 */{FALSE, 22, HM1-50, 39, 11, kpnhelps},  /* MEN_KPN 22 */};/**** End of data;  Begin code text ****//* Convert ONE hex-digit lower-case char to an integer.*  We permit hex digits greater than 'f', on purpose.*  Returns zero for invalid char.*/#define TOPHEX 'g'  /* Max "hex" char allowed (g == 16.) */short hexc2i(c)  char c;{     c -= '0';     if((c >= 0) && (c <= 9))          return(c);     c -= ('a' - '0');     if( (c >= 0) && (c <= (TOPHEX - 'a')) )          return(c + 10);     return(0);} /* hexc2i() */upmenu(code)  sexy    code;{     char      **prompts;     int       i;     char      *str;     Reg Menu  *mptr;     if((code < 0) || (code > MEN_MAX)) {          bell();          return;     }     alcurset(FALSE);    /* later let Bill turn it back on! *//* Setup and Layout, special cases */     if((code == MEN_LAYOUT) || (code == MEN_SETUP)) {          laymenu(code == MEN_LAYOUT);          return;     }/* Those needing a text or button list */     mptr = Menupars + code;     if(mptr->isgrafix) {       /* tgrafix();     /* vestige of Carboniferous? */          pbmenu(mptr->mlcol, mptr->mtopy & 255, mptr->mprompts,            mptr->mlines, mptr->mcwid, TRUE, TRUE, WSDOUBLE);          return;     }/* Text menus */     if(code != MEN_MIDI)     /* MIDI wcreates() his own for pre-text */          wcreate(mptr->mlcol, mptr->mtopy & 255, mptr->mcwid, mptr->mlines,            TRUE, WSDOUBLE);     prompts = mptr->mprompts;     for(i = 0; ; i++) {          if( ! *(str = *(prompts + i)) )               break;      /* Quit on null line */          pat(str);     }} /* upmenu() *//* General Subr to create and show Push-Button vertical menus;*  could figure out nitems and ncols, but Bill needs these anyway.*  XC is of leftmost characters; edge of menu is 1 or 2 to left of that.*  Y  is the very top borderline of the menu window.*  Style is best WSDOUBLE, except WSNONE for Layout Menu.*//* 89/11/5  More options in 1st chars of each string:.    No button, no args, just phrase (already)%b   Bool; Square box in front; 'X'-ed in iff stream byte != '0'%rN  Begin "Radio Buttons".  Read ASCII digit K (not N) from stream.     This string and next N-1 strings are prefixed with circles or slide,       and the Kth one is blackened in to show selected.       K==0 makes no sense, so K==0 means "nobody".       N should be from 2 thru 9 plus a thru g.[    Usual button, but Rectangular ends (Dialogue, but not full SubMenu)>    Usual button, but >____> shape (Sub-Menus)<    Usual button, but <_____> shape (Tool pickup)%s   Read string from input, use it for phrase%f   Fill-in; print phrase followed by read-in string.%g   Like %f, but " =" and read-in string are printed on the next line.*/pbmenu(xc, y, prs, nitems, ncols, dowin, save, style)  sexy    xc, y, nitems, ncols, style;  char    *prs[];   /* traditional menu prompt-string array */  bool    dowin,    /* do create a new window, else just draw */          save;{     char buff[8];     sexy textrows, j, phrasex, phrasey, radion, radiok, len;     bool radio1;     char c1;     Reg char  *phr;     radion = radiok = radio1 = 0;/* Convert sizes to fterm's text lines */     textrows = (PB_VPITCH * nitems + CHRHGT - 2) / CHRHGT;     if(dowin) {          wcreate(xc - 1, y, ncols + 2, textrows, save, style);          vanna('\f');     }/* Do each phrase line */     phrasey = y - PB_YOFF - TVBORD;     for(j = 0; j < nitems;  phrasey -= PB_VPITCH) {          phrasex = xc;       /* but gets diddled */          if( !radio1)   /* keep same phr if just began a radio */               phr = prs[j++];     /* If inside a "radio button" slider, override 1st-char tests */          if(radion > 0) {               radion--;               phrasex++;               if(radio1) {             /* Draw slide top */                    radio1 = FALSE;                    style = BXRADTOP;               }               else if( !radion) {      /* Draw slide bottom */                    style = BXRADBOT;               }               else {                   /* Draw plain old inner slide */                    style = BXRADMID;               }          } /* radios */          else {               c1 = *phr++;               switch(c1) {               case '.': /* nuthin' but the phrase */                    style = 0;     /* NONE */                    phrasex--;     /* hard against left side */                    break;               case '%': /* multitude of sins */                    c1 = *phr++;                    switch(c1) {                    case 'r':                         radio1 = TRUE;                         radion = hexc2i(*phr++);                         radiok = hexc2i(getchar());                         phrasey += PB_VPITCH;     /* fudge loop */                         break;                    case 'b': /* Boolean check box */                         phrasex++;                         style = BXOFF + (getchar() != '0');                         break;                    case 'f': /* Fill-in value, to Right of phr */                         len = strlen(phr);                         gets(buff);                         phrase(--phrasex + len, phrasey, buff, FALSE);                         style = 0;                         break;#ifdef MOREPBS                    case 's':                    case 'g':#endif                    } /* switch after '%' */                    break; /* after '%' */               case '[': /* Square button -- submenu? */                    style = BXSQUARE;                    break;               case '<': /* Hexagonal button -- tool? */                    style = BXHEXAG;                    break;               case '>': /* Arrow box button -- submenu? */                    style = BXARROW;                    phrasex++;     /* dodge left '>' */                    break;               default:  /* Original Rounded Button Box */                    style = BXROUND;                    phr--;    /* restore 1st char */               } /* switch(c1) */          } /* if not radio */     /* Draw button & Print the actual phrase, for all cases */          if(radio1)               continue;          butbox(xc - 1, xc + ncols, phrasey, style);          if( ! (--radiok)) {       /* Add a Radio Selected button */               butbox(xc - 1, xc, phrasey, BXRADSEL);               radio1 = FALSE;          }          phrase(phrasex, phrasey, phr, FALSE);     } /* for */} /* pbmenu() *//* YesNo() Menu.  Read prompt\n  direct from pipeline.*  Undone by standard wkill().*  YN_TOPY -> topy, YN_LCOL -> leftx to "float" 96-2-19.*/yesno() {     int  phrasey, leftx, topy;     leftx = arg0;     topy = arg1 & 255;     wcreate(leftx, topy, YN_COLS, YN_ROWS, TRUE, WSDOUBLE);     alcurset(FALSE);/*   pat(prompt); */     vanna(' ');     phrasey = topy - YN_RECTYOFF;     butbox(YES_L, YES_R, phrasey, BXROUND);     phrase(YES_L + 1, phrasey, "  YES", TRUE);     butbox(NO_L, NO_R, phrasey, BXROUND);     phrase(NO_L + 1, phrasey, "  NO!", TRUE);}void patience(){     wcreate( 24, 120, 33, 3, TRUE, WSSHADOW);     alcurset(FALSE);     pat("\n Patience...this takes time...");}/* eof ~Wm640/fmenus.c */