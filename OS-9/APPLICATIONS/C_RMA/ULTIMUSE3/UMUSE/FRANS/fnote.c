/* file ~fwm640/FNOTE.C  --7--    Replaces DRNOTE.C or PUTNOTE.C*  Image-putter for notes & rests.*  Major "pipe" conversion is to follow given Y, don't figure from Part.*    Converted x's end in c.*  And using Xc's 0--79 steda Xp's 0--639!*  Also separate Note and Rest drawing routines.*/#include "../wmuse.h"#include "../vgraf.h"#include "images.h"      /* Array declarations.  Read its comments! */#include "../wwidths.h"#include "../wmenu.h"#include "../macros.h"/* Non-graphic arrays */extern CLUZION cluzions[];extern STAFF   staves[];extern PART    parts[];extern direct ubyte     arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10;extern direct sexy     nstaves, lastnrx, lastaffy;extern void     put1(), put2(), dyna1(), dyna2(), dyna3();void jam2();/**** Fcns to initial-load image arrays from disk files ****//* CAUTION: New 90/5/8 version requires one solid file, *    MERGEd in same order as the image arrays are declared continguously.*/bool opnload(array, filename, size, flag)    /* Open & Load */  byte    *array;  char    *filename;  short   size;  bool    *flag;{     short     chan, nread;     chan = open(filename, 1);     if(chan < 0) {          printf("No file %s!\n", filename);          return(FALSE);     }     nread = read(chan, array, size);     if(size -= nread)          printf("File %s short %d.\n",               filename, size);     close(chan);     return(flag && TRUE);}/* Path and .Ext for image files are hardcoded in here */imgload(){     bool flag;     flag = opnload(icurses, "/DD/SYS/AllUm3.img",       sizeof(icurses) + sizeof(isign) + sizeof(icoda) + sizeof(imarks)         + sizeof(ilevels) + sizeof(iclefs) + sizeof(inumers)         + sizeof(idcs) + sizeof(ipmods) + sizeof(idmods)         + sizeof(iartics) + sizeof(ibars),       TRUE);     if( !flag)          printf("\007Error reading image file(s).\n", 0);}/******* Score-Drawing Fcns ******//* sexy  Notexc,Notey,      /* where to draw it *//*       Staffy,     /* Staff's bottom line, for ledger() *//*       Dur, Dmod, Pmod, Art; *//* bool  Stemdn,     /* stem direction: TRUE==down *//*       Noflags;    /* Don't draw the flags on stem *//** DUR: Breve,1,2,4,8,16,32,64. Limit=0-7* DurMod: Null  .  ..  Triplet.  Limit=0-3* PitMod: * Art:   0==Tied*//********************************************************//* 18% speedup 90/5/26 by reducing Pipe args from 10 to 5 for Note. *//* Draw a Note (NOT REST) directly from Fran's arg_box. *//* Note args in terms of arbox array */#define Notexc arg1#define Notey  arg2#define Staffy arg4/*   Bit fields of other args:arg0:0   color1   stemdn2   noflags3-5 pitmodarg3:0-1 durmod2-4 dur5-7 artic*/dnota() {     short     y;     sexy      notey, color, temp;     Reg char  *bp;     notey = Notey & 255;/* Now set by place() for Plus-pulling *//* If erasing, save coords for Placement */     if( !(color = arg0 & 1) ) {          lastnrx = Notexc;          lastaffy = Staffy & 255;     }/* Duration Mods, one column to right */     if(temp = arg3 & 3) {    /* DurMod */          if(temp == 3)      /* Triplet */               dyna1(Notexc + 1, notey - 2, 3, "\0\0\0");          put1(Notexc + 1, notey + DMODYOFF, DMODHGT, idmods[temp], color);     }/* Pitch Mods, one column to left */     if(bp = pmodps[temp = arg0 >>3]) {  /* skip if null */          if(temp == 3)      /* Double Sharp, dynamite line */               dyna1(Notexc - 1, notey, 1, "\0");          put1(Notexc - 1, notey + PMODYOFF, PMODHGT, bp, color);     }/* Articulations */     if((temp = (arg3 >>5) & 7) != NORMAL) {  /* was == TIED 90/6/10 */          y = notey +            ((arg0 & 2) ? ((temp += NARTICS) , ARTDNYOFF) : ARTUPYOFF);          put2(Notexc, y, ARTHGT, iartics[temp], color);     }/* Draw the Note -- body, stem, and flags are one image */     temp = (arg3 >> 2) & 7;  /* Dur */     if((arg0 & 4) && (temp > 3))  /* if noflags */          temp = 3;          /* Quarter note has no flags *//* test stemdn */     y = notey + ((arg0 & 2) ? ((temp += 8) , NOTEDNYOFF) : NOTEUPYOFF);     put2(Notexc, y, NOTEHGT, inotes[temp], color);     ledger(Notexc, notey, Staffy & 255, color);} /* drnote() *//********************************************************* Draw a Rest directly from Fran's arg_box.* Does not fudge Rests' Y; that's showall()'s job.*/void drsta() {     sexy notey, temp, color;     notey = Notey & 255;/* If erasing, save coords for Placement */     if( !(color = (arg0 & 1))) {          lastnrx = Notexc;          lastaffy = Notey & 255;  /* May be 8 or 16 high */     }/* Duration Mods, one column to right */     if(temp = (arg3 & 3)) {          if(temp == 3)      /* Triplet */               dyna1(Notexc + 1, notey - 2, 3, "\0\0\0");          put1(Notexc + 1, notey + DMODYOFF, DMODHGT, idmods[temp], color);     }     put2(Notexc, notey + RESTYOFF, RESTHGT, irests[(arg3 >> 2) & 7], color);} /* drest() *//****** Draw a Note or Rest from NOTE structure ***//* Kept around mainly for Palette-drawing *//* CLOBBERS arg_box ! */drawnr(it, x, y, sty, stemdn, noflags, color)  NOTE    *it;  sexy    x, y, sty;  bool    stemdn, noflags, color;{     arg0 = color;     Notexc = x;     Notey = y;     arg3 = ((it->dur) << 2) | (it->durmod);     if(it->slot == REST)          drsta();     else {          arg3 |= it->artic << 5;          arg4 = sty;          arg0 |= it->pitmod << 3;          if(stemdn)     arg0 |= 2;          if(noflags)    arg0 |= 4;          dnota();     }}/**** Draw just the Articulation part of a note */drawart(color, x, y, art, stemdn)  bool    color, stemdn;  sexy    x, y, art;{     if(art == NORMAL)          return;     put2(x, y + (stemdn ? ARTDNYOFF : ARTUPYOFF), ARTHGT,       iartics[art + (stemdn ? NARTICS : 0)], color);}/******************************** Draw ledger lines for notes above/below staff.* Given notex is Columns, translate to Pixels for hline().*/ledger(notexc, notey, staffy, color)  sexy    notexc, notey, staffy;  bool    color;{    int   dy, ln, ly;    int   xl, xr;    dy = notey - staffy;    xl = 8 * notexc - 2;    xr = 8 * notexc + 11;    if(dy < -2) {      /* below staff */        ln = (-dy) >>2;        for(ly = staffy - 4; --ln >=0; ly -= 4) {            /* hline(xl, xr, ly, color); */            put2(notexc-1, ly, 1, "\x03\xFF", color);            put1(notexc+1, ly, 1, "\xF0", color);        }    }    else if(dy > 18) {  /* above staff */        ln = (dy - 16) >>2;        for(ly = staffy + 20; --ln >=0; ly += 4) {            hline(xl, xr, ly, color);        }    }} /* ledger() *//*************************** 88/6/6 Draws multi-digits DOWNWARDS of 1st digit.* Draw up to three BCD digits in vertical Chinese style.* X,Y locate LOWER LEFT corner of TOP (most significant) digit.* Images are in char *inumers[11].*/drawbcd(num, xc, y)  int     num;  sexy    xc, y;{    short t, h;    y += 5;              /* get Upper left corner */    if(num < 0)          /* No negatives, use 0 */        num = 0;    else if(num > 999)   /* Condoms Save */        num = 999;    t = h = 0;    while( (num -= 100) >= 0)       h++;    num += 100;    while( (num -= 10) >= 0)       t++;    num += 10;     if(h) {          dyna1(xc, y, NUMHGT, inumers[h]);          y -= (NUMHGT - 1);     };     if( t || h) {          dyna1(xc, y, NUMHGT, inumers[t]);          y -= (NUMHGT - 1);     };     dyna1(xc, y, NUMHGT, inumers[num]);} /* drawbcd() *//*** Fcns to force Barlines up against the left or right wall,* for use with Auto Printing. */jam2(x, y, hgt, arrayp, yes)  sexy    x;  int     y, hgt;  unsigned     *arrayp;  bool    yes;{     unsigned       myarray[BARLHGT], crush;     Reg unsigned   *rowp;     strdn(myarray, arrayp, 2*BARLHGT);/* Clobber the staff lines in images (very dependent on images!) */     myarray[3] = myarray[7] = myarray[11] = 0;/* Find leftmost or rightmost pixel in image */     for(crush = 0, rowp = myarray + BARLHGT-1;  rowp >= myarray; )          crush |= *rowp--;     if( !crush)          return;/* Shift whole image copy L or R till it hits the wall */     if(x < 2) {    /* Left edge */          while((int)crush > 0) {               crush <<= 1;               for(rowp = myarray + BARLHGT-1; rowp >= myarray; )                    *rowp-- <<= 1;          }     /* Restore staff lines to left side */          myarray[3] = myarray[7] = myarray[11] = 0xFF00;      } else {       /* Right edge */          while((crush & 1) == 0) {               crush >>= 1;               for(rowp = myarray + BARLHGT-1; rowp >= myarray; )                    *rowp-- >>= 1;          }     /* Restore staff lines to right side */          myarray[3] = myarray[7] = myarray[11] = 0xFF;     }     put2(x, y, BARLHGT, myarray, TRUE);} /* jam2() *//*** DIAS ***************************** * Put given Inclusion code type on all staves. * Then draw BCD number with it if bcd nonzero. * For ordinary barlines, BCD is offset 0, -6 to go under staff; * but if NTHENDING, offset by +0,+20 to go above staff. * Putalst() is responsible for figuring what image(s) to use, *  where, how many byes wide, logic, etc. */putalst(x, type, bcd)  short   x, type, bcd;{     short     s, y, yoff, hgt, wbytes;     void      (*fcn)();     byte      *arrayp;       /* though may be short, etc. */     CLUZION   *czp;/* Figure out what to do */     if(type <= FINE) {       /* Barline */          arrayp = ibars[type];          if(type == NTHENDING) {            /* fcn = (x > 1) ? dyna3 : jam3; */               fcn = dyna3;               yoff = NTHENDYOFF;               hgt = NTHENDHGT;          }          else {               if((x <= 1) || (x == 79))                    fcn = jam2;               else                    fcn = put2;    /* was dyna2 till 89/5/22 */               yoff = BARLYOFF;               hgt = BARLHGT;          }         } /* barlines *//* Markers, DC's, ... */     else if(type == SPACE) {          Clear(x, SCROLTOP + 1, x + 1, SCORTOP, BACK);          return;     }     else {          czp = cluzions + type;          wbytes = czp->czbytes;          hgt = czp->czhgt;          yoff = czp->czyoff;          fcn = (wbytes==1) ? put1 : ((wbytes==2) ? put2 : dyna3);          arrayp = (byte *)(czp->czimg);     }/* At last, do it */    for(s = 0; s < nstaves; s++) {        y = Ystaff(s);        (*fcn)(x, y + yoff, hgt, arrayp, TRUE);        if(bcd) {            if(type == NTHENDING)                drawbcd(bcd, x + 1, y + 18);            else                drawbcd(bcd, x, y - 6);        }    }} /* putalst() */drawlab(notex, char1, char2)       /* label 940127 */  sexy    notex;  char    char1, char2;{     char pbuff[3];     pbuff[0] = char1;     pbuff[1] = char2;     pbuff[2] = '\0';     boxc(notex, SCORTOP-1-7-2, notex + 2 + (!!char2), SCORTOP-1);     phrase(notex + 1, SCORTOP-1-6, pbuff, FALSE);}/*** DGLI, part of ***************************** */drawaccent(notex, val)  short   notex, val;{     char pbuff[2];     *pbuff = (val < 0) ? '-' : '^';     *(pbuff+1) = '\0';     phrase(notex, SCORTOP-5, pbuff, TRUE);}drawtmp(notex, tempo)  short notex, tempo;{     drawbcd(tempo & 255, notex, SCORTOP-5);}drawclk(notex, onoff)  short   notex, onoff;{     phrase(notex, SCORTOP-5, "C", TRUE);     phrase(notex, SCORTOP-5-5, onoff ? "+" : "-", FALSE);}/******* Draw a System Event (Instant or Table) at top ****/drsysevt(notexc, tableno)  sexy    notexc, tableno;{     phrase(notexc, SCORTOP - ((tableno > 9) ? 8 : 5), "E", TRUE);     if(tableno >= 0)    /* else Instant */          drawbcd(tableno, notexc + 1, SCORTOP - ((tableno > 9) ? 5 : 8));}/*   <ff  >ppp      130  76*    12   90        A12  R32*/void drawcres(notex, level, beats, which)  sexy    notex, level, beats, which;{     char stuff[4];     bool cresc;     beats = clamp(beats, 1, 99);     if(cresc = (which < 2)) {     /* cresc/dim */          phrase(notex, SCORTOP-5, which ? "<" : ">", TRUE);          drawgenv(notex+1, level);          *stuff = ' ';     } else {                      /* accel/rit */          sprintf(stuff, "%2d", level & 255);          phrase(notex, SCORTOP-5, stuff, TRUE);          *stuff = (which == 3) ? 'R' : 'A';     }     sprintf(stuff+1, "%d", beats);     phrase(notex, SCORTOP-5-6, stuff, FALSE);}/********* Draw General volume levels (mf, ppp, etc) up top like Tempo. */void drawgenv(notexc, level)  sexy    notexc, level;{     /* level &= 7;         /* for now */     dyna2(notexc, SCORTOP-1, LEVELHGT, ilevels[level]);}/**** DAKS *********************** Draw key signature on each staff */drawks(notex, ksn)  short notex;  sexy  ksn;        /* # of sharps, negative for flats */{     short y;     sexy s;     char *preimg;/* New code to put "#3" or "b4" in middle of every staff */     preimg = pmodps[ (!ksn) ? 4 : ((ksn >0) ? 2 : ((ksn = -ksn), 7))];     notex -= (BARLWID - 2);    /* if BARLWIDTH gives one byte extra */     for(s = 0; s < nstaves; s++)     {          y = Ystaff(s) + 8;       /* center line */       /* Clear space in midline */          dyna1(notex, y + PMODYOFF, PMODHGT, preimg);          drawbcd(ksn, notex + 1, y - 2);     } /* Save this code for "Master" KS when we get Transposing Staves *//* Old code just draws "3#" or "5b" at top of screen *//*     drawbcd( ksn, notex, SCORTOP - 9);     dyna1(notex + 1, SCORTOP - 7 + PMODYOFF, PMODHGT, preimg);*/} /* drawks() *//**** DATS ************ Draw Time Signature ******/drawts(notex, numer, denom)  short notex;  sexy  numer, denom;{     short s, y, xpix;     xpix = notex << 3;     for(s = 0; s < nstaves; s++)     {          y = Ystaff(s);      /* White-out a space for stuff, leaving horiz bar in middle */          hline(xpix - 5, xpix - 2, y + 8, BACK);          hline(xpix + 10, xpix + 13, y + 8, BACK);          drawbcd(numer, notex, y + ((numer > 9) ? 16 : 10) );/* Denom is pulled directly out of image array */          if(denom < 0)  denom = 0;     /* Protection only */          if(denom > 9)       /* meaning 16, not 2, 4, or 8 */               denom = 10;    /* index of special one-char '16' */          dyna1(notex, y + 7, NUMHGT, inumers[denom]);     }}/************** Draw instrument/patch "I3" etc before its Part only. */drinstr(notex, y, inst)  sexy notex, y, inst;{     dyna1(notex, y + 2, 5, "\x7e\x18\x18\x18\x7e");     drawbcd(inst, notex + 1, y + ((inst > 9) ? 1 : -2) );}/************** Draw MIDI Channel hop "C3" etc before its Part only. */drmchop(notex, y, chan)  sexy notex, y, chan;{     chan++;   /* Humans like 1-16 *//*   dyna1(notex, y + 2, 5, "\x3c\x66\x60\x66\x3c"); /* "C" *//*   dyna1(notex, y + 2, 5, "\x82\xEE\xFE\xD6\xC6"); /* "M" *//*   dyna1(notex, y + 2, 5, "\x42\x66\x7E\x66\x66"); /* "M" */     dyna1(notex, y + 2, 5, "\x66\x7E\x66\x66\x66"); /* "H" high */     drawbcd(chan, notex + 1, y + ((chan > 9) ? 1 : -2) );}/*** Draw Partwise Event (Instant or Table) before its Part only ***//* If table_slot >= 0, then include that number like Instr. */drprtevt(notexc, y, tableno)  sexy    notexc, y, tableno;{/*   dyna1(notexc, y + 2, 5, "\x7e\x30\x3c\x30\x7e");  /* big 'E' */     dyna1(notexc, y + 2, 5, "\x7e\x60\x7c\x60\x7e");  /* big 'E' */     if(tableno >= 0)          drawbcd(tableno, notexc + 1, y + ((tableno > 9) ? 1 : -2));}/********* Draw volume levels (mf, ppp, etc) as for instruments. */short drlevel(notexc, notey, level)   /* DXLV */  sexy    notexc, notey, level;{     level &= 7;         /* for now */     dyna2(notexc, notey + LEVELYOFF, LEVELHGT, ilevels[level]);}/* eof ~fwm640/FNOTE.C */ 