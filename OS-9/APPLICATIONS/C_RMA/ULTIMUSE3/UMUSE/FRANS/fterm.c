/* ~Sw640/FTERM.C   Graphics text screens for fran   Begun 88/11/26*  our mis-Fortune to re-invent the Wheel, including letter-turner.*  Modified for variable-size and overlaying windows 89/1/13.*  Under this scheme, VDG graphics screen is always displayed,*  so old text() and grafix() fcns have been redefined*  to create/kill "stock" default-sized windows.*  These stock gtext windows can't be overlaid directly on each other,*  but can with intervening wcreate'd windows.**  Every Fran.c shud have a tgw, tho not on purposes, neither was ours!*/#include <stdio.h>#include "../wmuse.h"#include "../screen.h"#include "../windows.h"#include "../macros.h"#define STATIC#define SPACE       9860      /* Our spalloc() working area size */#define SPACESTK    WSTACKSIZE#define WSTACKSIZE  4         /* Depth of overlay window stack */#define DCOLS       32        /* defaults */#define DROWS       18#define CURSOFF     (COLS * (CHRHGT-1))#define NL     '\n'#define LF     10#define CR     '\r'#define FF     12#define BS      8#define BL      7extern direct ubyte     *vdgram;extern ubyte     /* *malloc(), */     ichars[96][6];extern direct bool     grafmode;direct bool     tgwmode = FALSE;    /* if ANY windows at all are open */typedef struct {     bool          stock;     ubyte          ncols, nrows, cleft, topy,          col, row, invrow,          *cursadr, *saver;} Window;Window     wstack[WSTACKSIZE];direct Window     *wp = wstack;STATIC direct sexy     wncols, wnrows,      /* No. of text (byte) columns & rows */     wcleft,    /* Leftmost text column, where screen edge is col 0 */     wcrght,     wtopy,    /* Y of uppermost pixel */     wboty,     whgt,     /* window height in pixels */     nowinv;   /* row currently inverted by mouse in menu */STATIC direct unsigned     wsavsiz;  /* bytes needed to save under new window */STATIC direct bool     alfacurse = 1,     /* text cursor is on */     stocker;  /* Current window is "stock" default Text 32x20 */STATIC direct ubyte     *curaddr,     *homeaddr;       /* Address of TOP LEFT corner of character space *//* Current Text_Cursor position, relative to the Window, not screen! */STATIC direct sexy     curcol, currow;STATIC direct int     curpx, curpy;       /* Pixel version of above *//* Zero whenever cuurrent window didn't save underlying */STATIC direct ubyte     *texsave;      /* Ptr to mallloc'ed save array */ubyte *spacestk[SPACESTK];sexy  spaceind;ubyte space[SPACE];      /* spalloc() working area *//**** Replacement for malloc() package ****/spinit() {     spacestk[0] = space;     spaceind = 0;}/* Allocate bytes to save window */ubyte *spalloc(req)  int     req;{     char *curtop, *newtop;     newtop = req + (curtop = spacestk[spaceind]);     if( (newtop >= (space + SPACE)) || (spaceind >= SPACESTK-1))          return(NULL);     spacestk[++spaceind] = newtop;     return(curtop);}bool spfree() {     if(spaceind <= 0)          return(FALSE);     spaceind--;     return(TRUE);    }/* Entries to Text Graphic Window mode *//* Old-compatible Centered window, using default sizes;*  no-op if already a window showing.*  Don't try to overlay this on a "real" window. */void gtext() {     if(tgwmode) {          if(stocker)    /* No duplicates! */               return;          else               wsave();     }     tgwmode = TRUE;     stocker = TRUE;     wncols = DCOLS;     wnrows = DROWS;     center();     newin(TRUE, WSDOUBLE);   /* always save */}#ifdef TGRAFIX/* Back to grafix.  Leave tgwmode on.  For old compat'ly only!*  wkill() will clear tgwmode via wrestore() if no more windows. */void tgrafix() {     if(stocker)    /* don't touch non-stockers */          wkill();  /* wkill() is no-op if !tgwmode */else if(tgwmode)  printf("\007tgrafix(non-stocker) at $%04x\n",texsave);     return;}#endif/* General overlay_window creator */void wcreate(lc, ty, width, hgt, dosave, style)  sexy    lc, ty, width, hgt, style; /* All in cols & rows, except ty Pixels */  bool    dosave;{     if(tgwmode)          wsave();     tgwmode = TRUE;     stocker = FALSE;     wncols = width;     wnrows = hgt;     wtopy = ty;     wcleft = lc;     winrest();          /* limits args and figures the rest */     newin(dosave, style);}/* General window ender */void wkill() {/* fprintf(stderr, "Wkill tgwmode=%d; ", tgwmode); */     if( !tgwmode)          return;     if(texsave) {          Put(wcleft-1, wboty, wcrght+1, wtopy, texsave);          if( !spfree() )               printf( "\007**Can't free %04x\n", (int)texsave);          texsave = 0;     }     wrestore();    /* may turn off tgwmode */} /* wkill() *//* Invert given row # of current text window,*  numered from 1, since 0 means "none inverted."*  Uses local knowledge of window's location and width.*  Try auto'ly de-inverting previous choice, save Bill work.*/void invert(rowno)  sexy    rowno;{     if(rowno == nowinv)          return;     if(nowinv)                         /* Undo previous */          rawinv(nowinv);     if(rowno && (rowno <= wnrows))     /* Do this one */          rawinv(rowno);}/* Real work of invert()ing a text row */void rawinv(rowno)  sexy    rowno;    /* may assume nonzero */{     int  top;     top = wtopy - TVBORD + 1 - (CHRHGT * (rowno - 1));     Invert(wcleft, top - CHRHGT, wcrght, top);}/* End of outside entries *//* Stack points to next empty slot */void wsave() {     if(wp >= wstack + WSTACKSIZE)          return;     wp->ncols = wncols;      wp->nrows = wnrows;     wp->cleft = wcleft;      wp->topy = wtopy;     wp->invrow = nowinv;     wp->cursadr = curaddr;     wp->col = curcol;        wp->row = currow;     wp->saver = texsave;     wp->stock = stocker;     wp++;}void wrestore() {     if(wp == wstack) {          tgwmode = FALSE;          return;     }     wp--;     wncols = wp->ncols;      wnrows = wp->nrows;     wcleft = wp->cleft;      wtopy = wp->topy & 255;     nowinv = wp->invrow;     curaddr = wp->cursadr;     curcol = wp->col;        currow = wp->row;     texsave = wp->saver;     stocker = wp->stock;     winrest();     /* regenerate the rest */}/* Temp debugging fcn *//*void unwind() {     Reg Window    *twp;     twp = wp;     while(twp >= wstack) {           fprintf(stderr,            "No %d at $%04x Nc=%d Nr=%d TopY=%d Stock=%d.\n",            twp - wstack, wp->saver, wp->ncols, wp->nrows, wp->topy & 255,            twp->stock);          twp--;     }}*//* Create a new window */newin(dosave, style)  bool    dosave;  sexy    style;{     texsave = 0;     if(dosave) {          texsave = spalloc(wsavsiz);          if( !texsave) {               printf("\007***Can't alloc(%d)!\n", wsavsiz);          }          else               Get(wcleft - 1, wboty, wcrght + 1, wtopy, texsave);     }     wboxclr(style);     /* actually draw the box */     gohome();     tgwmode = TRUE;}/* Limit sizes of window */wlimit() {     if(wncols > COLS)          wncols = COLS;     if(wnrows > ((HGT - 2*TVBORD) / CHRHGT))      /* 26. */          wnrows = (HGT - 2*TVBORD) / CHRHGT;/* Wasted if centered window, but no harm */     if(wtopy < 0)          wtopy = 0;     if(wtopy > HM1)          wtopy = HM1;/*     if( (wcleft &= 255) > 79)          wcleft = 79;*/     if(wcleft > (COLS-1))    /* New version of above, but need & 255 yet? */          wcleft = (COLS-1);     if(wcleft < 1)          wcleft = 1;}/* Given new sizes (wncols & wnrows), calculate all for center window */void center() {     wlimit();     wcleft  = (COLS - wncols) / 2;     wtopy  = 3 + TVBORD + ( HGT + (wnrows * CHRHGT)) / 2;     winrest();}/* Given new sizes and location (wcleft & wtopy), figure the rest */void winrest() {     wlimit();     wcrght = wcleft + wncols - 1;     if(wcrght > (COLS-2)) {          wcleft -= (wcrght - (COLS-2));          wcrght = (COLS-2);     }     wboty = wtopy - 2*TVBORD - (wnrows * CHRHGT);     if(wboty < 0) {          wtopy -= wboty;     /* move whole window up */          wboty = 0;     }     homeaddr = vdgram + ((HM1 - (wtopy - TVBORD)) * COLS + wcleft);/* There's no funny fudge below except at end */     wsavsiz = (wncols + 2) * (wtopy - wboty + 1) + 2;    /* +2 for luck *//* Well, now there is:  +1 in each coordinate.  Don't ask why! */  /* wsavsiz = (wncols + 2+1) * (wtopy - wboty + 1+1); */}wboxclr(style)  sexy    style;    /* plain, shadow, or double box */{     Clear(wcleft-1, wboty, wcrght+1, wtopy);     winbox(wcleft-1, wboty+1, wcrght+1, wtopy-1, style);}gohome() {     curcol = currow = 0;     curaddr = homeaddr;     if(tgwmode && alfacurse)          *(curaddr + CURSOFF) = 0x7F;}alcurset(onoff)  bool    onoff;{     if(tgwmode) {          if(onoff && !alfacurse) {               *(curaddr + CURSOFF) = 0x7F;          }          else if(!onoff && alfacurse) {               *(curaddr + CURSOFF) = 0;          }     }     alfacurse = onoff;}gotoxy(col, row)   /* Random cursor addressing */  sexy    col, row;{/* later */}/* Type a string on the screen.  Must already be in text mode */pat(str)  char *str;{     char ch;     while(ch = *str++)          vanna(ch);}vanna(ch)      /* Displays one at a time, does auto CRLF */  char    ch;{     register char  *from;     ch &= 127;     /* No Krauts, Frogs, Vikes, ... */     if(ch < 32) {  /* Control */          if(ch == NL) {               linefeed();          }/*          else if(ch == CR)               linefeed();          else if(ch == LF)               linefeed();*/          else if(ch == FF) {               Clear(wcleft, wtopy-TVBORD, wcrght, wboty+TVBORD);               gohome();          }          else if(ch == BS) {               if(curcol)          /* Don't back up to previous row */                    backsp();          }          else if(ch == ('X' & 31)) {   /* Line killer */               while(curcol)                    backsp();          }          else if(ch == BL)   /* Bell */               bell();     } /* CTRL chars */     else {    /* Print it */          from = ichars[ch - ' '];/* Turn the letter over ... */          *curaddr = *from;          *(curaddr+ 80) = *(from+1);          *(curaddr+160) = *(from+2);          *(curaddr+240) = *(from+3);          *(curaddr+320) = *(from+4);          *(curaddr+400) = *(from+5);          if(alfacurse)               *(curaddr+480) = 0;      /* erase old cursor */     /* Advance the cursor position */          if(++curcol >= wncols)               linefeed();          else               curaddr += 1;     } /* printable chars *//* Draw underline_style cursor */     if(alfacurse)          *(curaddr + CURSOFF) = 0x7F; /* Cursor */} /* vanna() *//* Do complete backspace.  Caller must verify non-zero column */backsp() {     *(curaddr + CURSOFF) = 0;     /* Erase cursor */     curcol--;     curaddr--;     *curaddr = 0;       /* Erase char */     *(curaddr+ 80) = 0;     *(curaddr+160) = 0;     *(curaddr+240) = 0;     *(curaddr+320) = 0;     *(curaddr+400) = 0;}/* Do Newline actions */linefeed() {     if(alfacurse)          *(curaddr + CURSOFF) = 0;     /* erase old cursor */     curcol = 0;     if(currow >= wnrows - 1) {          scrollup();          curaddr = homeaddr + (COLS*CHRHGT * (wnrows - 1));     }     else {          currow++;          curaddr = homeaddr + (COLS*CHRHGT * currow);     }}scrollup() {     sexy y;     ubyte *rowp;     for(y = wtopy - TVBORD, rowp = homeaddr;       y > wboty + TVBORD+CHRHGT;  y--, rowp += COLS)          strdn(rowp, rowp + COLS*CHRHGT, wncols);     Clear(wcleft, wboty + TVBORD, wcrght, wboty + TVBORD+CHRHGT);}/* eof ~Sw640/fterm.c */