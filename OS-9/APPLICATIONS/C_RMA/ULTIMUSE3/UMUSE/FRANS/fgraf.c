/* ~FWm640/FGRAF.C  -10A-* CoCo-3 Level 2 VDG Grafix package for C UltiMusE.*  NOTE: Uses Y-axis positive UPwards.** 95/9/11   Use legit Type 5 640x2 L2 window* 90/6/26   More thorough use of DP vars* 88/07/13  Converted for 1==Foreground, 0==Background* 88/10/16  Used speedup  for(i=n+1; --i; )* 88/11/08  Col-X's*/#include <stdio.h>#include "../wmuse.h"#include "../windows.h"#include "../screen.h"#include "buttons.h"#define SAFETY 1#define VDGSIZE 15360         /* 640x192c2 = 15,360 = 0x3c00 bytes */extern bool    thick;extern ubyte     ichars[192][6];/* Only INITIALIZED D.Page stuff, gets very first locations,*  right where "*NULL = something;" stmts toss grenades.*/direct int dummy =  0; /* For argfix(), and *NULL bug-catcher! */direct ubyte     *vdgram = NULL;     /* T.H.E. VDG page location */direct bool     grafmode = FALSE;/* Direct-Page Statics for Speed *  locals for Line fcns, Bytblt() and friends*  Not really "static", just private unless else noted*/direct int   afxi, afxa1, afxa2;   /* for argfix() */direct int     hgt, width, dy, xl, xr;direct short   /* that's 16 Bits */     *ibase, *iptr,     *igoal,   /* pointer upper/lower limit */     paint, color, bucket;direct sexy     col;       /* column counter */direct ubyte   /* was byte */     *bgoal,   /* pointer limit */     *base,    /* row pointer */     *bptr;     /* byte pointer *//* Savers for beam lines group */int    /* static */    bdeltx, bdelty, bx1, by1, bdy;ubyte    *bbp;    /* static *//* Mask tables for precision horiz line begins & ends *//* Note: right1s[n] == left0s[n + 1], right0s[n] == left1s[n + 1] */char left1s[9] = {0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00};char left0s[9] = {0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF};/**************** Functions ****************************//* BEAM-line drawer.  Draws extra line above self if 'thick',*  and leaves setup values around for later segments of same slop and x1.*  Also leaves 'thick' for followers.*//* Saves for future passes:  deltx, delty, y1, x1, bp. */void bline(x1, y1, x2, y2, thk)    /* no color; always draws */  int    x1, y1, x2, y2;{    int   t;    int   sum, count;    ubyte rotor;    Reg ubyte    *bp;#ifdef SAFETY    if(x1 < 8)    x1 = 8;    else if(x1 >= WID-8)    x1 = WID-8;    if(x2 < 8)    x2 = 8;    else if(x2 >= WID-8)    x2 = WID-8;#endif    if(y1 < 2)    y1 = 2;    else if(y1 >= HM1-1)    y1 = HM1-1;    if(y2 < 2)    y2 = 2;    else if(y2 >= HM1-1)    y2 = HM1-1;    bdelty = y2 - y1;    bdeltx = x2 - x1;#ifdef SAFETY    if(bdeltx < 0) {   /* swap ends? */        t = x1;        x1 = x2;        x2 = t;        bdeltx = -bdeltx;        bdelty = -bdelty;    }#endif/* Make bdelty always be >= 0 */    if(bdelty >= 0)        dy = -COLS;    /* "up" goes lower in memory */    else {        bdelty = -bdelty;        dy = COLS;    }    if(bdelty > bdeltx)    /* Temp hack to limit slope to 1:1 */        bdelty = bdeltx;    bx1 = x1;    /* save for later calls */    by1 = y1;    bdy = dy;/* New tricks  to get equal segments * by aiming at a virtual endpoint higher and wider */    bdelty++;    bdeltx++;    thick = thk;/* FINALLY, init for line drawing! */    sum = -bdeltx;        /* full-length 1st segment, like Kev's */    bbp = bp = vdgram + ((HM1 - y1) * COLS + (x1 >> 3));    rotor = 0x40;        /* always starts on 1 or 9 *//* And get to work! */    for(count = bdeltx; --count >= 0; ) {        *bp |= rotor;    /* plot one point */        if(thick)            *(bp - COLS) |= rotor;        if(rotor < 0)    /* Hack to fake unsigned */            rotor = 0x40;        else if( (rotor >>= 1) ==0) {            bp++;        /* cud do safety clip test here */            rotor = 0x80;        }        if((sum += bdelty) >= 0) {    /* was > 0 */            sum -= bdeltx;    /* For "arthritic" thick line, plot another pt before Y-step */            if(count) {            /* don't on very last pt */                *bp |= rotor;    /* Arthritic joint */                if(thick)                    *(bp - COLS) |= rotor;            }/* Could do safety clip test here */            bp += dy;    /* up or down one pixel */        }    }} /* bline() *//* Repeat the original line, full length, but up or down by 'yd',*  'yd' being relative to y1 of last bline() call. */void bagnline(yd)  int    yd;{     int    sum, count;    ubyte  rotor;    Reg ubyte *bp;    bp = bbp - (COLS * yd);    dy = bdy;    sum = -bdeltx;    rotor = 0x40;    for(count = bdeltx; --count >= 0; ) {        *bp |= rotor;        if(thick)            *(bp - COLS) |= rotor;        if(rotor < 0)            rotor = 0x40;        else if( (rotor >>= 1) ==0) {            bp++;            rotor = 0x80;        }        if((sum += bdelty) >= 0) {    /* was > 0 */            sum -= bdeltx;            if(count) {                *bp |= rotor;                if(thick)                    *(bp - COLS) |= rotor;            }            bp += dy;        }    }} /* bagnline() */    /* Repeat the line as above, but draw only between given xs and xe pts,*  where xs >= original x1, and xe > xs. */void bsegline(yd, xs, xe)  int    yd, xs, xe;{     int    sum, count, wait;    ubyte  rotor;    Reg ubyte  *bp;    bp = bbp - COLS * yd;    dy = bdy;    sum = -bdeltx;    rotor = 0x40;    wait = xs - bx1;    /* no. pts to waste before turning on the ink */    for(count = xe - bx1 + 1; --count >= 0; wait--) {        if(wait <= 0) {            *bp |= rotor;            if(thick)                *(bp - COLS) |= rotor;        }        if(rotor < 0)            rotor = 0x40;        else if( (rotor >>= 1) == 0) {            bp++;            rotor = 0x80;        }        if((sum += bdelty) >= 0) {    /* was > 0 */            sum -= bdeltx;            if(count && (wait <= 0)) {                *bp |= rotor;                if(thick)                    *(bp - COLS) |= rotor;            }            bp += dy;        }    }} /* bsegline() *//** END of Beamers */int zclamp(it, upper)  int     it, upper;{     if(it < 0)          return(0);     if(it > upper)          return(upper);     return(it);}/* Limit given value between Lower and Upper */int clamp(it, lower, upper)  int     it, lower, upper;{     if(it < lower)          return(lower);     if(it > upper)          return(upper);     return(it);}/* Show the VDG graphics instead of the 32x16 text */grafix() {     grafmode = TRUE;}/* Get 32x16 text mode back, but don't release VDG page */text() {     grafmode = FALSE;}/* Release VDG graphics page.  Can be re-allocated later. */release() {     text();             /* mustn't release while visible *//*   vdgram = NULL;      /* let 'em know it's gone */}/* Clear entire VDG screen to back(0) or fore(1) or 2-byte patterns */pcls(keler)  int keler; {     register short *vp;     paint = -keler;     /* works, and still allows patterns */     for(vp = (short *)(vdgram + VDGSIZE); vp > vdgram;  )          *(--vp) = paint;}/* Palette color-changer -- even works on VDG screens */pal(slot, rgb)  byte    slot,     /* 0 or 1 are all we care about */          rgb;      /* 00 -- 63 color code, may be Composite too */{     printf("\x1B\x31%c%c", slot, rgb);     fflush(stdout);}/* Draw a horizontal line of color c==1 (Fore) or c==0 (Back);*  Non-Boolean c's give interesting (!) gray-pattern results.*  91/7/31 Fixed to extend gray-pattern to edge bytes*    and only 2 edge-byte arrays (even better than MM/1!)*  X's still Pixels; Front End fixes this.*/hline(x1, x2, y, c)      short x1, x2, y, c;{#define x1coarse hgt     /* Recycle some direct page */#define x2coarse width     Reg ubyte *bp;     color = -c;    /* all 0s or all 1s */#ifdef SAFETY     argfix(&x1, &x2, 639);/* Clip (no draw) if Y out of range */     if( (y < 0) || (y > HM1) )          return;#endif     x1coarse = x1 >> 3;     x1 &= 7;     x2coarse = x2 >> 3;     x2 = (x2 & 7) + 1;/* Find leftmost byte of line */     bp = vdgram + (HM1 - y) * COLS + x1coarse;/* Special case if starts & ends in same byte (very short!) */     if(x1coarse == x2coarse) {          if(c)               *bp |= left1s[x1] & left0s[x2] & color;          else               *bp &= left0s[x1] | left1s[x2];          return;     }/* Normal cases *//* Draw leftmost byte of line */     if(c)          *bp |= left1s[x1] & color;     else          *bp &= left0s[x1];/* Draw all intermediate solid bytes */     bp++;     for(col = x2coarse - x1coarse; --col ; )          *bp++ = color;/* Draw the final rightmost byte */     if(c)          *bp |= left0s[x2] & color;     else          *bp &= left1s[x2];}/* Draw vertical line.  X is in Pixels. */vline(x, y1, y2, c)  short x, y1, y2, c;{     Reg ubyte *bp;#ifdef SAFETY     argfix(&y1, &y2, HM1);/* Just clip (skip) if X out of bounds */     if( (x < 0) || (x > 639) )          return;#endif/* 'color' is byte but uses 16-bit constants to feed Bit 7 right */     if(c)     /* Foreground */          color = 0x0080 >> (x & 7);     else          color = 0xFF7F >> (x & 7);     bp = vdgram + ((HM1 - y2) * COLS) + (x >> 3);  /* screen hi y */     for(dy = y2 - y1 + 1; --dy >=0;  bp += COLS)          if(c)               *bp |= color;          else               *bp &= color;}/* Compound vertical line(s) using given pattern instead of*    3:8 decode of x_fine.  Xc is in Columns.  Dynamites.*/vpatdyn(xc, y1, y2, pat)      /* y1 < y2 */  sexy    xc, y1, y2;  ubyte   pat;      /* 8-bit pattern */{     register ubyte *bp;#ifdef SAFETY     argfix(&y1, &y2, HM1);     if((xc < 0) || (xc > COLS-1))          return;#endif     color = pat;     bp = vdgram + ((HM1 - y2) * COLS) + xc;  /* screen hi y */     for(dy = y2 - y1 + 1; --dy >=0;  bp += COLS)          *bp = color;}/* New PUT fcns to draw objects that are one or two bytes wide;*  object image must be arrayed from Top Down.*/put1(xc, y, h, what, draw)     /* one-byte wide */  sexy    xc,   /* X in Columns */          y,   /* TOP's location */          h;   /* # lines of height */  byte    *what;    /* the image to put */  bool    draw;     /* FALSE to erase */{     Reg byte  *bp;#ifdef SAFETY     xc = zclamp(xc, 79);     y = zclamp(y, HM1);#endif     bp = vdgram + (HM1 - y) * COLS + xc;     if(draw)          for( ; --h >=0; bp += COLS)               *bp |= *what++;     else          for( ; --h >=0; bp += COLS)               *bp &= ~*what++;}put2(xc, y, h, what, draw)     /* two-bytes wide */  sexy    xc,          y,   /* TOP's location */          h;   /* # lines of height */  short  *what;     /* the image to put */  bool    draw;     /* actually assumes BACK==F, FORE==TRUE */{     Reg short *bp;#ifdef SAFETY     xc = zclamp(xc, COLS-2);     y = zclamp(y, HM1);#endif     bp = (short *) (vdgram + (HM1 - y) * COLS + xc);     if(draw) {          if(h == 16) /* note or rest */               or2_16(bp, what);          else if(h == 15)    /* Barline as of 89/5/22 */               or2_15(bp, what);          else               for( ; --h >=0; bp += 40)                    *bp |= *what++;     }     else          for( ; --h >=0; bp += 40)               *bp &= ~*what++;}/****** "Dynamite" Putters that use Overwrite logic and can't erase.*  Used for drawing digits and other small items that need*    to blast-out the area around themselves.*/dyna1(xc, y, h, what)     /* one-byte wide */  sexy    xc,          y,   /* TOP's location */          h;   /* # lines of height */  byte    *what;    /* the image to put */{     Reg byte  *base;#ifdef SAFETY     xc = zclamp(xc, 79);     y = zclamp(y, HM1);#endif     base = vdgram + (HM1 - y) * COLS + xc;     for( ; --h >=0; base += COLS)          *base = *what++;}dyna2(xc, y, h, what)     /* two-bytes wide */  sexy    xc, y, h;  short   *what;    /* the 2-byte image to put */{     Reg short *base;#ifdef SAFETY     xc = zclamp(xc, COLS-1);     y = zclamp(y, HM1);#endif     base = (short *) (vdgram + (HM1 - y) * COLS + xc);/*     if(h == 15)          dyna2_15(base, what);     else*/          for( ; --h >=0; base += COLS/2)               *base = *what++;}dyna3(xc, y, h, what)     /* three-bytes wide */  sexy    xc, y, h;  ubyte   *what;    /* the 3-byte image to put */{     Reg ubyte *base;#ifdef SAFETY     xc = zclamp(xc, COLS-3);     y = zclamp(y, HM1);#endif     base = vdgram + (HM1 - y) * COLS + xc;     for( ; --h >=0; base += COLS) {       /* Do a byte, then an int */          *base = *what++;          *((short *)(base + 1)) = *( (short *)(what) )++;     }}/* Draw a simple rectangular box.  Pixel X's.*  Double-thick sides.  Can't erase, just draw. */box(x1, y1, x2, y2)  short   x1, y1, x2, y2;{     hline(x1, x2, y2, FORE);     vline(x2, y1, y2, FORE);     vline(x2 - 1, y1, y2, FORE);  /* double-thick sides */     hline(x1, x2, y1, FORE);     vline(x1, y1, y2, FORE);     vline(x1 + 1, y1, y2, FORE);}/* Draw box but with Column-X args.  Slightly rounded edges. *//* Caution: X's and Y's are ASSUMED in ascending order! */boxc(xcl, y1, xcr, y2)  sexy    xcl, xcr;  sexy    y1, y2;{     xl = 4 + (xcl << 3);     xr = 3 + (xcr << 3);     hline(xl, xr, y1, FORE);     hline(xl, xr, y2, FORE);     y1++;     y2--;          /* Slightly rounded corners */     vpatdyn(xcl, y1, y2, 0x18);     vpatdyn(xcr, y1, y2, 0x18);}/* Draw Window Box of given Style.*  Args are Columns and assumed in order.*  Does not do the CLlear.*/void winbox(xcl, y1, xcr, y2, style)  sexy    xcl, xcr, y1, y2, style;{     xl = (xcl << 3);     xr = (xcr << 3);     if(style == WSSHADOW) {          hline(xl + 3, xr + 1, y2,     FORE); /* top */          vpatdyn(xcr,  y2 - 2, y2 - 1, 0x60); /* top rgt corner */          vpatdyn(xcl,  y1 + 4, y2 - 1, 0x30); /* left side */          hline(xl + 8, xr + 7, y1 + 2, 0x56); /* -6A bottom shadow 2 lines */          hline(xl + 8, xr + 7, y1 + 1, 0x56);       /* hline(xl + 8, xr + 7, y1,     0x56); /* was 3rd line */          vpatdyn(xcl+1,y1 + 1, y1 + 2, 0xAA); /* LL corner */          vpatdyn(xcr,  y1 + 4, y2 - 3, 0x6A); /* right side */       /* vpatdyn(xcr,  y1 + 3, y1    , 0xAA); /* LR corner */          vpatdyn(xcr,  y1 + 1, y1 + 3, 0xAA); /* LR corner */          hline(xl + 3, xr + 1, y1 + 3, FORE); /* bottom main edge */     }     else if(style == WSDOUBLE) {       /* Horiz line end pts will be dyna'ed anyway */          hline(xl, xr , y2,     FORE); /* upper top */          hline(xl, xr , y2 - 2, FORE); /* lower top */          hline(xl, xr , y1,     FORE); /* lower bot */          hline(xl, xr , y1 + 2, FORE); /* upper bot */          dyna1(xcl, y2,     3, "\x1f\x30\x63"); /* UL corner */          dyna1(xcl, y1 + 2, 3, "\x63\x30\x1f"); /* LL */          dyna1(xcr, y2,     3, "\xf8\x0c\xc6"); /* UR */          dyna1(xcr, y1 + 2, 3, "\xc6\x0c\xf8"); /* LR */          vpatdyn(xcl,  y1 + 3, y2 - 3, 0x66); /* left side */          vpatdyn(xcr,  y1 + 3, y2 - 3, 0x66); /* right side */     }     else if(style==WSPLAIN)          boxc(xcl, y1, xcr, y2);     else      /* WSNONE, no box at all */          ;}/* Draw box for a push-button.  Rounded sides.*  Y is of the Ruler Line for 7-high chars; XCs outside of letters.*/ubyte *lsides[] = {     "\x0e\x18\x30\x30\x30\x30\x18\x0e", /* ( L ) */     "\x06\x06\x06\x06\x06\x06\x06\x06", /* [ L] */     "\x06\x0c\x18\x30\x30\x18\x0c\x06", /* < L > */  /* "\x06\x06\x06\x06\x06\x06\x06\x06", /* [ L > */     "\xc0\x60\x30\x18\x18\x30\x60\xc0", /* > L > */};ubyte *rsides[] = {     "\x70\x18\x0c\x0c\x0c\x0c\x18\x70",  /* ( R ) */     "\x60\x60\x60\x60\x60\x60\x60\x60",  /* [ R ] */     "\x60\x30\x18\x0c\x0c\x18\x30\x60",  /* < R > */     "\x60\x30\x18\x0c\x0c\x18\x30\x60"   /* [ R > */};ubyte *lboxes[] = {/*   "\x00\x3f\x30\x30\x30\x30\x30\x30\x30\x3f\x00",   /* empty box */     "\x00\x0f\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0f\x00",   /* empty box >>2 *//*   "\x00\x3f\x30\x36\x33\x31\x33\x36\x30\x3f\x00",   /* X in box */     "\x00\x0f\x0C\x0D\x0C\x0C\x0C\x0D\x0C\x0F\x00",   /* X in box >>2 */     "\x00\x00\x00\x1f\x1f\x19\x19\x19\x19\x19\x19",   /* rad top */     "\x19\x19\x19\x19\x19\x19\x19\x1f\x00\x00\x00",   /* rad bot */     "\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19\x19",   /* rad mid */     "\x00\x00\x00\x7F\x7F\x78\x7F\x7F\x00\x00\x00"    /* rad selected */};ubyte *rboxes[] = {/*   "\x00\xfc\x0c\x0c\x0c\x0c\x0c\x0c\x0c\xfc\x00",   /* empty box */     "\x00\xff\x03\x03\x03\x03\x03\x03\x03\xff\x00",   /* mt box >>2 *//*   "\x00\xfc\x0c\x6c\xcc\x8c\xcc\x6c\x0c\xfc\x00",   /* X in box */     "\x00\xff\x03\x9B\xF3\x63\xF3\x9B\x03\xff\x00",   /* X box >>2 */     "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",   /* rad bot */     "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",   /* rad bot */     "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",   /* rad mid */     "\x00\x00\x00\xe0\xf8\x3c\xf8\xe0\x00\x00\x00"    /* rad sel */};void butbox(xcl, xcr, y, style)  sexy    xcl, xcr, y, style;{     int       fudge, yhi, ylo;     if( !style)          return;     ylo = y - 3;   yhi = y + 6;     if(style < 8) {     /* some type of Box */          xl = 6 + (xcl << 3);          xr = 1 + (xcr << 3);          hline(xl, xr, ylo, FORE);          hline(xl, xr, yhi, FORE);          yhi--;          fudge = (--style == BXARROW-1);          dyna1(xcl + fudge, yhi, 8, lsides[style]);          dyna1(xcr,         yhi, 8, rsides[style]);     }     else {    /* Just a two-column [X] or Slider on Left side */          yhi++;          xcr = xcl + 1;          if(style == BXRADSEL) {  /* Slider, 'OR' it in */               put1(xcl, yhi, 11, lboxes[BXRADSEL-8], TRUE);               put1(xcr, yhi, 11, rboxes[BXRADSEL-8], TRUE);          }          else {               dyna1(xcl, yhi, 11, lboxes[style -= 8]);               dyna1(xcr, yhi, 11, rboxes[style]);          }     }}/* BYTBLT() series of rectangle Blit functions * to move the given rectangle to/from a  byte array 'where[].' * Usually called as more mnemonic macros. * XC1 and XC2 are INCLUSIVE of their columns. * Assumes that where[] is big enuf to hold it all! * Code has been optimized to hell and gone; still needs more Int moves.*/bytblt(what, xc1, y1,  xc2, y2,  where)  sexy    what;   /* 0=Get, 1=DynaPut, 2=Clear, 4=Blacken, 3=Invert, 5=OrPut */                  /* 6=Gray */  sexy    xc1, y1, xc2, y2;  ubyte   *where; /* unused on Clear & Blacken */{    register ubyte *rbp;     color = 0;     /* Background */#ifdef SAFETY     argfix(&xc1, &xc2, COLS-1);     argfix(&y1, &y2, HM1);#endif     width = xc2 - xc1 + 1;     /* No. of columns *//* Invert Y's to internal axis & add horiz offset */     base = vdgram + ((HM1 - y2) * COLS) + xc1;     hgt = y2 - y1 + 1;        /* No. of rows to move *//* Choose which way to move what */     switch(what) {     case 0:   /* GET existing picture into a save array */          if((width & 1)==0) {     /* Even */               width >>= 1;               for( ; --hgt >= 0; ) {                    igoal = (iptr = (int *)base) + width;                    for(  ; iptr < igoal;  )                         *((int *)where)++ = *iptr++ ;                    base += COLS;               }          }          else {    /* Odd, do even, then last byte */               width >>= 1;               for( ; --hgt >= 0; ) {                    igoal = (iptr = (int *)base) + width;                    for(  ; iptr < igoal;  )                         *((int *)where)++ = *iptr++ ;                    *where++ = *(ubyte *)iptr;   /* odd byte */                    base += COLS;               }          }          break;     case 1:   /* PUT-Dynamite save-array onto graphics screen */          if((width & 1)==0) {               width >>= 1;               for( ; --hgt >= 0; ) {                    igoal = (iptr = (int *)base) + width;                    for(  ; iptr < igoal;  )                         *iptr++ = *((int *)where)++;                    base += COLS;               }          }          else {               width >>= 1;               for( ; --hgt >= 0; ) {                    igoal = (iptr = (int *)base) + width;                    for(  ; iptr < igoal;  )                         *iptr++ = *((int *)where)++;                    *(ubyte *)iptr = *where++ ;                    base += COLS;               }          }          break;     case 6:   /* CLEAR area to Gray 10101010 */          color = 0x5555;          goto clears;     case 4:   /* PAINT to Foreground  (Cajun Cookin') */          color = 0xFFFF;     case 2:   /* CLEAR area to all-Background */clears:          if((width & 1) == 0) {   /* Even, 16 bits at a time for speed */               width >>= 1;               for( ; --hgt >= 0; ) {                    igoal = (iptr = (int *)base) + width;                    for(  ; iptr < igoal;  )                         *iptr++ = color;                    base += COLS;               }          }          else {               width >>= 1;               for( ; --hgt >= 0; ) {                    igoal = (iptr = (int *)base) + width;                    for(  ; iptr < igoal;  )                         *iptr++ = color;                    *(ubyte *)iptr = color;     /* Odd byte */                    base += COLS;               }          }          break;     case 3:   /* INVERT area */          for( ; --hgt >= 0; ) {               bgoal = (rbp = base) + width;               for( ; rbp < bgoal; )                    *rbp++ ^= 0xFF;     /* XOR; assy use COM */               base += COLS;          }          break;     case 5:   /* PUT-OR save-array onto graphics screen */          for( ; --hgt >= 0; ) {               bgoal = (rbp = base) + width;               for( ; rbp < bgoal; )                    *rbp++ |= *where++ ;               base += COLS;          }          break;      default:     } /* switch */} /* bytblt() *//* Clear entire width of screen between two Y limits to given color. * Uses 16-bit words for extra zip, and gets it!*/yclear(y1, y2, paint)  short y1, y2, paint;   /* NOTE for now, Paint is ignored */{     register short *rsp;     /* bucket = -paint; */#ifdef SAFETY     argfix(&y1, &y2, HM1);#endif     ibase = (int *) (vdgram + ((HM1 - y2) * COLS));  /* lower addr */     rsp = ibase + ((y2 - y1 +1) * (COLS/2));         /* upper addr */     while(rsp > ibase)     /*   * --rsp = bucket; */          * --rsp = 0;} /* yclear() *//* Sort and limit args to screen limits, and NO cheap shortcuts! */argfix(ea1, ea2, limit)  int     *ea1, *ea2, limit;{      if((afxa1 = *ea1) > limit)          afxa1 = limit;     else if(afxa1 < 0)          afxa1 = 0;     if((afxa2 = *ea2) > limit)          afxa2 = limit;     else if(afxa2 < 0)          afxa2 = 0;/* Make afxa1 <= afxa2 */     if(afxa1 > afxa2) {          afxi = afxa1;   afxa1 = afxa2;  afxa2 = afxi;     }     *ea1 = afxa1;     *ea2 = afxa2;} /* argfix *//************************* Draw a 5-line staff whose bottom left corner   is at x,y.  Include left bar iff left==TRUE.   No Clef or right barline.*/staff(x, y, left, halftone)  sexy    x, y;  bool    left, halftone;{    register short  *usp;    if((y > HM1-18) || (y < 0))        return; /* no room at the top! */    ibase = (int *)(vdgram + ((HM1-y) * COLS));/* Left vertical barline, if desired.  Uses x. */    if(left) {        usp = ((ubyte *)ibase + x);        for(dy = 18; --dy; ) {            *usp = 0xC000;            usp -= 40;                       }    }/* Always draw the five horiz lines, full width of screen */    color = halftone ? 0xAAAA : 0xFFFF;    usp = ibase;    for(dy = 6; --dy; ) {        for(width = 41; --width; )            *usp++ = color;        usp -= (160+40);    /* up 4 lines plus the one just drawn */    }}/********** Text-printing fcns **********//* Type one phrase line of null-term'ed text at given XC, Y.*  Y is of ruler line; descenders go one below that;*    letters go from 4 above it.  Clears a line above that.*  If 'caps' is True, the line above and descender line are omitted.*/phrase(xc, y, s, caps)  sexy    xc, y;  char    *s;  bool    caps;     /* for Menu Bar */{     Reg char  *cbase;     char      c;     y = clamp(y + 4, 5, 190);     cbase = vdgram + COLS * (HM1 - y) + xc;     while(c = *s++) {          bptr = ichars[c - ' '];/*        *(cbase - COLS) = 0;   /* Clear line above letter */          *cbase = *bptr;      /* Top of char */          *(cbase +  COLS) = *(bptr + 1);          *(cbase + 2*COLS) = *(bptr + 2);          *(cbase + 3*COLS) = *(bptr + 3);          *(cbase + 4*COLS) = *(bptr + 4);          if( !caps)               *(cbase + 5*COLS) = *(bptr + 5);  /* Descender */          cbase++;     }} /* phrase() *//* End of grafix fcn bodies *//* eof ~FWm640/fgraf.c */