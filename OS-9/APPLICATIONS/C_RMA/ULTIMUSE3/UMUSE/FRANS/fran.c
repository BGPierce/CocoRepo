/* ~VM640/FRAN.C  (VDG Front End) * Main Program File for Rcving End of Pipeline* Receives grafix cmd bytes from Umuse via Pipeline,* collects args, and dispatches to appropriate routine.*//* TEST version uses sparse table with linear-search lookup.*  Final version will have solid table, direct array access.*/#define FRANPRY     160  /* anything over 140 is good */#include <stdio.h>#include "../wcodes.h"  /* Also requires syscall.r */#include "../wmuse.h"  /* General defns */#include "../wmenu.h"#include "../vgraf.h"#include "../version.h"#include "../mencodes.h"#include "../macros.h"/* Both sets of I/O fcns return # of items, ==0 for EOF||error */#define TEST   1#define Read(buf, n)     fread(buf, 1, n, stdin)#define ReadOne(c)       c = getchar()#define Write(buf, n)    fwrite(buf, 1, n, stdout)extern direct ubyte     printype,     *vdgram;   /* T.H.E. VDG page location */extern ubyte     *makevdg(),     ichars[96][6],     brushsave[];extern short     iclefs[4][CLEFHGT];extern direct sexy     numer, denom, keysig,     brushx, brushy, tooly,   /* Y's need int! */     nstaves;extern NOTE     brush;    /* aka Rep */extern void    /* Fcns called directly by dispatcher */     prtboss(),     patience(),     yesno(),     wkill(),     dnota(),     drsta(),     storf(),     drsys(),     erbrush(),     dmenbar(),     mainbord(),     grafix(),     text(),     release();extern direct bool     grafmode, tgwmode;extern int     squeeze();direct byte     arg0,arg1,arg2,arg3,arg4,arg5, arg6,     nowcolor = FORE,    /* current color setting */     broke;    /* Signal flag *//* Many globals necessary for "erase most recently drawn" commands */direct sexy     lastaffy, lastclef,     lastnrx, lastnry;   /* coords of last note/rest erased *//** Save/Restore background rectangles behind note/rest being placed **/#define SAVL  1     /* define rectangle around note */#define SAVR  1#define SAVT 54     /* above staff */#define SAVB 42     /* below staff, was 42 til 91/10/1 *//* Extra 16 lines of height in case of top-voice rests */ubyte scene[(SAVL + SAVR + 1) * (SAVT + /* 16 + */ SAVB + 1) + 2];#ifdef PUTGET#define NARRAYS     1ubyte *pgarrays[NARRAYS] = {     scene,};#endif/****** Don't get BREAKed with a VDG Screen active ****/catcher(sigtype)  int sigtype;{     beepa();     broke++;}/* Allocate a "VDG" screen:  640x192x2 = 15,360 bytes.  Set vdgram.  *//* But now merely maps in proper L2 screen, much simpler */ubyte *makevdg() {     if(vdgram == NULL)  { /* Permit only ONE allocation at a time */          mapwin();      /* in fpix.a */          return(vdgram);     }}/************ Yes, VFE must have a Main Street */main() {     char buff[BUFFSIZE], *ch;/* Initialize all kinds of stuff */     spinit();     intercept(catcher);     broke = 0;     setpr(getpid(), FRANPRY);     stdin->_flag |= _SCF;    /* force not read(), but readln() *//*unlink("/r0/franout");freopen("/r0/franout", "w", stderr);*/     curinit();/* Allocate and show VDG screen on your own *//* Colors are RG|Brgb */     if( !makevdg()) {          printf("Fran: No Graphics screen, 'bye!\n");     /* need to kill Bill here -- if he pipes you his PID */          exit(37);     }     else {          printf("Screen at $%04x\n", (int) vdgram);          sleep(1);     }     grafix();/* Pal's needed so user sees solid title frame during image load */     pal(1, 1);     /* Foreground, Navy Blue */     pal(0, 0x18);  /* Medium Cyan. */     pcls(-(0x5555));     opnload(ichars, "/DD/SYS/chars.img", sizeof(ichars), buff);     upmenu(MEN_SIGNON);     /* sign-on copyrt msg */     sprintf(buff, "    Version %d.%d.%d%c\n\n",       UMLEVEL, SCLEVEL, RVLEVEL, RVSUBLET);     pat(buff);     setcurse(1);     imgload();     dispatch();    /* Wait on the boss forever */     release();     /* or till death do you part */     exit(0);}/* Intermediate linking fcns to call grafix.c fcns --*  these middlemen may be deleted from time to time...*  They all have ONE arg, the command byte that called them.*  All real args come from arg0, arg1, ... arg15.*//* Greasy fundamentals */void pala() {     pal(arg0, arg1);}/* Setups & Definitions */defsa() {     dfstaff(arg0, arg1, arg2 & 255);}udfsa() {     fgstaff(arg0);}defpa() {     dfpart(arg0, arg1, arg2 & 255,       arg3, arg4, arg5 & MCHORDS);}udfpa() {     fgpart(arg0);}sksa() {     keysig = arg0;}stsa() {     numer = arg0;     denom = arg1 & 31;}/* Clears & Refreshers */claa() {     pcls(arg0);}cssa() {     yclear(SCROLTOP + 1, SCORTOP, BACK);}drepa() { /* Draw Brush rep */     brushx = arg0;  /* save these for later erasure */     brushy = arg1 & 255;     drbrush(&brush, arg2 & 255);}dfrna() {     brush.slot = arg0;     brush.dur = arg1;     brush.durmod = arg2;     brush.artic = arg3;}scrla() {     scroll( *(int *)&arg0, *(int *)&arg2, *(int *)&arg4);}scrma() {     sexy howmuch;  /* scaled 0 -- 255 */     howmuch = arg1 & 255;     scroll(257, howmuch, howmuch + 2);}rftba() { /* ReFresh (draw) ToolBox */     tooly = arg0 & 255;     drtools(arg1 , arg2);}/* Mouse & Cursor */scura() {     setcurse(arg0);}dcura() {     cursor( *(int *)&arg0, arg2 & 255);}/* Active Drawing */drsha() {     storf(arg0, arg1 );}drsa() {     lastaffy = arg0 & 255;   /* global for later erasure */     lastclef = arg2;     staff(0, lastaffy, arg1, arg3);     put2(SCORLEFT+1, lastaffy + CLEFYOFF-1, CLEFHGT, iclefs[lastclef], FORE);}ersa() {  /* Erase most recently drawn staff & clef */     yclear(lastaffy, lastaffy + 16, BACK);     put2(SCORLEFT+1, lastaffy + CLEFYOFF-1, CLEFHGT, iclefs[lastclef], BACK);}dralstcl() {  /* Draw all Staves with Clefs */     sexy      st, staffy;     ubyte     *imp;/* arg0 == leftline *//* arg1 == left x  (usu. 0 or 1 ) 90/7/29 *//* arg2 == halftone 97/4/5 */     for(st = nstaves; --st >=0; ) {          getstaff(st, &staffy, &imp);     /* Begin staff no farther right than Col 0 or 1 (from MM/1 93/4/14) */          staff(arg1 ? 1 : 0, staffy, arg0, arg2);          put2(arg1 + arg0, staffy + CLEFYOFF-1, CLEFHGT, imp, FORE);     }}dcrsa() { /* Draw Crescendo (and later Accel) */     drawcresc(arg0, arg1, arg2, arg3);}drsys() {  /* Draw System Braces */     sexy      st, staffy;     int       maxy, miny;     ubyte     *imp;     miny = 191;    maxy = 0;     for(st = nstaves; --st >=0; ) {          getstaff(st, &staffy, &imp);          if(staffy > maxy)   maxy = staffy;          if(staffy < miny)   miny = staffy;     }     vpatdyn(0, 0, 191, 0);     dyna1(0, maxy + 18, 4, "\x0c\x18\x30\x60");     dyna1(0, miny + 1, 4, "\x60\x30\x18\x0c");     vpatdyn(0, miny + 2, maxy +14, 0xE0);}daksa() {     drawks(arg0, arg1);    /* Key sig is Signed */}datsa() {     drawts(arg0, arg1, arg2);}dxlva() {     drlevel(arg0, arg1 & 255, arg2 );}dinsa() {     drinstr(arg0, arg1 & 255, arg2);}dmcha() {     drmchop(arg0, arg1 & 255, arg2);}dpeva() {     drprtevt(arg0, arg1 & 255, arg2);}/* Global Inclusions at top margin */dglia() {     int  notex;     notex = arg0;     arg2 &= 255;     if(arg1 == NUTEMPO)          drawtmp(notex, arg2);     else if(arg1 == GENVOL)          drawgenv(notex, arg2);     else if(arg1 == CLOCKON)          drawclk(notex, arg2);     else if((arg1 == ISEVT) || (arg1 == TSEVT))          drsysevt(notex, arg2);     else if(arg1 == ACCENT)          drawaccent(notex, arg2);/**  For future "Concert Pitch" KeySig --*     else if(arg1 == KEYSIG)*          drawks(notex, arg2);     /* Signed value *//* no default case; ignore if undefined */}dlaba() {     drawlab(arg0, arg1, arg2);}diasa() {      /* Takes 16-bit BCD 89/9/22 */     putalst(arg0, arg1 & 31, *((int *)&arg2) );   /* need & 31? */}/* Draw/Erase Artic(color, x, y, what, stemdn) */arta() {     drawart(arg0 , arg1, arg2 & 255, arg3, arg4 );}slaya() { /* Show Layout */     showglay(arg0, arg1);}/* Placement */getnbak() {     Get(lastnrx-SAVL, lastaffy-SAVB, lastnrx+SAVR, lastaffy+SAVT, scene);}putnbak() {     Put(lastnrx-SAVL, lastaffy-SAVB, lastnrx+SAVR, lastaffy+SAVT, scene);}gaboa(){     if(arg0) {          gtext();          pat("\f\n\n  RELEASE TO ABORT\n");     }     else {          wkill();  /* tgrafix(); *//* If this is needed, is bug in wkill() */          tgwmode = FALSE;    /* Not needed but is */     }}/* Line Drawers */hlina() {     hline( *((int *)&arg0), *((int *)&arg2),       arg4 & 255, arg5 & 255);}vlina() {     vline( *((int *)&arg0), arg2 & 255,       arg3 & 255, arg4 & 255);}blinea() {     bline( *((int *)&arg0), arg2 & 255,            *((int *)&arg3), arg5 & 255, arg6);}bagnla() {     bagnline(arg0);     /* DO want "sex" for delty */}bsegla() {     bsegline(arg0, *((int *)&arg1), *((int *)&arg3) );}/* Boxers *//* Draw a FOREground box around the coordinates */boxa() {     boxc(arg0, arg1 & 255, arg2, arg3 & 255);}/* Draw a box using XOR Logic (even-numbered calls erase it) *//*   XBOX, 4, xboxa}, *//* Invert-video all pixels inside the virtual "box" */nboxa() {     Invert(arg0, arg1 & 255, arg2, arg3 & 255);}/* Gray-scale (half-tone) contents of virtual "box" *//*   GBOX, 4, gboxa}, */#ifdef PUTGET/* Save the scene inside the "box" */geta() {     sexy what;     if((what = arg4) >= sizeof(pgarrays)/sizeof(ubyte *))          return;     Get(arg0, arg1 & 255, arg2, arg3 & 255, pgarrays[what]);}/* Restore scenery */puta() {     sexy what;     if((what = arg4) >= sizeof(pgarrays)/sizeof(ubyte *))          return;     Put(arg0, arg1 & 255, arg2, arg3 & 255, pgarrays[what]);}     #endif/* Clear to BACKground inside "box" */clra() {     Clear(arg0, arg1 & 255, arg2, arg3 & 255);}/********* Text, Menu, & Window Fcns ***********/acura() {     alcurset(arg0);}phrsa() {      /* 3rd arg (String) is read by fcn itself */     char buff[81];     gets(buff);    /* How to smear a program... */     phrase(arg0, arg1 & 255, buff, arg2);}dbcda() {     drawbcd(arg2 & 255, arg0, arg1 & 255);}/*   HBCD, 3, hbcda}, */menua() {      /* 2nd arg in table is just the \n */     upmenu(arg0);}/*   MEND, 0, menda}, */owsta() {     wcreate(arg0, arg1 & 255, arg2, arg3, arg4, arg5);}/*   ALRT, 0, alrta}, *//*   ATXT, 0, atxta}, *//*   ETXT, 0, etxta}, */flsha() {     /* fflush(stdout); */}/* Miscellaneous *//* Full-Screen dump to printer.  Handles various printers via arg0 */dumpa() {     printype = arg0 & 15;     ndump(192);}/* For Unimplemented fcns; assume dispatch() reads off the args. */unimp() {}/* Ring the chimes.  Later add various styles. BEEP, 1, beepa */beepa() {     putc(7, stdout); /* had \n too */}/* die() {     exit(0);  } *//* End of intermediate fcns */typedef struct {#ifdef TEST     ubyte     code;     /* command op-code */#endif     byte      nargs;    /* no. of arg bytes to collect */     short     (*fcn)(); /* the subr to execute */} FE;                    /* howe does this relate to PMSL? */#ifdef TEST/* Fcn names ending in 'a' work directly from the argbox[] *//* Some arg counts are inflated by +1 to eat final NEWLINE. */FE   fes[] = {      /* Sparse cmd table */  /* In a hurry */     {DNOT,5, dnota},    /* was 10 90/5/26 */     {DRST, 4, drsta},   /* was 5 *//* Greasy fundamentals */  /* {ALOV, 1, makevdg}, */  /* {SHOV, 1, tgrafix}, */     {HIDV, 1, gtext},  /* {DALV, 1, release}, */     {PAL , 2, pala},/* Clears & Refreshers */     {CLA,  1, claa},     {CSS,  0, cssa},     {DREP, 3, drepa},     {EREP, 1, erbrush},     {DFRN, 4, dfrna},     {SCRL, 6, scrla},     {SCRM, 1, scrma},     {MBAR, 0, dmenbar},     {MBRD, 0, mainbord},     {RFTB, 3, rftba},/* Mouse & Cursor */     {SCUR, 2, scura},     {DCUR, 4, dcura},/* Active Drawing */     {DRS,  4, drsa},     {ERS,  0, ersa},     {DAS,  3, dralstcl},     {DRSH, 3, drsha},   /* includes newline ignored by storf() *//* DNOT, DRST really belong here; up front for speed */     {DAKS, 2, daksa},     {DATS, 3, datsa},     {DXLV, 3, dxlva},     {DINS, 3, dinsa},     {DMCH, 3, dmcha},     {DGLI, 3, dglia},     {DIAS, 4, diasa},     {ART,  5, arta},     {DCRS, 4, dcrsa},     {SLAY, 3, slaya},   /* incl \n.  Probably out of order */     {DPEV, 3, dpeva},   /* Draw Part Event.  930412 */     {DLAB, 3, dlaba},   /* Draw Label 940127 *//* Placement */     {GBG,  1, getnbak}, /* incl \n */     {PBG,  1, putnbak}, /* incl \n */     {ENP,  0, unimp},     {GABO, 1, gaboa},/* Line Drawers */     {HLIN, 6, hlina},     {VLIN, 5, vlina},     {BLINE, 7, blinea},     {BAGNL, 1, bagnla},     {BSEGL, 5, bsegla},/* Boxers */     {BOX,  4, boxa},     {XBOX, 4, unimp},     {NBOX, 4, nboxa},     {GBOX, 4, unimp},#ifdef PUTGET     {GET,  5, geta},     {PUT,  6, puta},#endif     {CLR,  5, clra},    /* 5th is Color, ignored! *//* Setups & Definitions */     {DEFS, 3, defsa},     {UDFS, 1, udfsa},     {DEFP, 6, defpa},     {UDFP, 1, udfpa},     {SKS,  1, sksa},     {STS,  2, stsa},/* Text, Menu, & Window Fcns */     {PHRS, 3, phrsa},     {DBCD, 3, dbcda},     {HBCD, 3, unimp},     {PATI, 1, patience},     /* just the NL */     {ACUR, 2, acura},   /* 2nd is NL */     {MENU, 2, menua},   /* 2nd arg is just the REQUIRED \n */     {MEND, 0, unimp},     {OWST, 6, owsta},   /* one extra for \n */     {OWEN, 1, wkill},     {ALRT, 0, unimp},     {YSNO, 2, yesno},     {ATXT, 0, unimp},     {ETXT, 0, unimp},     {FLSH, 1, flsha},   /* Arg is just the \n to eat *//* Miscellaneous */     {DUMP, 2, dumpa},   /* extra arg for \n */     {DMPS, 6, prtboss}, /* Squeeze dump */     {SQZ,  1, squeeze}, /* just \n */     {DSYS, 1, drsys},     {BEEP, 1, beepa},/* The End *//*   {DIE, 0, die}, */     {MAXCODE + 1, 0, NULL}  /* MUST end with illegal cmd code */};#else/* Following will get monstrous initialization, later */FE   fes[MAXCODE + 1 - 128];  /* the dispatch table */#endif/* Fran's Main Loop -- over & over till user quits */dispatch() {     char buff[65];     sexy ntoget;     int  result, (*thisfcn)();     byte cmd, prevcmd = 0;     sexy i, cmdtemp;     register FE    *feptr;     while(TRUE) {          result = Read(&cmd, 1);   /* get a byte */          if( !result) {           /* EOF */               text();/*             printf("\nFran: Normal EOF.\n"); */               break;              /* exits main loop */          }          if(cmd >= 0) { /* Not a command code */               if(tgwmode)                    vanna(cmd);  /* for now *//* Just chew thru non-negative bytes till a cmd *//* else     alert("Fran: Not a cmd; prev. cmd:", 2, cmd, prevcmd); */               continue;          } /* not op code *//* prevcmd = cmd; */          if(cmd > MAXCODE) { /* Illegal op code */               illegal(cmd);  /* so kvetch */               continue;          }/* Look up op code in table */#ifdef TEST          for(i = 0, feptr = fes; ;i++, feptr++) {               if( ((cmdtemp=feptr->code)==cmd) || (cmdtemp==MAXCODE+1) )                    break;          }          if(cmdtemp == MAXCODE + 1) {               illegal(cmd);               continue;          }#else          feptr = fes + (cmd -128);#endif          thisfcn = feptr->fcn;          if(ntoget = feptr->nargs)      /* yes, '=' */               result = Read(&arg0, ntoget );          if(result < ntoget) {            /* text();   /* no work anyway */               fprintf(stderr,                 "\n\007Fran: EOF in Cmd $%2x;\n need %d args, got %d.\n",                 (cmd | 128) & 255, ntoget, result);               break;          }     /* Fcns are called with the cmd code, so several codes     *  can go to one fcn and it can tell which code it was.     */          result = (*thisfcn)(cmd);     /* Analyze result if desired */     } /* cmd-&-args loop*/} /* dispatch() *//* Can be called directly, or from dispatch table */illegal(cmd)  int     cmd;{     char buff[65];/*   text();   /* meaning 32x16 greenie */     sprintf(buff, "\n**Fran: Illegal Cmd $%02x\n", cmd & 255);     pat(buff);/* Try to find next command */     do {          cmd = getchar();          sprintf(buff, " %2x", cmd);          pat(buff);     } while(cmd & 0x80 != 0);     if(cmd == EOF) {          printf("\nFran found EOF, 'bye.\n");/* SHOULD kill Bill here */          release();          exit(1);     }     pat("\nWait a few sec...");     tsleep(100);/*   grafix();      /* back to VDG 640 */}/* eof ~Vm640/fran.c */