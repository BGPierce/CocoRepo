/* FPRINT.C  Fran's part of Music Printer *//* Auto'ly corrects for roundoff errors in page Y.*  Does NOT leave /p opened except when in use.* 901027 verfied that Xmode /P -lf makes no diff on Tandys,*  which are showing some page drift problems.*  CGP-220 uses wider vertical pitch, much grief!*    Only in Grafix Mode, by ratio of about 9/8 or 81/72.*/#include <stdio.h>#include "../wmuse.h"/* Everything measured in "points" of 1/72 inch.*  Standard printer text linefeed is 12/72, or 6 lines/inch.*/#define TOPMARG     48   /* 4 lines, was 3, 4/97 */#define BOTMARG     48#define PAGE        792  /* 11" * 72 pts/in */#define CGPAGE      730  /* for CGP-220, by experiment */#define CGP220      3    /* printype */#define FRANPRY     160  /* must agree with fran.c's */extern direct ubyte     *vdgram,     pnrows;extern direct byte  arg0, arg1, arg2, arg3, arg4;direct FILE    *fprtr;   /* declared int* in some other places */direct int     printy;   /* current vert printer pos on page */direct ubyte   printype, /* printer type code */               prpage;direct bool     dosqueeze,     doesff,     automarg;char *blank35 = "                                   ";void putprtr(ch)    /* Putchar() for assy printer routines */  char    ch;{     putc(ch, fprtr);}/* Dump 'pnrows' worth of lines of grafix */void dumper() {     if(fprtr = fopen("/p", "w")) {          fprtr->_flag |= _RBF;    /* avoid writeln() edits! */          setpr(getpid(), 128);    /* don't hog the machine */          dump();   /* printype == printer type, pnrows == #rows */          fclose(fprtr); /* includes an fflush() */          setpr(getpid(), FRANPRY);     }}/* Find how many actual lines are needed for a given # of Y pixels,*  since printers must do integral # of head sweeps.*  CGP-220's larger vertical pitch is not yet allowed for.*  Side effect sets 'pnrows' in dump.a  */int roundup(npix)  int     npix;{     int  head;     head = (printype > 3) ? 8 : 7;    /* Not Tandy : Tandy */     npix = zclamp(npix, 192);     pnrows = (npix + head - 1) / head; /* Force round-up */     npix = head * pnrows;    /* Exact number of vert pixels *//* MM/1 omits the next line.  Why?? *//*   if(pnrows > 27)     pnrows = 27; */     return(npix);}/* For ^C one-shot quickie dump, from Fran */int ndump(npix)  int     npix;{     npix = roundup(npix);     dumper();     return(npix);}/* To test for a blank line.  Ignores Column 0, System Braces. */bool blank(lnum)  int     lnum;{     ubyte     *ubase;     Reg ubyte *usp;     ubase = vdgram + 80 * lnum;     for(usp = ubase + 79; usp > ubase; )    /* '>' ignores Column 0 */          if(*usp--)               return(FALSE);     return(TRUE);} /* blank() *//* Fcn to take a completed VDG drawing and squeeze out any wasted* horizontal space, meaning more than 2 consecutive horizontal strips* of background.  Pushes everything upwards.* Returns no. of vert lines remaining; ==192 if no gain.*/int squeeze() {     int     curline, nblanks, botline;/* alert("Squeeze(): dosqueez==", 1, dosqueez); */     botline = 191;     nblanks = 1;   /* not 0, to push to very top of screen */     for(curline = 0; curline <= botline; curline++) {          if(blank(curline)) {     /* Blank, just count for now */               nblanks++;               continue;          }          if( !dosqueez || (nblanks < 2)) {   /* Not blank; any accumulated? */               nblanks = 0;   /* Not enuf, keep looking */               continue;          }     /* Reduce blank lines out */          nblanks--;     /* always leave one blank line */          strdn(vdgram + 80 * (curline - nblanks),            vdgram + 80 * curline,            80 * (botline - curline + 1) );          curline -= nblanks;          botline -= nblanks;          nblanks = 0;     }/* Done.  Credit for any blank lines at bottom */     if(botline < 191)          yclear(0, 190 - botline, 0);     return(botline - nblanks + 1);} /* squeeze() */               /* Eject page to bottom fold */void eject() {     int  quot, Page;     Page = (printype==CGP220) ? CGPAGE : PAGE;/* Figure how many linefeeds to reach page bottom */     quot = (Page+6 - printy) / 12;     if(quot > 63)  /* No eject if at top of page */          quot = 0;     if( (printy += quot * 12) > Page)          printy -= Page;     if(fprtr = fopen("/p", "w")) {          fprtr->_flag |= _RBF;          for( ; quot > 0; quot--) {               if(quot == (BOTMARG/12)) {                    fprintf(fprtr, "%s-%d-\r", blank35, prpage);                    if(doesff) {                         putprtr('L' & 31);  /* FF */                         printy = 1;    /* Perfect! */                         break;    /* no more LFs */                    }                    else if(printype > 3)    /* non-Tandy, so */                         putprtr('\l'); /* add LF */               }               else                    putprtr('\l'); /* chug another blank line */          }          fclose(fprtr);     }     prpage++;} /* eject() *//* Overseer function.  Controlled by arg0; arg1 is printype. */void prtboss(){     int  hgt, quot, Page;     printype = arg1 & 15;     dosqueez = arg2;/* alert("Prtboss() set dozqueez==", 1, dosqueez); */     doesff = arg3;     automarg = arg4;     Page = (printype==CGP220) ? CGPAGE :PAGE;     switch(arg0) {     case 'b': /* Begin -- assume user has topped printer paper */          prpage = printy = 1;    /* Org 1 not 0 */          break;     case 'd': /* Do dump some stuff */          hgt = roundup(squeeze());/* At top of page, more or less? */          for(;;) {               if( (printy  < TOPMARG) || (printy >= Page-6) ) {                    if(fprtr = fopen("/p", "w")) {                         fprtr->_flag |= _RBF;     /* Eject TOPMARG-1 lines via '\l' */                         if( !automarg)                              fprintf(fprtr, "\l\l\l");                         fprintf(fprtr, "%s-%d-\r", blank35, prpage);                         if(printype > 3)                              putprtr('\l');                         fclose(fprtr);                    }                    if((printy += TOPMARG) > Page)                         printy = automarg ? (TOPMARG+1) : (printy - Page);                    break;               }/* Will it fit in remaining page space? */               if((printy + hgt) > Page - (BOTMARG+12))                    eject();  /* this changes printy */               else                    break;          } /* for *//* Print it */          dumper();          printy += hgt;     /* Slip one 12/72" linefeed after pix */          if(fprtr = fopen("/p", "w")) {               fprtr->_flag |= _RBF;               putprtr('\l');               fclose(fprtr);          }          printy += 12;          break;     case 'e': /* Eject final page */          eject();          break;     case 'q': /* Quick one-shot squeezed dump */     case '1': /* 192-high fixed quickie */          ndump( (arg0=='q') ? squeeze() : 192);          break;     default:     } /* switch() */} /* prtboss() *//* eof fprint.c */