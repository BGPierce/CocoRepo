/* file MENSUBS.C   --4B--*  Instrument menus, plus subrs for menus, pipes, plus misc. human I/O fcns.*/#define FRAG 1#include <stdio.h>#include "wmuse.h"#include "mencodes.h"#include "wcodes.h"#include "windows.h"#include "screen.h"#include "cursors.h"#include "vmem.h"#include "fcnptrs.h"#include "soowee.h"#define UPARROW     12   /* Coco, not MM/1 or PC */#define DNARROW     10#define LFTARROW    8#define RITARROW    9#define PAGEUP      '<'#define PAGEDN      '>'/* Note: Channel #s are kept 0--15, as actually transmitted */extern ubyte     chans[NPARTS + 1];extern direct bool     rfr_scr, sticky;extern char     instnams[NINSTRS][INAMEL];extern sexy     ioff, instvals[];extern direct sexy    nparts, curcurse;extern ubyte percmids[17];extern char  *percnams[17],             percsynth[24];/* format strings for talking thru the pipe */extern direct char    *pct2, *pct3, *pct4, *pct5, *pct5, *pct6, *pct7,    *pctn1, *pctn2, *pctn3, *pctn4;/* Fcn pre-decls */sexy hexc2i();int onehex() {    /* eats one char, tries to hex->int it */     char ch;     return(hexc2i((*pcharmaus)(&ch)) );}/* Wait for mouse to be released.  No-op if not being held. */void waitmouse() {     int     x, y;     while((*pmouce)(&x, &y) != 0)          tsleep(4);     /* meaning 3 ticks */}/* Fcn to print a menu plus "Choice:" and collect prompted response.*  Note: ENTER returns '\n', not '\0'.*  87/8/29 reads ONE char w/out ENTER; caller must get any more.*  88/1/2  no longer clears screen unless your 1st string has a ^L.*  89/10/13 Mouse click serves as an ENTER for default out of menus.*/prmenu(code, answer)  sexy    code;  char    *answer;  /* set to NULL to skip reading response */{     menu(code);     waitmouse();     (*pprintf)("  Choice: ");     alcurset(TRUE);     if(answer)          (*pcharmaus)(answer);}/* Prompt and read an integer; blank ENTER returns given 'def'. *  If prompt string contains a "%d", "%x", etc.,*    the default value will be shown to user.*  User can type '0' and force a zero return value.*/int getdefp(prompt, def)  char    *prompt;  int     def;{     char buff[BUFFSIZE];     (*pprintf)(prompt, def);     /* ignores def if prompt has no "%d" */     (*pgets)(buff);     if(! *buff)              /* just ENTER */          return(def);     else         return(atoi(buff));}int clamp(it, lower, upper)  int     it, lower, upper;{     if(it < lower) return(lower);     if(it > upper) return(upper);     return(it);}/* Convert ONE hex-digit lower-case char to an integer.*  We permit hex digits greater than 'f', on purpose.*  Returns zero for invalid char.*/#define TOPHEX 'g'  /* Max "hex" char allowed (g == 16.) */sexy hexc2i(c)  char c;{     c -= '0';     if((c >= 0) && (c <= 9))          return(c);     c -= ('a' - '0');     if( (c >= 0) && (c <= (TOPHEX - 'a')) )          return(c + 10);     return(0);} /* hexc2i() *//* Inverse of above; no hard limit */char i2hexc(i)  sexy    i;{     i &= 31;       /* super-MPARTS */     if(i <= 9)          return(i + '0');     return(i + ('A' - 10));} /* i2hexc() *//******** Instrument Menu package *//* Korg DW8000 and Roland MT-32 use a strange sort of offset Octal,*  where LEDs 11-88 map into MIDI values 0.-63.*  Other brands use straight Decimal 1-128,*  but in all case actual MIDI values are 0-127, which we store.*  However, Decimal patches have Bit 7 set as format flag.*  Decimals print with leading '.', Octals with 'o'.*  Octals also use leading '.' PLUS a '0',*    unless > 088; then subst 'o' for '.'  (03/4/19)*/char *prpatch(k, str)  sexy k;  char *str;        /* must be at least 5 bytes long */{     *(str + 4) = '\0';     *str = '.';/* "sign bit" (still positive) means straight decimal */     if((k & 128) != 0) {     /* YES, you must say != 0 */          (*psprintf)(str + 1, "%3d", (k & 127) + 1);     }     else {              /* "positive" means Korg Funny Octal */          if(k & 64)               *str = 'o';    /* over the '.' */          *(str + 3) = (k & 7) + '1';          *(str + 2) = ((k >>3) & 7) + '1';          *(str + 1) = (k & 64) ? '1' : '0';     }     return(str);} /* prpatch() *//* Display instrs and settings in existing window *//* 97/2/10 NILINES, offset, and Western steda Oriental scan */void instrsho() {     char iused[NINSTRS], ps1[5], ps2[5];     int  line, i, ip1;     Reg EVENT *evp;/* Tag in-use instrs with a '+' sign */     for(i = NINSTRS; --i >= 0;  )          iused[i] = ' ';     for(evp = i2p(nevents-1); curind > 0; evp = decdec() )          if( !evp->part && (evp->show.INCTYPE==INSTR))               iused[evp->show.INSTRNO & MINSTRS] = '>';/* Show 'em */     for(line=0, i=ioff, ip1=i+1;       line < NILINES;       line++, i += 2, ip1 += 2) {          (*pprintf)("%c%2d%4s %-15s  %c%2d%4s %-15s\n",            iused[i], i,  prpatch(instvals[i],  ps1), instnams[i],            iused[ip1], ip1, prpatch(instvals[ip1], ps2), instnams[ip1]);     }} /* instrshow() *//* Instrument/Patch-editing top menu.  To textmenu() 93/4/19 *//* Added swap, copy, usedinstrs 96/8/16 *//* 64 instrs with scrolling 97/2/17 */void instrmen(){     char buff[BUFFSIZE], ps1[6], swapname[INAMEL];     bool menuon;     sexy srcnum, destnum, swap;     sexy ih, i, cm, savecurse;     char *nam, ch, what;     register char *cp;     savecurse = curcurse;     curset(CARROW);     menuon = FALSE;     for(;;) {          if(ioff < 0)     ioff = 0;          if(ioff > (NINSTRS-2*NILINES))               ioff = NINSTRS-2*NILINES;          ioff &= 0xFE;     /* force Even */          if( !menuon) {               menu(MEN_INSTRS);   /* really just a wcreate() */               menuon = TRUE;          }          (*pprintf)("\014           INSTRUMENTS\n");          instrsho();          (*pprintf)( " [Percussion...]         (Clear all)\n");          (*pprintf)( " (Read file...)          (Write file...)\n");          (*pprintf)( " <Kopy>                  <Move>\n");          (*pprintf)( " <Swap>                  <X-out>\n");          (*pprintf)( " (Back in list)          (Forward list)\n");          (*pprintf)( "\n   Cmd or Instr. No: ");/* A customized smart gets() with mouse-click ENTER ability.*  Gets one char, or two chars if 1st is '1'-- '6' */          for(cp = buff; ; cp++) {               *(cp + 1) = '\0';     /* save bother later */               cm = (*ptextmen)(INST_LCOL, INST_TOPY, (INST_CWID+1)/2,                 2, 1, NILINES + 5, TRUE);     /* doesn't echo by itself */               if(cm < 0)     /* typed */                    ch = -cm;               else if(cm == 0)     /* valid clicks start from 1 */                    ch = '\n';               else if((cm >= 1) && (cm <= 2*NILINES)) { /* Clicked Instr # */                    i = cm + ioff - 1;          /* Next must sprintf(buff) for later atoi() */                    (*psprintf)(buff, "%d\n", i); /* pretend typed into buff */                    (*pprintf)(buff);             /* echo */                    break;    /* the for loop */               }               else /* Clicked command, not instr no. */                    ch = "pcrwkmsxbf" [cm - (2*NILINES+1)];     /* Now treat clicked & typed alike */               *cp = ch;               (*pputchar)(ch);   /* echo */               if((ch < '0') || (ch > '6') || ((cp-buff) > 0)) {          /* Not 1st digit of a typed Instr # */                    if(ch != '\n')                         (*pputchar)('\n');                    break;               }          } /* for(cp++) *//* Got string; key off of 1st char in it */     /* If null, downgrade cursor one notch */          if( !(ch = *buff) || (ch=='\n')) {               if(curcurse==CPARTFULL) {                    curset(CPARTCOPY);                    continue;               }               if((curcurse==CPARTCOPY) || (curcurse==CXOUT)) {                    curset(CARROW);     /* back to normal */                    continue;               }               break;     /* out of loop.  Was CARROW, so return */          }     /* Not null; a command char? */          switch(ch) {          case UPARROW:               ioff -= NILINES;   /* Half screen */               continue;          case DNARROW:               ioff += NILINES;               continue;          case LFTARROW:               ioff -= 2;     /* One line */               continue;          case RITARROW:               ioff += 2;               continue;          case 'b':          case PAGEUP:     /* full screen, no overlap */               ioff -= 2*NILINES;               continue;          case 'f':          case PAGEDN:               ioff += 2*NILINES;               continue;          case 'k': /* Kopy */          case 's': /* Swap */          case 'm': /* Move */               curset(CPARTCOPY);               what = ch;               continue;          case 'x':               curset(CXOUT);               what = 'x';               continue;          case 'c':               wkill();               menuon = FALSE;               if((*pyesno)(" Clear All Instruments?"))                    instinit();               curset(CARROW);               continue;          case 'r':          case 'w':               wkill();               menuon = FALSE;               curset(CARROW);               *buff = '\0';               Diskio(buff, (ch=='w'), 'i', FALSE, FALSE);               continue;          case 'p':               wkill();               menuon = FALSE;               curset(CARROW);               percmenu();               continue;          } /* switch(ch) */     /* Reject non-digits */          if((ch < '0') || (ch > '9')) {               bell();               continue;          }/* At last, an Instr number */          i = atoi(buff) & MINSTRS;     /* What to do depends on cursor & other states */          if(curcurse==CXOUT) {               instvals[i] = 0x80;               *instnams[i] = '\0';               if( !sticky)                    curset(CARROW);               continue;          }          if(curcurse==CPARTCOPY) {               curset(CPARTFULL);               srcnum = i;               continue;          }          if(curcurse==CPARTFULL) {     /* Do some real work! */               curset(sticky ? CPARTCOPY : CARROW);               destnum = i;     /* save dest */               strncpy(swapname, instnams[destnum], INAMEL);               swap = instvals[destnum];     /* copy */               strncpy(instnams[destnum], instnams[srcnum], INAMEL);               instvals[destnum] = instvals[srcnum];               if(what=='s') {                    strncpy(instnams[srcnum], swapname, INAMEL);                    instvals[srcnum] = swap;               }               if(what=='m') {                    instvals[srcnum] = 0x80;                    *instnams[srcnum] = '\0';               }               continue;          }     /* No special cursor; plain old human update */          (*pprintf)("New Patch No. [%4s]: ", prpatch(instvals[i], ps1) );          (*pgets)(buff);          if( *buff)               instvals[i] = atopatch(buff);          (*pprintf)("New Name [%-15s]: ", nam = instnams[i]);          (*pgets)(buff);          buff[INAMEL-1] = '\0';          if( *buff) {               if( *buff == ' ')   /* type BLANK to kill line */                    *buff = '\0';               strncpy(nam, buff, INAMEL-1);          }     } /* loop */     curset(savecurse);     if(menuon)          wkill();} /* instrmen() */void percmenu() {     char buff[81];     int  lin;     wcreate(INST_LCOL, INST_TOPY, 24, 24, TRUE, WSDOUBLE);     for( ; ; ) {          (*pprintf)("\f Slot  Note#   Sound\n");          for(lin = 16; lin >= 0; lin--) {            /* percmids[lin] &= 127;          /* just for test */               if( (lin <=12) && (lin >=4) )  /* inside staff */                    (*pprintf)((lin & 1) ? "||     " : "||-----");               else                    (*pprintf)((lin & 1) ? "       " : "    -- ");               (*pprintf)("%3d %s\n", percmids[lin], percnams[lin]);          }          (*pprintf)("  (Read from file)\n  (Write to file)\n");          (*pprintf)("     (CLEAR ALL)\n%s\n", percsynth);          *buff = '\0';          lin = (*ptextmen)(INST_LCOL, INST_TOPY, 23, 1, 1, 21, TRUE);          if( !lin || (lin== -'\n'))               break;    /* and return */          if((lin==20) || (lin== -'c')) { /* clear */               if((*pyesno)("Clear all Note Numers.  Sure?"))                    for(lin = 16; lin >= 0; lin--)                         percmids[lin] = 0;          }          else if((lin==18) || (lin== -'r'))               Diskio(buff, FALSE, 'p', FALSE, FALSE);          else if((lin==19) || (lin== -'w'))               Diskio(buff, TRUE,  'p', FALSE, FALSE);          else if(lin == 21) {     /* Synth name */               (*pprintf)("Type new Synth name:\n");               (*pgets)(buff);               if(*buff) {                    strncpy(percsynth, buff, 24);                    *(percsynth + 23) = '\0';               }          }          else if(lin > 0) {    /* A drum note */               lin = 17 - lin;     /* upside down */               (*pprintf)("Sound: %s\n", percnams[lin]);               percmids[lin] = clamp(getdefp("MIDI Note # [%d]: ",                 percmids[lin] ), 1, 127);          }     }     wkill();} /* percmen() *//* Convert ASCII digits to patch values; * leading char other than 1-9 means "Korg Octal" format, * where "hundreds" digits of 1 means Roland MT-32 'B' bank. * String is known non-null.  Remember to decrement by 1. * Non-Korg values set 0x80 bit, but keep positive value.*/sexy atopatch(cp)  char *cp;{     sexy n = 0;     char c;     if(( (c = *cp) >= '1') && (c <= '9'))          return( ((atoi(cp) - 1) & 127) | 128);/* Korg style */     cp++;               /* throw away leading 'o' or '0' */     while(c = *cp++)          n = (n << 3) + c - '0';     n -= 9;            /* compensate unit & 10s digits, NOT 100s */     return(n & 127); }/* Clear instrument arrays to value 128 (shows as 1, not o011) and NULL. */instinit() {     int       i;     Reg char  *cp;     for(i = NINSTRS, cp = instnams[0];  --i >= 0;  cp += INAMEL) {          instvals[i] = 0x80;          *cp = '\0';     }}/*** Put up a stock menu *//* DO NOT take out the trailing '\n' w/out changing Fran's end */void menu(code)  sexy    code;{     (*pprintf)(pctn2, MENU, code);  /* no extra bytes, in case of menu args */}/*** Close window ***/wkill() {     (*pprintf)(pctn1, OWEN);  }void dialogue(big)    /* Open a small Double window */  bool    big;{     wcreate(14, 110, 50, big ? 5 : 2, TRUE, WSDOUBLE);    }/************************* Set or reset Grafix Cursor Type, and update global curcurse.* Best done when no cursor is showing.*/void curset(curtype)  sexy    curtype;{     curcurse = curtype;     (*pprintf)(pctn2, SCUR, curtype);}bell() {  /* putc(7, stderr)  Known to work! */     char c;     c = 7;     write(2, &c, 1);}/*** Open a Pat & Vanna overlay window ***/wcreate(leftcol, topy, colswide, rowshigh, dosave, style)  sexy    leftcol, topy, colswide, rowshigh, style;  bool    dosave;{     (*pprintf)(pct7, OWST, leftcol, topy, colswide, rowshigh, dosave, style);     (*pflush)();}alcurset(onoff)  bool    onoff;{     (*pprintf)(pctn2, ACUR, onoff);   }/* eof MENSUBS.C */