/* ~VM640/PLAYSUBS.C   Subrs for Play() */#include <stdio.h>#include <os9.h>#include "wmuse.h"#include "fcnptrs.h"#include "vmem.h"#include "titles.h"typedef unsigned USH;    /* from OSK version; belong in wmuse.h! */typedef long UL;         /* shud be unsigned... */extern FILE *fmidi;extern direct short     scorelvl;extern direct sexy     nparts, nstaves, nevents;extern direct unsigned     contemp,        /* secmin * TEMPCON */     tempo, machtemp, midicnt, smfdelta;extern direct sexy     numer, denom, secmin, keysig, runstat;extern direct bool     mididev, tripper, smf;extern direct Etime     dendur, zonedur;extern ubyte     chans[NPARTS + 1];  /* Part --> MIDI_channel assgnmts *//* None of these arrays is R/O: */extern STAFF staves[NSTAVES];extern PART  parts[NPARTS + 1]; /* Parts are ORG 1, not 0! */extern char     instnams[NINSTRS][INAMEL],     filename[];extern short     instvals[NINSTRS];/* Botnotes are White keys above 16' C==01.  Mid C ==22. *//* This IS Read-Only! */extern CLEF  clefs[];extern short durtable[4];extern ubyte     *evtarray,     *evtartop,     *evtarnxt;void smfdelout();/* Convert dur & durmod codes to raw durations, using small table. */Deltime cod2raw(cdur, cdurmod)  sexy    cdur, cdurmod;      /* cdur==0-7, cdurmod==0-3 */{     return(durtable[cdurmod] >> cdur);}/************* Sleep given no. of 1/60ths of a second.* Used for note/rest playing, this timing is critical!*/void sleep60(ticks)  int     ticks;{     struct registers regs;/* OS9 can't handle over 255 ticks, nor 0, and 1 is no-op */     if(++ticks <= 0)         /* sleep(N) is really only N-1 ticks */          return;     do {          regs.rg_x = (ticks > 254) ? 255 : ticks;          _os9(F_SLEEP, &regs);          ticks -= 254;       /* sleep(255) is only 254 ticks */     } while( ticks > 0);}/************ Key-Sensing for "shifting" keys */ubyte keysense() {     struct registers regs;     regs.rg_a = 0;           /* stdin */     regs.rg_b = 0x27;        /* SS_KeySns */     _os9(I_GETSTT, &regs);     return(regs.rg_a);}/* Parnasian interface; given Part No., returns the other items *//* This is a Stripped-down version of partstaff() for Play() only! */void playstaff(part, lownote, hilo)  sexy  part;       /* INput; rest are OUTputs: */  sexy  *lownote;   /* clef.bnote */  sexy  *hilo;      /* indicators */{     Reg PART  *ptptr;    if((part < 1) || (part > nparts)) {        part = nparts;     }     *hilo = (ptptr = parts + part) -> philo;     *lownote = clefs[(staves + (ptptr->pstaff)) ->clef_no] . bnote;}/************ Fcns originally in play.c itself ****//* All MIDI byte output goes thru here */void midiwr(b)  sexy    b;   /* really ubyte */{     midicnt++;     midiout(b);    /* assy subr does own mode testing */     if(mididev || smf)          (*pputmidi)(b);}/* Customize a one-octave white keyboard for given key */newkey7(new, key)  ubyte   *new;  sexy    key;      /* no. of sharps or flats */{     ubyte     start;     Reg ubyte *rnew;     rnew = new;/* Former global keyc[7] */     strdn(new, "\x00\x02\x04\x05\x07\x09\x0B", 7);    /* Init all whites */     if( !key )          /* Key of C, done */          return;     if(key > 0) {       /* Sharps */          start = 3;     /* 1st one is F */          while ( --key >= 0) {               (*(rnew + start)) ++;   /* sharpen that note */               if((start += 4) > 6)   /* up by 5ths */                    start -= 7;          }     }     else {              /* Negative, Flats */          start = 6;     /* 1st one is B */          while( ++key <= 0) {               (*(rnew + start)) --;   /* flatten that note */               if((start += 3) > 6)   /* up by 4ths */                    start -= 7;          }     }} /* newkey7() *//* Copy single white key-sig octave to full 7 octaves. *  Note that MIDI "ORG" assigns 0, not 1, to 64' C. */spread50(single, seven)  register ubyte    *single;  ubyte   *seven;{     sexy      chroff;     ubyte     *whoff;     whoff = seven + 49;     seven += 1;    /* I forget why */     for(chroff = 24 + 24*256;       seven < whoff;  seven += 7, chroff += (12+12*256) )     {          *((short *)seven)       = *((short *)single)       + chroff;          *((short *)(seven + 2)) = *((short *)(single + 2)) + chroff;          *((short *)(seven + 4)) = *((short *)(single + 4)) + chroff;          *          (seven + 6) = *           (single + 6)  + chroff;     }}/* Convert Human to Machine tempos, in # of DENOM-notes per minute.* Tempos from 30 to 240, tripled to 720, denoms 2-16, secmins 20-180,* machtemps 3-1920 (some dynamic range, eh?!?)*/void tempcon(){     unsigned  human;     human = (tripper && (scorelvl >= 7)) ? (tempo + tempo + tempo) : tempo;     machtemp = ((unsigned)contemp * (unsigned)denom) / human;}/* As above, but with human tempo given as arg, and returns value*  without touching machtemp.  More general, used by Cresc, Accel. */unsigned hum2mach(human)  unsigned  human;{     if(tripper)    /* know scorelvl >= 7 */          human += (human + human);     return( ((unsigned)contemp * (unsigned)denom) / human);}/* Can't hum2mach() also serve for this fcn?  Over/Under-flow? *//* Inverse conversion of above -- machtemp to human tempo,*  to convert Accel/Ritard fo .MID file stream. */USH temprev(mach)  USH     mach;{     if(tripper && (scorelvl >= 7))          mach += (mach + mach);     return( ((USH)contemp * (USH)denom) / mach);}/***** MIDI_Events stuff **//***** SMF.MID file stuff *****//* Output a System Common or System Realtime MIDI Byte*  preceded by its SMF "wrapper" bytes (what a waste!) */putsys(mb)  ubyte   mb;{     if(smf) {          smfdelout();          midiwr(0xF7);          midiwr(0x01);     }     midiwr(mb);}     /* Output a value as one or more var-length bytes *//* For now only 16 bits, unsigned */void varlenout(dt)  USH     dt;{     if(dt < 128) {          midiwr((ubyte) dt);          return;     }     if( (dt & 0xC000) != 0)          midiwr( (ubyte) ( (dt >> 14) | 0x80) );     midiwr( (ubyte) (((dt >> 7) | 0x80) & 0xFF) );     midiwr( (ubyte) (dt & 0x7F) );     return;}/* return Play read Pointer to one event, given offset & cuenta *//* Swaps in but not out */ubyte *ievtplay(offset, cuenta)  int     offset;  int     cuenta;{     Reg ubyte *ubp;     cuenta &= 255;     evtarray = (*pswapevts)(TRUE);     ubp = evtarray + offset;     if((ubp + cuenta) > evtarnxt)  /* no got that many */          return(NULL);     return(ubp);} /* ievtplay() *//** Aux fcn to play Outline events (partwise or system),*   with channel substitution and SMF mickey-mouse wrappers. */void playout(evp, chan)  EVENT     *evp;  ubyte     chan;     /* ==0 (Ch. 1) for System event */{     bool      sysex;     int       cnt, lookcnt;     ubyte     bytemp, *look;     Reg ubyte *ubp;/* SMF-wise, anything can happen -- SysEx's mixed with Sys-non-ex's*    or even Channel stuff!*  Must parse the string, one event at a time.*/     cnt = (int)(evp->show.IEVTBYT2) & 255;     ubp = ievtplay( *((short *)(&evp->show.IEVTBYT0)), cnt);     if( !ubp)          return;/* Inside loop, cnt== #bytes left afer bytemp, incl. 0 */     while( --cnt >= 0) {          bytemp = *ubp++;/* If Status byte, put out an SMF Delta and run further tests... */          if( (char)bytemp < 0) {               if(smf)     smfdelout();/* If status is Partwise, and no literal Channel, then subst Part's chan */               if( (bytemp & 0xF0) != 0xF0) { /* Partwise, not System */                    if( !(bytemp & 0x0F) )    /* default chan 0, can subst */                         bytemp = (bytemp & 0xF0) | chan;               }     /* System -- no more work unless smf mode.      * If a Sysex F0 ... F7, use F0 "wrapper" and assume F7 is in event;      * else use F7 wrapper and send actual Fx byte. */               else if(smf) {                    look = ubp;          /* save loca, already at next byte */                    if( !(sysex = ((bytemp & 255)==0xF0))) { /* if not Sysex */                         bytemp = 0xF7;  /* use generic wrapper */                         ubp--;          /* and do send actual byte later */                    }                    midiwr(bytemp);     /* wrapper */          /* Look ahead to find length; assume user typed valid stuff;           * consider an F7 as end of this event, not the next new one. */                    for(lookcnt = cnt ; lookcnt; lookcnt--) {                         bytemp = *look++;                         if( ((char)bytemp < 0) && ((bytemp & 255) != 0xF7) )                              break;                    }                    lookcnt = cnt - lookcnt; /* length - 1 */                    cnt -= lookcnt; /* don't count one byte you paid already */                    if( !sysex)                         lookcnt++; /* since we'll repeat the non-F0 */                    varlenout(lookcnt);          /* Output substring, leaving ubp at right spot */                    while( --lookcnt >= 0)                         midiwr(*ubp++);     /* do trust ++ in putc() */                    continue;               } /* System && smf */          } /* if status byte */          midiwr(bytemp);     /* covers non-Sys status and data bytes */     } /* while */} /* playout() *//****** playevt() == fcn to Play "MIDI Events", from file events.c ***/void playevt(evp)  Reg EVENT   *evp;{     int    cnt;     ubyte  bytemp, chan;     Reg ubyte *ubp;     bytemp = evp->show.IEVTBYT0;     if(evp->show.INCTYPE == IPEVT) {          chan = chans[evp->show.PARTNO] & 15;          if((char)bytemp < 0)     {     /* Inline Partwise, 1st byte */               if( !(bytemp & 0x0F))     /* if no literal channel... */                    bytemp = (bytemp & 0xF0) | chan;     /* insert part's */               if(smf)   smfdelout();               midiwr(bytemp);/* Any Partwise event always has ONE or TWO more bytes, never more! */               midiwr( evp->show.IEVTBYT1 & 127);               if( (char)(evp->show.IEVTBYT1) >= 0)      /* not last */                    midiwr( evp->show.IEVTBYT2 & 127);          } /* Inline IPevt */          else {          /* Partwise Outline */               playout(evp, chan);               (*pswapevts)(FALSE);          }      } /* IPevt *//* Unforch, SMF requires all System Non-Excl Fx Events to be*  prefixed by an F7 "wrapper" and Length.*  ISEVT is known non-SysEx and also gives its length.*/     else if(evp->show.INCTYPE == ISEVT) {          if( (char)bytemp < 0) {          /* Inline System *//* Extra-byte count is in upper nybble, << 1 */               if(smf) {                    smfdelout();                    midiwr(0xF7);  /* wrapper */                    midiwr(((bytemp >>5) & 3) + 1);    /* length */               }               midiwr(bytemp | 0xF0);          /* restore hi nybble *//* Any extra bytes? */               if(bytemp &= 0x60) {          /* yes, '=' */                    midiwr(evp->show.IEVTBYT1);                    if(bytemp & 0x40) {          /* the 2 bit */                         midiwr(evp->show.IEVTBYT2);                         if(bytemp & 0x20)     /* the 1 bit */                              midiwr(evp->show.IEVTBYT3);                    }               }          } /* Inline System */          else {     /* Outline System */               playout(evp, 0);               (*pswapevts)(FALSE);          }     } /* ISevt */     else {          /* play Table event -- someday! *//* Table Event: */          ;     } /* end play table event */} /* playevt() *//*********** Std MIDI File Functions ***********//* Dynamic outputters put out current smfDelta value *//* MUST DO timesig()-type stuff BEFORE this fcn, to update zonedur, etc. *//* 00 FF 58 04 nn dd cc bb */void smftimes() {  ubyte temp[4],        ubt;     smfdelout();     (*psmfwrit)("\xff\x58\x04", 3);     temp[0] = numer;     ubt = 2;     /* default n/4 */     if(denom==2)     ubt = 1;     if(denom==8)     ubt = 3;     if(denom==16)    ubt = 4;     temp[1] = ubt;     temp[2] = zonedur >> 1;     /* Our 48 -vs- std 24 tick/quarter */     temp[3] = 8;     (*psmfwrit)(temp, 4);     runstat = 0;} /* smftimes() *//* Convert & Output Human tempos (ZoneDur's / minute) to SMF-.MID tempos*  of microseconds (!) per zonedur (or quarter?).  (LucasFilm likes it tight!)*  Tempo==60 --> 1,000,000 us/beat, 120-->500,000, etc.*  Note that MM/1's 200 ticks/s and Coco3's 60 ticks/s*    are irrelevant to a .MID file.*  Maybe so is "zonedur" -- set #ifdef to suit.*  Experiments show Paul Seniura wants us/quarter, not us/zonedur.*  Result must fit in 3 bytes == 24 bits (not vari-length).*/void smftempo(tempo)  USH     tempo;     /* Human's M.M. tempo */{     UL     usperqrt;          smfdelout();     (*psmfwrit)("\xff\x51\x03", 3);/* 1Meg * (60/tempo) * (secmin/60) == 1Meg * (secmin/tempo) */#ifdef PAULBLEW/* This simple version is always per Zone-Beat, period --*  assumes PaulSen's converter/player is hosed. */     usperqrt =  (1000000L * (UL)secmin) / (UL)tempo;#else/* This version scales it per Quarter Note, using zonedur,*  and assume Paul's player works the same as "real world" stuff.*  Zonedurs go from 16th (12T) to 2 (96T), or 8:1*  Want usperbeat *= 48/zonedur.  That quotient is from 4 to 0.5:*/     usperqrt = ((48000000L / (UL)zonedur) * (UL)secmin) / (UL)tempo;#endif     (*psmfwrit)( (ubyte *) &usperqrt + 1, 3);     runstat = 0;}/* Output Key Sig in SMF */void smfkeys(){     smfdelout();          (*psmfwrit)("\xff\x59\x02", 3);     midiwr((ubyte) keysig);     /* same convention as UME's! */     midiwr(0);                  /* always Major, who knows? */     runstat = 0;}void smfstring(str, code)  char    *str;  int     code;     /* 1=random, 2=copyrt, 3=sequence name, 4=instrs */{     UL     lt;     int    len;     len = strlen(str);     lt = (code << 8) + 0x00FF0000L + len;     (*psmfwrit)(&lt, 4);     (*psmfwrit)(str, len);}/* Output score file's name and all non-empty Title_Screen lines. */void smftitles(){     char  buff[80];     UL    lt;      int   tit, len;     Reg char  *cp;     /* Copyright notice would go first, someday *//* File name */     if( !(len = strlen(filename)))     /* already includes ".ume" */          return;     strcpy(buff, filename);     strcat(buff, " via UltiMusE-III under CoCo3 OS-9 L2. ");/*   strcat(buff, " via UltiMusE-K under OS-9 on the MM/1."); */     smfstring(buff, 3);          /* 3 = sequence/track name *//* Non-empty title lines */     (*pswapevts)(TRUE);     for(tit = 0, cp = Titles; tit < TOTLINES; tit++, cp+=TLENP1) {          len = strlen(cp);          if( !len || (len > TLEN))               continue;          smfstring(cp, 1);          /* 01 = general text event */     }     (*pswapevts)(FALSE);     /* was () BUG in 8.11.0 fixed 97/4/27 */}/* Output part:chan and instr:num:name maps */void smfinfo() {     char     buff[32];     UL       lt;     int      len, it, i;     Reg char *iname;          for(i = 1; i <= nparts; i++) {          (*psprintf)(buff, "Part %d on Chan %d.", i, chans[i] + 1);          smfstring(buff, 1);          /* 1=random */     }     for(i = 0; i < NINSTRS; i++) {          it = instvals[i] & 0x7F;          iname = instnams[i];          if( !it && !strlen(iname) )     /* skip if BOTH void */               continue;          (*psprintf)(buff, "Instr %d: %s", it, iname);          smfstring(buff, 4);          /* 4 = instrs */               }}/* Output the headers and other handy info */void smfhead(tempo)  USH     tempo;{     (*psmfwrit)("MThd\x00\x00\x00\x06\x00\x00\x00\x01\x00\x30", 14);     (*psmfwrit)("MTrk\x00\x00\x00\x00", 8);     smftitles();     smfinfo();     /* Parts, chans, instrs */     smftimes();     smftempo(tempo);/*   smfkeys(); /* no, wait till you really see one */}/* Output the final EOF bytes, and adjust Mtrk length.*  WON'T WORK ON PIPES! */void smfinish() {     UL     lt = 0x00FF2F00L;     /* includes delta */     (*psmfwrit)(&lt, 4);/* Get length of the file */     (*pmflush)();       /* so we can use "raw" lseek(), write() */     lt = lseek(fmidi->_fd, 0L, 1) - 22L;  /* cur pos at end == length *//* Seek to 18 bytes from beginning */     lseek(fmidi->_fd, 18L, 0);/* OverWrite longword there with filesize - 18. */     write(fmidi->_fd, &lt, 4);}/* Output current smfdelta (usually 0), then clear it */void smfdelout() {     varlenout(smfdelta);     smfdelta = 0;}/* eof ~Vm640/playsubs.c */