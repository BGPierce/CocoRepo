/* ~Vm640/VIRT3.C  The 3 major fast routines needed by all fraggers,*     who need link in only this tiny file instead of bvirt.r*/#include "wmuse.h"extern bool     (*ppswap)();/* Virtual Memory items */extern direct EVENT     *curevp,       /* current event pointer */     *database,     /* Bottom of current page (1st byte's addr) */     *curptop;      /* highest event ptr possible on current page */extern direct Index     nevents,  /* yeah, this is different... */     curind;   /* current index */extern direct sexy     group,    /* buffer group, usually our PID */     curpage,  /* current page no. */     nmpages;  /* how many pages are in memory *//* end of VMem items *//* Given a good-old-style index, *  swap in the page and compute the pointer.*  Slowest thing you can do, if page swaps. */EVENT *i2p(ind)  register int ind;{     int  page;     curind = ind;/* Repeated subtraction to get quotient and remainder */     for(page = 1; (ind -= PNEVENTS) >= 0; page++)          ;     ind += PNEVENTS;    /* restore after last subtract *//* Swap data pages if needed */     if(page != curpage) {          if( !(*ppswap)(page))               return(NULL);     }     return(curevp = database + ind);}/* Increment current pointer by one Event.*  Let curind go off the end of nevents, so caller can check it,*    but don't call pswap(), and return old curevp. */EVENT *plusplus(){     if( ++curind < nevents) {          if(++curevp > curptop) {               (*ppswap)(curpage + 1);                curevp = database;          }     }     return(curevp);}/* Decrement by one.  Let curind go <0 but hold page=1 and curevp=0. */EVENT *decdec(){     if( --curind >= 0) {          if(--curevp < database) {               (*ppswap)(curpage - 1);               curevp = curptop;          }     }     return(curevp);}/* eof ~Vm640/virt3.c */