/* file ~VMem/BFM.C was BIO.C   -13-    Disk I/O.    All DiskIO code has been fragged out of here;      only Menus and some stuff remain.90/3/17   Extensive rebuild for side info files (i, p, m, l)90/01/26  User can omit .ume and .ins in file names.** Version:* Level -- radical, like 640 screen.* Score -- older scores are invalid, tho probably compatible.* Revision -- new features, cleaned up code, etc.*/#include <stdio.h>#include <modes.h>#include "wmuse.h"#include "size.h"#include "wmenu.h"#include "mencodes.h"#include "windows.h"#include "cursors.h"#include "version.h"#include "vmem.h"#include "soowee.h"/* None of these arrays is R/O: */extern STAFF staves[NSTAVES];extern PART  parts[NPARTS + 1]; /* Parts are ORG 1, not 0! *//* This IS Read-Only! */extern CLEF  clefs[];extern sexy    instvals[NINSTRS];extern char    instnams[NINSTRS][10];extern char    filename[SFILENAME],               percsynth[24];extern ubyte   chans[NPARTS + 1],               levels[NLEVELS], genvols[NLEVELS],               percmids[17];extern bool    partens[NPARTS + 1], chanens[16];extern direct short    nparts, nstaves,    xgoal, nbars, nzones;extern direct Index     lftind, ritind, gind;extern direct sexy    curcurse, numer, denom, keysig, secmin;extern direct Time    length;extern direct bool    scrclock, readonly, rfr_scr, rfr_tit, rfr_bar;Time      figurst();bool      diskio();      /* pre-dec */char      *instrg(), *malloc();/* Re-inits formerly done in diskio() after reading new file */void reinit() {     Reg int   i;     length = figurst(nevents - 1);     barenum(FALSE);     /* Count into nbars, don't renumber */     if( !numer || !denom)          numer = denom = 4;     timesig();     dfalprts(1, nparts);     dfalstvs(0, nstaves - 1);     for(i = 1; i <= NPARTS; i++)          partens[i] = (i <= nparts);     for(i = 0; i < 16; )     /* Later enable only chans actually used */          chanens[i++] = TRUE;} /* reinit() *//* Remove blanks in-place from file or path name */void trim(s)  char *s;{     char      c;     Reg char  *fp;     fp = s;     do {          c = *fp++;          if(c != ' ')               *s++ = c;     } while(c);}/* Sub-Menu for Instrs, Percs, etc. */bool fsubmen(buff)  char    *buff;{     sexy oldcurse, which;     char who, ch;     which = 1;     /* select Instrs */     who = 'i';     while(TRUE) {          oldcurse = curcurse;          curset(CBUTTON);          menu(MEN_FSUB);          printf("%d", which);/* Bug in Mware c.prep forbids quoted strings >8 chars,*    so what follows is FILE_STR from mencodes.h */          ch = menukey("ipml rwdk\n",             FSUB_LCOL, FSUB_CWID, FSUB_TOPY, FSUB_BOTY);          wkill();          curset(oldcurse);          *buff = '\0';  /* force filename promptings */          switch(ch)          {          case '\n':               return(FALSE);     /* Choosers */          case 'i':               which = 1;     who = 'i';               break;          case 'p':               which = 2;     who = 'p';               break;          case 'm':               which = 3;     who = 'm';               break;          case 'l':          case 'v':               which = 4;     who = 'l';               break;     /* Do-ers */          case 'r':               return(Diskio(buff, FALSE, who, FALSE, FALSE));          case 'w':               return(Diskio(buff, TRUE,  who, FALSE, FALSE));          case 'd':               return(Diskio(buff, FALSE, who, TRUE, FALSE));   /* just DIR */          case 'k':               return(Diskio(buff, TRUE, who, FALSE, TRUE));          default:               bell();          }     } /* main while */     return(FALSE);} /* fsubmen() *//* Complete file I/O menu, incl. Instruments. * Uses nevents <= 1 to do Startup steda Files menu. * 'W/A' does NOT change Filename[] unless user sez so. * Note calls that change Filename use it as arg, else use buff[] * "Break" recycles loop; must "return" to get out.*/void iomen(){     char buff[SFILENAME + 8];     sexy oldcurse;     char ch;     while(TRUE) {          oldcurse = curcurse;          curset(CBUTTON);          if(nevents > 1) {               menu(MEN_FILE);               printf("%d", readonly & 1);   /* for [X] box *//* Bug in Mware c.prep forbids quoted strings >8 chars,*    so what follows is FILE_STR from mencodes.h */               ch = menukey("nraswfoidphtkq\n",                  FILE_LCOL, FILE_CWID, FILE_TOPY, FILE_BOTY);          }          else {                   menu(MEN_STARTUP);               printf("%d", readonly & 1);   /* for [X] box */               ch = menukey(" nroidph\nq\n",      /* was STRT_STR */                  STRT_LCOL, STRT_CWID, STRT_TOPY, STRT_BOTY);          }          wkill();          curset(oldcurse);          *buff = '\0';  /* force filename promptings */          switch(ch)          {          case '\n':               return;          case 'q':               breaker(2);    /* fake a BREAK */               break;         /* get here if user cancels Quit */          case 'o': /* read-Only mode toggle */               readonly = !readonly;               break;          case 't': /* Title/Info submenu */               titlemen();               wkill();       /* title window? */               break;          case 'n':               if( (nevents < 2)                 || yesno(" Will clear current score.  Sure? ")) {                    newscore(TRUE);                    rfr_scr = TRUE;                    gind = xgoal = 0;                    return;               }               break;          case 'f':               dialogue(FALSE);               printf("\nOld: %s\n", filename);               printf("New: ");               gets(buff);               wkill();               trim(buff);               if(*buff)                    strcpy(filename, buff);               break;          case 's':               /* if(nevents < 2)  break; */               if( *filename) {                    if(readonly && !yesno(                      "Read_Only Mode is on.\n  Write anyway?"                      ))                         return;                    monologue();                    printf("\nOK, Writing:\n  %s", filename);               }               flush();               if(Diskio(filename, TRUE, 'u', TRUE, FALSE))                    return;               wkill();               break;          case 'd': /* DIR all NON-.UME files */               Diskio(buff, FALSE, 'u', TRUE, TRUE);               break;    /* recycle; was return */          case 'r': /* List & Load .ume files only */               if(Diskio(buff, FALSE, 'u', FALSE, FALSE)) {                    rfr_scr = TRUE;                    strcpy(filename, buff);                    gind = xgoal = 0;                    reinit();                    audit();                    return;               }               break;          case 'a': /* Append */               if(Diskio(buff, FALSE, 'a', FALSE, FALSE)) {                    rfr_scr = TRUE;                    length = figurst(nevents - 1);                    barenum(TRUE);                    audit();                    return;               }               break;          case 'k': /* Kill / delete */               Diskio(buff, TRUE, 'u', FALSE, TRUE);               break;          case 'w':               /* if(nevents < 2) break; */               if( Diskio(buff, TRUE, 'u', FALSE, FALSE)                 && yesno("Keep new file name? ")) {                    strcpy(filename, buff);                    return;               }               break;          case 'i':      /* Instrs, etc.  Sub-Menu */               if(fsubmen(buff))                    return;               break;          case 'c':          case 'h':          case 'p':               dialogue(TRUE);     /* was ch=='p' */               if(ch=='p') {                    printf("\nNow: ");                    fflush(stdout);                    system("ex pwd");               }               for( ; ; ) {                    printf("\n To: ");                    gets(buff);                    trim(buff);               /* Abort ENTER or succeed */                    if(!*buff || !chdir(buff) )                         break;                    bell();                    printf("***Can't CHD to that dir.\n");               }               wkill();               break;          default:                    bell();   /* just go round again */          } /* switch(ch) */     } /* while */} /* iomen() *//* eof ~VMem/bfm.C */