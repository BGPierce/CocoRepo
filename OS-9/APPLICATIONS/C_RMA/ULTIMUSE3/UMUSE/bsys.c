/* ~VM640/BSYS.C  -10B--    OS-9 system calls and related functions*  No Col-X conversion needed.Contents:     mouce(&x, &y)  Bjork's Black Box     setmouse()     keysense()     inkey();     testkey();     seeregs(r) struct registers *r;*/#include <os9.h>#include <sgstat.h>#include <stdio.h>#include "wmuse.h"#define SS_GIP      0x94#define SS_MOUSE    0x89#define MOUSESRATE  2    /* 2 == 30 checks/sec */#define MOUSETIMO   15   /* 1/2 sec */#define SUBRTYPE 0x21      /* 6809 Subr */#define MAINTYPE 0x11      /* Main Prog */#define DATATYPE 0x40      /* Data Module */#define SYSTYPE  0xC1      /* 6809 System, eg, GrfDrv */#define HGT 192#define HM1 191typedef struct {     char valid,    /* bool-test before all else */          actv,          totm,     /* Timeout init value */          dum1,dum2,          ttto;     /* Remaining till timeout */     short tsst;    /* Time since counter start */     byte cbsa,     /* the FIRE button */          cbsb,     /* The other Deluxe fire button */          ccta,cctb,          ttsa,     /* Time in this current state */          ttsb,          tlsa,     /* Time in last (previous) state */          tlsb;      short dumres,           bdx,bdy; /* saved when button first pressed */     byte  stat,res;      short acx,acy, /* Actual current X and Y (positive DOWNwards) */           wrx,wry,srx,sry;} MousePak;/* Following pair must be initialized to '\0' and 0 */extern char    curmod;  /* current mod's last letter */extern int     subrhead;  /* (was subrmod) header addr of above, to unlink */extern direct int     moldx, moldy;       /* mouse savers for Hysteresis, DON'T USE elsewise! */extern direct bool     pldebug,     hires, left, automon;   /* mouse dirt */extern direct sexy     uptime, dntime;     /* Mouse button times *//******** Linkers for "fragged" subrs *//* Link to a "subr" (really program, for cheating) module,*  after loading it if necessary.  The loading gives it an extra*  reference count, so it stays in RAM after unlinking.*/int (*linkup())(who)    /* Fcn that returns a ptr to an int fcn */  char    *who;     /* name of fcn module to link */{     struct registers regs;     regs.rg_a = MAINTYPE;     regs.rg_x = who;          if( _os9(F_LINK, &regs) != 0)      /* 1st try Linking */     {     /* Link failed.  Try to LOAD the module, but without linking to it.      *  This lets a 2nd LINK lock it into memory.     *  For throw-away load, use plain F_LOAD and skip the F_LINK.     */          regs.rg_x = who;    /* must reset */          if( _os9(F_NMLOAD, &regs) ||            ((regs.rg_x = who),  _os9(F_LINK, &regs)) ) {               dialogue(TRUE);               printf("\n\007Er %d ldg %s\n", regs.rg_b & 255, who);               hitenter();               wkill();               return(NULL);          }     }     subrhead = regs.rg_u;    /* Update IFF successful */     return(regs.rg_y);/*   attr = regs.rg_b & 255;*    printf("Attr=%x, Header at %4x, Entry at %4x\n",*      attr, subrhead, entry);*/}/* Unlink current subr module, if present */void delink() {     struct registers regs;     if( !subrhead)          return;     regs.rg_u = subrhead;      /* use the Header addr */     _os9(F_UNLINK, &regs);     subrhead = 0;}/* Unlink any module, by name */void unload(who)  char    *who;{     struct registers regs;     regs.rg_a = MAINTYPE;     regs.rg_x = who;     _os9(F_UNLOAD, &regs);   /* 0x1D */}/* SOOWEE()  Caller of the [memory] Hogs (not Frank). 89/1/13 -- 95/7/6*  Can recursively call multiple levels of Link-fragged fcns*    and unwind the returns, IFF all fcns always map*    into the same 8K block.*  Each invocation unlinks the level above and relinks when done.*/int soowee(mod, what, a1, a2, a3, a4, a5)  char    mod,           /* last letter of subr module name to call */          what;          /* fcn-select switch char for within module */  int     a1, a2, a3, a4, a5; /* args -- actual types unknown, who cares? */{     char name[6];     char oldmod;   /* previous mod last letter */     int  oldhead;   /* and its header addr */     int  retval;     register int   (*fptr)();/* Save current subr's tags */     oldmod = curmod;     oldhead = subrhead;     delink();      /* skips if subrhead == NULL *//* Link new subr, test for success.  Note linkup() updates subrhead. */     strcpy(name, "Um3x");     *(name + 3) = mod;     fptr = linkup(name);     /* updates subrhead iff succeeds */     if( !fptr)          return(0);/* Put new subr's name in lights for next soowee() level */     curmod = mod;     automouse(FALSE);/* Make the jump into hyperspace */     retval = (*fptr)(what, a1, a2, a3, a4, a5);/* Unlink our boy */     delink();      /* uses global subrhead, zeros it if successful *//* Restore old current subr */     if(oldhead) {    /* skip if NULL (at top) */          *(name + 3) = oldmod;          if( !linkup(name)) {               text();               printf("Cn't rlk %s!\n", name);               exit(38);          }     }     curmod = oldmod;     return(retval);} /* soowee() *//************ Key-Sensing for "shifting" keys */ubyte keysense() {     struct registers regs;     regs.rg_a = 0;           /* stdin *//* Sense the keys */     regs.rg_b = 0x27;        /* SS_KeySns */     _os9(I_GETSTT, &regs);     return(regs.rg_a);}/***** Char and Line Input *****/char readone(buff)  /* returns the char. */  char *buff;       /* need be only one byte long */{     alcurset(TRUE);     flush();       /* favor to StdIO and the caller */     read(0, buff, 1);/* Self-Echo the char */     if( (*buff &= 0x7F) != 5)     /* No ALTs or BREAKs */          putchar(*buff);     flush();     return(*buff);}/* Like readone(), but lets user substitute mouse click for ENTER.*  Lets him push same old cursor around.*  Unlike keymouse(), this echoes chars.*/char charmaus(buff)  char *buff;{     int  x, y;     char ch;     alcurset(TRUE);     flush();     ch = keymouse(&x, &y);   /* starts with a free waitmouse() */     if( !ch)  /* button pressed */          ch = '\n';     ch &= 0x7F;     if(ch != 5)    /* not BREAK */          putchar(ch);      /* echo */     flush();     return(*buff = ch);}int onehex() {    /* eats one char, tries to hex->int it */     char ch;     return(hexc2i(charmaus(&ch)) );}/* INKEY$ fcn to safely test for and read a char. * Returns '\0' if none there. */char inkey() {    char c;    fflush(stdout);        /* needed before raw I/O */    if(getstat(1, 0))        return('\0');      /* no char ready */    return(readone(&c));   /* this echoes and flushes */}/* Just test for char present, don't read it.*  Used by keymouse() */bool testkey() {     fflush(stdout);     return( !getstat(1,0));}/* Special version of gets(char *buff), overlays system lib's.*  Echoes each char as typed.  Like original, ends in NULL, not NewLine.*  As extra bonus, limits to NGETS chars, so can't blow buffers!*  And gives caller a FREE flush() job!*  89/11/21 Mouse click == ENTER.*  89/5/2 fixed to not echo BSes past front of buffer,*    and dings bells instead of auto-returning after buffer exceeded.*/#define NGETS  BUFFSIZEchar *gets(buff)  char *buff;{     int  count, x, y;     char c;     register char  *bp;     bp = buff;     alcurset(TRUE);     flush();       /* favor to StdIO and the caller */     for(count = 0; ; ) {     /*   read(0, &c, 1); */          if( !(c = keymouse(&x, &y)))  /* so CLICK == ENTER */               c = '\n';          c &= 0x7F;          /* No ALT chars to Fran! */          if(c == 8) {        /* Backspace */               if(count)               {    bp--;                    count--;                    putchar(8);               }          }          else if(c == ('X' & 31)) { /* ^X line killer */               for( ; count--; )   /* so Vanna won't kill prompt too */                    putchar(8);               bp = buff;     /* start over */               count = 0;          }          else if(c == '\n') {               putchar('\n');               flush();       /* Thought unnecessary after a \n */               *bp = '\0';               break;         /* ONLY WAY OUT of loop */          }          else if(count < NGETS) {    /* '<' saves room for the \0 */               *bp++ = c;               count++;               putchar(c);          }          else {               bell();          }          flush();       /* serves most branches */     }     return(buff);}/* Prompt user and initialize Level II Mouse System */setmouse(){     struct registers regs;     regs.rg_a = 0;      /* stdin */     regs.rg_b = SS_GIP;     regs.rg_y = 0xFFFF; /* no change keyboard params */     if(hires < 0)          hires = yesno("Hi-Res Adapter? ");     if(left < 0)          left = yesno("Left Joy Port? ");     regs.rg_x = (hires ? 0x100 : 0) + 1 + left;     _os9(I_SETSTT, &regs);   /* that's 0x8E *//* Click-timing extras added 88/9/27 */  /* automouse(TRUE); */}/* Turn automatic mouse sampling on/off */void automouse(onoff)  bool    onoff;{     struct registers    regs;     if( !(onoff ^ automon))  /* already in desired mode */          return;     regs.rg_a = 0;      /* stdin */     regs.rg_b = SS_MOUSE;/* 2nd choice was 0, now MOUSETIMO 90/5/6 */     regs.rg_x = onoff ? ((MOUSESRATE <<8) | MOUSETIMO) : MOUSETIMO;     _os9(I_SETSTT, &regs);     automon = onoff;}/* 91/8/29  Mod'ed to sleep for large fraction of second*    whenever our window is flipped out.  Inspired by KG-2BN game! *//* THE Mouse Reader -- position, button, timing.* Includes own single-pixel hysteresis.* 640 x 192 Pixels, Y+ upwards, say again, UPWARDS. * Independent of HiRes or not, or "keyboard mouse";*   all return same Hi-Res scaled values.* Updates timings of button having been up and down;*   these are Tandy's values minus one unsigned,*   so timeout value of 0 looks like 255 or "infinity."*/#define XDIFF 1     /* Hysteresis backlash thresholds */#define YDIFF 2     /* was 1; 2 may help on noise */bool mouce(outx, outy)  short *outx, *outy;    /* caller is permitted to clobber these */{     struct registers regs;     MousePak gruyere;   /* expensive food for the mousie */     short diff, vacx, vacy;     bool  fire;     for(;;) {          regs.rg_a = 0;          regs.rg_b = SS_MOUSE;          regs.rg_x = &gruyere;          regs.rg_y = 0x101;       /* not needed, but... */          _os9(I_GETSTT, &regs);   /* should be 0x89 */          if(gruyere.valid)        /* yes, our window, */               break;              /* so process it. */          /*   return(0);          /* someone else's window */          tsleep(30);              /* so cool it 1/2 sec *//* Experimental disappearing-windows fix.  Works great,*    but no longer needed.  95/9/18 *//*        write(2, "\x1B\x21", 2); */     }     diff = (vacx = gruyere.acx) - moldx;     if(diff > XDIFF)          moldx = vacx - XDIFF;     if(diff < -XDIFF)          moldx = vacx + XDIFF;     *outx = moldx;     diff = (vacy = gruyere.acy) - moldy;     if(diff > YDIFF)          moldy = vacy - YDIFF;     if(diff < -YDIFF)          moldy = vacy + YDIFF;     *outy = 191 - moldy;           /* Invert the inversion ... *//* Button state and timings -- good stuff from Level 2 */     fire = gruyere.cbsa;     if(fire) {          dntime = gruyere.ttsa;          uptime = gruyere.tlsa;     } else {          dntime = gruyere.tlsa;          uptime = gruyere.ttsa;     }     dntime = (dntime - 1) & 255;     uptime = (uptime - 1) & 255;     return(fire);}/* Real L2 GrfDrv drawing fcns, for real L2 Windows of '95 */setfore(color)  sexy    color;{     char stuff[3];     *stuff = 0x1B;     *(stuff+1) = 0x32;     *(stuff+2) = color;     write(2, stuff, 3);}bool line(x1,y1, x2,y2)  sexy    x1,y1,x2,y2;{     short     stuff[6];     sexy      ty;               stuff[0] = 0x1B40;       /* 2-byte SetDPtr ESCape code */     stuff[1] = x1;     stuff[3] = 0x1B46;       /* LineM */     stuff[4] = x2;/* Invert the Y's, and check */     ty = HM1 - y1;     if(ty < 0)     ty = 0;     else if(ty > HM1)     ty = HM1;     stuff[2] = ty;          ty = HM1 - y2;     if(ty < 0)     ty = 0;     else if(ty > HM1)     ty = HM1;     stuff[5] = ty;     return( write(2, stuff, 12) == 12); /* StdErr, not Fran! */}#ifdef seethemseeregs(r) struct registers *r;{     printf("CC=%02x, A|B=%02x|%02x, DP=%02x\n", r->rg_cc,          r->rg_a, r->rg_b, r->rg_dp);     printf("X=%04x, Y=%04x, U=%04x\n",r->rg_x,       r->rg_y,r->rg_u);}#endif/* eof ~Vm640/bsys.c */