/* file ~VM640/SHOW.C  -6-    nee SHOWALL.C   Beaming 4/97   Bar #s below, Nth ending #s on top 88/6/7   Converted to Column-X 88/11/18*/#define LASTCLUZ ACCENT  /* highest defined Inclusion type *//* #include <stdio.h> */#include "wmuse.h"#include "vgraf.h"#include "wwidths.h"#include "wmenu.h"#include "wcodes.h"#include "vmem.h"#include "macros.h"#include "fcnptrs.h"#define FRAG   1#include "soowee.h"#define LPAD   1      /* left "margin" for notes figuring */#define RPAD   2      /* was 3 */#define LMARGIN     (SCORLEFT+CLEFWID+LPAD)#define RMARGIN     (SCORIGHT-RPAD)#define MAXBEAM     16extern bool ispwexpr();Deltime barmin();sexy findkey();Index sametime();extern STAFF    staves[];extern ubyte    bcluzis[];extern ubyte    grafxes[];extern ubyte    grafyes[];extern direct short    nparts,    nstaves,    xyoff,           /* index - xyoff = xyindex */    xgoal,           /* where gind's object should be shown */    gbar;            /* bar # containing gind *//*  lftbar, ritbar,  /* edgemost Bars shown at all *//*  lftlin, ritlin,  /* edgemost BarLines shown */extern direct Index    gind,            /* index of goal event */    gbarind,         /* index of gbar's barline */    lftind, ritind;  /* edgemost indices shown */extern direct Time    length;          /* current length of piece */extern direct bool    compact,       /* Squeeze as many notes as possible */    beam;main(what)     /* really showall() */  char    what;{     if(what=='s')          show();     else if(what=='p')          hprint();}/*** Good old screen showall() ****/show() {    sexy    staffy, lmargin;    int     bar, xincr;    Index   xyind, ind;    sexy    slot, part, oldslot, oldpart, hilo, nth;    Deltime bmin, gbarmin;     sexy    semitic, incwid;    bool    stemdn;    Deltime deltime, absdelt;    sexy    notex, notey;    Etime   timgoal, thistime, lastime;    Reg EVENT  *evp;     if(gind < 0)          gind = 0;     else if(gind >= nevents)        gind = nevents - 1;reshow:   /* label used only at beginning of score *//*  Pad some room for width of notes & pitmods */     lmargin = LMARGIN+1 /* + !gind */ ;     if(xgoal < lmargin)          xgoal = lmargin;     else if(xgoal > RMARGIN)          xgoal = RMARGIN;/* Make sure all objects of same startime are shown together,*    iff near the left or right edge 96/2/18 *//*  New code to keep ']' and such within right edge 89/10/03 */     if( (xgoal <= lmargin) || (xgoal >= RMARGIN) )          gind = sametime(gind, xgoal > 40);     evp = i2p(gind);     timgoal = evp->startime;    /* make it exact *//* Set gbarind to barline of bar containing gind, * allowing that gind may already be that barline. */    for( ; curind >=0; evp = decdec() )        if(anybar(evp))            break;    gbarind = curind;    gbar = EvBarNo(evp);    gbarmin = barmin(gbarind + 1, FALSE);    /* may exceed nevents-1 *//* Use Xgoal to set the offset of graphic-X,Y arrays * relative to events[], for arrays[413] divided over 640 pixels. * 427 / 640  -- 2/3 x 8 */    xyoff = gind - (16 * (xgoal - (lmargin-LPAD))) / 3;/* How about let's Draw something ... */    wkill(); /* grafix(); */    yclear(SCROLTOP + 1, SCORTOP, BACK);/* Draw the open-ended staves */    drstaves(SCORLEFT, !gind);  /* (*pflush)();   /* Instant user feedback *//* Put the notes & rests on. *//* Two phases: from xgoal to right margin (semitic == 0), * then from xgoal back to left margin (semitic == 1).  */    for(semitic = 0; semitic <= 1; semitic++ ) {        notex = xgoal;        lastime = timgoal;        ind = gind - semitic;/* Set up first bar drawn, which we may be in middle of */        if(ind >= gbarind) {           bar = gbar;           bmin = gbarmin;        }        else {           bar = gbar - 1;           bmin = 0;      /* flag as invalid */        }        oldpart = oldslot = 0;     /* for now *//* THE Inner, Events Loop */        for( evp = i2p(ind);          (curind >=0) && (curind < nevents) && (notex <= RMARGIN);          evp = semitic ? decdec() : plusplus() )        {      /* If new to this bar, update min duration */            part = evp->part;            if( !bmin) {                ind = curind;   /* save thru fcn call */                bmin = barmin(curind, semitic);                evp = i2p(ind); /* restore */            }      /* If no time change, skip lots of code: */            thistime = evp->startime;            if(deltime = thistime - lastime)  /* '=' */            {                lastime = thistime;                absdelt = semitic ? -deltime : deltime;/* Linear placement if delt < bmin or compact mode is off *//* Temporarily re-enter Pixel-X Domain */                if((absdelt < bmin) || !compact) {                    xincr = (8 * NOTEWID * deltime) / bmin;     /* Quantize to byte size for BYTBLT graphics */                    if(xincr < 0) {                         xincr = (xincr - 4) & ~7;                         if(xincr > -8)                              xincr = -8;                    } else {                         xincr = (xincr + 4) & ~7;                         if(xincr < 8)                              xincr = 8;                    }                    notex += xincr / 8;               }/* No, Compact -- just advance by note width */                else                   notex += (semitic ? -NOTEWID : NOTEWID);          /* Test for screen edges */                if((notex < lmargin)                 || (notex > RMARGIN))                   break;            } /* time advanced *//* AT LAST, process note, rest, or inclusion */            slot = evp->show.slot;    /* ASSUMES .slot == .INCTYPE *//* A group of partwise expressors may have been repeating in same X-space;*  if so but now out of the group, then catch up notex to reality. */            if( !oldpart && ispwexpr(oldslot)              && (part || (slot != oldslot)) )                notex += (semitic ? -incwid : incwid); /* previous incwid *//* Inclusion Processing.*  All 'incwid' values must be multiples of 8 for BYTBLT.*/            if(part == 0) {        /* Inclusion */                if(slot > LASTCLUZ) {     /* undefined type */                    grafxes[curind - xyoff] = 0;  /* so Find() can't */                    grafyes[curind - xyoff] = 255;                    continue;                }                incwid = bcluzis[slot];                notey = 0;         /* std default for all-staffers */                if(semitic && ((notex -= incwid) < lmargin))                    break;                grafxes[curind - xyoff] = notex;/* Here, "barline types" means only actual bar lines,*    not including hangers-on from barline menu (TS, K/S, etc.) */                if(slot <= FINE) {  /* BarLine types */                    bar = EvBarNo(evp);            /* Draw barline & no. for each staff;             * special hacks for Nth endings: */                    if(curind) {   /* don't draw #1 bar */                        nth = 0;                        if(slot == NTHENDING) {                            nth = evp->show.REPENDN;                    /* Use a double bar or endrepeat for Nth */                            slot =  (nth == 1) ? SINGLEBAR: ENDREPEAT;                        }            /* All barline types converge here ... */                        putalst(notex, slot, bar);                        if(nth)                    /* Draw the Nth-ending brackets and number;                     * do this last so it wins the dynamite war. */                            putalst(notex, NTHENDING, nth);                    }            /* ...except non-drawn Bar #1 */                    else {                        grafxes[curind - xyoff] = 0;                        incwid = 0;                    }             /* Set up for next Bar */                    bmin = 0;   /* Flag 'bmin' as obsolete */                    bar -= semitic; /* replaces below *//*                    if(semitic)                          lftbar = lftlin = bar--;                      else                          ritbar = ritlin = bar;*/                } /* BarLine inclusions */        /* Complex inclusions needing special draw code        *  and maybe funny 'incwid' diddling:  */     /* How about a CASE stmt? */               else if(slot==KEYSIG)                    drawks(notex, evp->show.KSN);               else if(slot==NUTEMPO)                    drawgli(NUTEMPO, notex, evp->show.TEMPONO);               else if(slot==GENVOL)                    drawgli(GENVOL, notex - 1, evp->show.LEVELNO);               else if(slot==CLOCKON)                    drawgli(CLOCKON, notex, evp->show.PARAM1);               else if((slot==CRESC) || (slot==ACCEL))                    drawcres(notex, evp->show.LEVELNO,                      evp->show.pitmod, evp->show.dur);               else if(slot==LABEL)                    drawlab(notex, evp);     /* evp is arg! */               else if(slot==ACCENT)                    drawgli(ACCENT, notex, evp->show.PARAM1);               else if(slot==TIMESIG)                    drawts(notex, evp->show.TSNUMER, evp->show.TSDENOM);               else if(slot==ISEVT)                    drawgli(ISEVT, notex, -1);               else if(slot==TSEVT)                    drawgli(TSEVT, notex, evp->show.TEVTNO);/* Following inclusions are Part-Specific and need true noteY value.*  Also they fudge notex so groups of them draw in same X-space. */               else if(ispwexpr(slot)) {                    notey = drindiv(                      (slot==INSTR) ? DINS                        : ((slot==LEVEL) ? DXLV : (slot==MCHOP) ? DMCH : DPEV),                      notex, evp->show.PARTNO,                      ( (slot==IPEVT) ? -1 : evp->show.PARAM1) );                    notex += (semitic ? incwid : -incwid);               }        /* (Add other inclusion types here) */        /* Simple inclusions, fixed width and drstring */               else {                    putalst(notex, slot, 0);               }        /* Code common to ALL inclusions, incl BarLines */               grafyes[curind - xyoff] = notey;               if(!semitic && curind) /* undrawn bar#1 no x++ */                    notex += incwid;            } /* inclusions */            else        /* Note or rest. */            {        /* Figure vertical position of note wrt staff */                 showstaff(part, &staffy, &hilo);                 notey = staffy;/*               lftbar = bar; */                 if(slot != REST) {     /* Note */                     notey += (slot + slot);                     stemdn = Stemway(hilo, slot);     /* Keep bass note stems out of Menu */                     stemdn &= (notey > (SCROLTOP + 13));                 }                 else   /* Duet Rests need hi/lo placement */                     notey += Roffset(hilo) + 8;                 grafxes[curind - xyoff] = notex;                 grafyes[curind - xyoff] = notey;    /* So do it already! */                 if( !beam || (slot==REST) || (hilo & NOFLAG))                      (*pdrawnr)(&(evp->show), notex, notey, staffy, stemdn,                        hilo & NOFLAG, FORE);             } /* note/rest *//* Common code for ALL EVENTS -- needed for Inst & Level prefixes */            oldpart = part;            oldslot = slot;        } /* event loop *//* Update border info. * Got here by curind out of range or plotting off screen; *   either way, curind and evp are last valid values +/- 1. */        if( !semitic) { /* Right edge */         /* ritbar = bar; */            evp = decdec();            ritind = curind;         /* lftbar = lftlin = gbar; */        }        else {        /* Left edge */            evp = plusplus();            lftind = curind;        }    } /* semitic loop *//* Fix display so that if beginning is shown, it's at hard left edge */    if( !lftind && (notex > lmargin)) {        gind = xgoal = 0;        goto reshow;    }    if(beam)        Beam();/* Put key signature down left margins */    ind = findkey(lftind);    if(ind)         drawks(SCORLEFT+CLEFWID-1 + !gind, ind);    (*pflush)();} /* showall() *//* eof ~Wm640/SHOW.C */