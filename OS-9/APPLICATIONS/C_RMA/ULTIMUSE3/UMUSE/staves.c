/* file ~VM640/STAVES.C  --12--   begun 6/14/86* Layout & Setup Menus, nice grafix.*/#define FRAG 1      /* for soowee.h */#include "wmuse.h"#include "screen.h"#include "vgraf.h"#include "wcodes.h"#include "wmenu.h"#include "mencodes.h"#include "cursors.h"#include "windows.h"#include "macros.h"#include "soowee.h"#include "fcnptrs.h"#define KEYCEL 1    /* couple of extra keyboard accelerators */#define Noffset(hilo) ((hilo & UPPER) ? 6 : ((hilo & LOWER) ? -6 : 0))#define LAYMNLFT   LAYWINX#define LAYMNRGT   (LAYMNLFT+SET_CWID-1)#define LAYMNTOP   (LAYWINY-TVBORD)#define LAYMNBOT   (LAYMNTOP-PB_VPITCH*LAY_NITEMS)#define SETMNBOT    (LAYMNTOP-PB_VPITCH*SET_NITEMS)/* Private Enum Types; Victim_type codes (arbitrary) */#define VEXCLEF  1#define VTS    2#define VKS    3#define VEXPART 4#define VNUPART 5#define VNUCLEF 6extern direct short     nparts, nstaves, nevents;extern direct sexy     numer, denom, curcurse;extern direct char     *pct2, *pct3;extern direct bool     rfr_scr, rfr_bar;extern char     readone();extern sexy     partstaff(), askclef(), newhilo(), ph2curse();extern void     styinit();extern bool     pforget();/* None of these arrays is R/O: */extern STAFF   staves[NSTAVES];extern PART    parts[NPARTS+1]; /* Parts are ORG 1, not 0! */extern bool    partens[NPARTS+1];/* Botnotes are White keys above 16' C==01.  Mid C ==22. *//* This IS Read-Only! */extern CLEF  clefs[];main(what, exlay)  /* really laymen() */  char    what;     /* selector, not used */  bool    exlay;{     char  buff[BUFFSIZE], ch;     bool  rfr_lay, fire;     sexy  oldcurse, callerct, i, s, p, newclef, oldclef, ph,           mxc, my, omx, omy, graybar,           victype, oldhilo, nuhilo;     int   y, staffy, diffy, lind, rind, tind, mx;     callerct = curcurse;     menu(exlay ? MEN_LAYOUT : MEN_SETUP);     rfr_lay = rfr_scr = rfr_bar = TRUE;     /* score screen wasn't saved */     curset(curcurse = CARROW);     if(nstaves) {  /* prompts did some work already */          dfalprts(1, nparts);     /* update fran */          dfalstvs(0, nstaves - 1);     }     dfsigs();/* May want to use Diamond cursor in Palette side, Arrow in victim */     for(;;) {          if(rfr_lay)               showlay(exlay, FALSE);     /* refresh layout display */          rfr_lay = FALSE;          graybar = PARTCOL + 3 * (nparts + (nparts < NPARTS));/* Expect cursor to NOT be showing when entering here *//* State 1:  Update cursor while awaiting mouse down *//* Extend to keymouse() to pick up Menu initials,*   AND Part #'s 0-G will set VicType to VEXPART if cursor is a Tool. */          ch = (*pkeymaus)(&mx, &my); /* does LOTSA work, like SunView */          mxc = mx >> 3;/* State 2:  Mouse button or a key went down */          if(ch || (mxc > PALXC)) {  /* If palette areas */     /* Reload brush; no cursor move while wait for release */               if(inrect(mxc,my, XOUTLFT,XOUTBOT, XOUTRGT,XOUTTOP)) {                    curset(curcurse = CXOUT);               }               else if(inrect(mxc,my, PRTPLEFT,PRTPLBOT, PRTPLRGT,PRTPLTOP)) {                    i = (mxc - PRTPLEFT) / 3;                    curset(curcurse = CPIT + i);               }               else if(inrect(mxc,my, CLFPLEFT,CLFPLBOT, CLFPLRGT,CLFPLTOP)) {                    i = (mxc - 1 - CLFPLEFT) / 2; /* was /3 2/92 */                    curset(curcurse = CTREBLE + i);               }               else if(ch                 || inrect(mxc,my, LAYMNLFT, exlay ? LAYMNBOT : SETMNBOT,                      LAYMNRGT,LAYMNTOP))               {                    if(!ch) {      /* Get char from Menu Position */                         i = (LAYMNTOP - my) / PB_VPITCH;                         ch = (exlay ? LAYM_STR : SETM_STR) [i];                    }               /* Convert char to actions */                    switch(ch) {                    case 's': /* Re-Number and/or Spread-space  staves */                         if((*pyesno)("Re-Number all Staves?"))                              Renumber;                         if((*pyesno)("Space Staves equally?"))                              styinit();                         dfalstvs(0, nstaves - 1);                         dfalprts(1, nparts);                         rfr_lay = TRUE;                         break;                    case 'p':                    case 'o': /* Re-Order Parts */                         if((*pyesno)("Re-order Parts on All Staves?")) {                              s = -1;                              fire = (*pyesno)(                                "Segregate Clones to the rear?");                         }                         else {                              dialogue(fire = FALSE);                              (*pprintf)("Which Staff (Number)? ");                              (*pgets)(buff);                              wkill();                              if( ! *buff)                                   break;                              s = (*buff - '1') & NSTAVES;  /* limits 0 - 7 */                         }                         Reorder(s, fire);                         dfalprts(1, nparts);                         rfr_lay = TRUE;                         break;                    case 'r': /* Range of voices display */                         if(!(*pfixmarx)(&lind, &rind, &tind))                              break;                         oldcurse = curcurse;                         curset(CBUTTON);                         range(lind, rind);                         (*phit)();     /* using showlay()'s special window */                         curset(oldcurse);                         wkill();  /* the special one */                         rfr_lay = TRUE;                         break;                    case '=':                    case '+': /* +8va part */                         curset(CPLUS8VA);                         break;                    case '-': /* -8va part */                         curset(CMINUS8VA);                         break;                    case 'f': /* reFill part */                         curset(CREFILL);                         break;                    case 't': /* Tacet-ize part OR Time Signature */                         if(exlay)                              curset(CTACET);                         else {                              (*pgtsig)();                              (*pprintf)(pct3, STS, numer, denom);                              rfr_lay = TRUE;                         }                         break;                    case 'c': /* Clear out part */                         curset(CCLEAR);                         break;                    case 'k': /* Key signature */                         if(!exlay)                              (*pprintf)(pct2, SKS, (*pgksig)());                              rfr_lay = TRUE;                         break;                    case '\n':     /* Done */                         if( !exlay && (numer==4) && (denom==4) ) {                              if( !(*pyesno)(                         "Use Common 4/4 Time?") )                                   (*pgtsig)();                              (*pprintf)(pct3, STS, numer, denom);                         }                         wkill();            /* dump buttons menu */                         curset(callerct);                         return;#ifdef KEYCEL          /* Optional accelerators not doc'ed on menu */                    case 'x':                         curset(CXOUT);                         break;                    case ' ': /* Brush clear */                         curset(CARROW);                         break;#endif                    default:                         bell();                         continue;                    } /* switch(ch) */               }               else {    /* Clear the brush */                    curset(CARROW);   /* or CBUTTON */               }          } /* if palette area */  /* if Victim area */          else if(mxc >= CLEFCOL)          {     /* First, classify victim, if any (like find() on Score) */               victype = 0;   /* ie, none */          /* No-man's land?  Leave victype ==0 */               if(mxc >= graybar) {                    curset(CARROW);     /* Clear Brush */               }          /* Clef/Staff? */               else if((mxc >= CLEFCOL) && (mxc < TSCOL)) {                    victype = VNUCLEF;  /* unless overwritten below */                    if((s = (*pfindstaff)(my)) < nstaves) {                         victype = VEXCLEF;                         y = Ystaff(s);                    }               }          /* Existing Part's "Note"? */               else if( (mxc > PARTCOL)                 && ((p = 1 + (mxc - (PARTCOL+1)) / 3) <= nparts) )               {                    s = partstaff(p, &staffy, /* &i, */ &ph);                    y = staffy + 8 + Noffset(ph);                    if((my >= y-3) && (my <= y+2))                         victype = VEXPART;               }          /* New Part?  Depends on above vicnum 'p' */               else if(p == nparts + 1) {                    if( (s = (*pfindstaff)(my)) < nstaves) {                         victype = VNUPART;                         staffy = Ystaff(s);                    }               }          /* Endif Classification of victim -- skip if none */               if(!victype) {                    bell();   /* maybe not wanted */                    continue;           /* the whole main loop */               }     /* Is brush loaded? */               if((curcurse!=CARROW) && (curcurse!=CBUTTON))               {          /* If victim appropriate for brush */               /* Modify victim or create new one */               /* Clear brush afterwards?  Was it good for you too? */                    if((curcurse>=CTREBLE) && (curcurse<=CLASTCLEF))                    {                         if(victype==VNUCLEF) {   /* Add new staff */                              if(nstaves >= NSTAVES) {                                   (*palert)("No more Staves!\n", 0);                                   continue;                              }                              s = nstaves++;      /* yes, lag 1 behind */                              staves[s].staffY = my - 8; /* hot spot fix */                              staves[s].clef_no = curcurse - CTREBLE;                              dfalstvs(s, s);                              rfr_lay = TRUE;                         }                         else if(victype==VEXCLEF) {   /* Change clefs */                              oldclef = staves[s].clef_no;                              staves[s].clef_no = newclef                                = curcurse - CTREBLE;                    /* transpose .slots when clef is changed */                              for(p = 1; p <= nparts; p++)                                   if( parts[p].pstaff == s)                                        fixslot(p, oldclef, newclef);                              dfalstvs(s, s);                              rfr_lay = TRUE;                         }                         else {    /* No other victims make sense */                              bell();                         }                    } /* endif cursor==clef */                    else if(victype==VEXPART) {                         oldhilo = parts[p].philo & NOFLAG;                         switch(curcurse)                         {                         case CPIT:                         case CPITNF:                         case CPERC:                         case CPERCNF:  /* Change part style */                              parts[p].philo = nuhilo                                = newhilo(ph, curcurse, my, Ystaff(s));                              nuhilo &= NOFLAG;                    /* Removed flags? */                              if( !oldhilo && nuhilo                                && (*pyesno)("Remove Rests from part?") ) {                                   patience();                                   tacet(0, nevents-1, p, FALSE, TRUE);                                   wkill();                              }                    /* Or added flags? */                              if(oldhilo && !nuhilo                                && (*pyesno)("Restore Rests to part?") ) {                                   patience();                                   refill(0, nevents-1, p);                                   (*pfixup)(0, nevents-1, p, FALSE);                                   wkill();                              }                              dfalprts(p, p);                              rfr_lay = TRUE;                              break;                         case CXOUT:                              rfr_lay = pforget(p);                              break;                         case CREFILL:                         case CPLUS8VA:    /* +8va */                         case CMINUS8VA:   /* -8va */                              if(!(*pfixmarx)(&lind, &rind, &tind))                                   break;                              if(curcurse==CREFILL) {                                   if( ( !oldhilo & NOFLAG) || (*pyesno)(                                     "No-Flags Clone-Part; Refill anyway?")) {                                        patience();                                        refill(lind, rind, p);                                        wkill();                                   }                              }                              else {                                   patience();                                   (*ptranprt)(p,                                     (curcurse==CPLUS8VA) ? 7 : -7, lind,rind);                              }                              wkill();                              break;                         case CTACET:                         case CCLEAR:                              if(!(*pfixmarx)(&lind, &rind, &tind))                                   break;                              patience();                              tacet(lind, rind, p, curcurse==CCLEAR, oldhilo);                              wkill();                              break;                         default:                              bell();                         } /* switch */                    }                    else if(victype==VNUPART) {                         if((curcurse>=CPIT) && (curcurse<=CPERCNF)) {                              if(nparts >= NPARTS) {                                   bell();                                   continue;                              }                    /* Add a new part */                              p = ++nparts;                              parts[p].pstaff = s;                              parts[p].philo = nuhilo                                = newhilo(0, curcurse, my, staffy);                              partens[p] = TRUE;                    /* Fill all bars with rests, unless no-flag part */                              if( !(nuhilo & NOFLAG)) {                                   patience();                                   refill(0, nevents - 1, p);                                   dfalprts(p, p);                                  wkill();                              }                              rfr_lay = TRUE;                         }                         else {    /* No other brushes make sense */                              bell();                         }                    }     /* Can't X-out KS, TS, or unborn parts or staves.  Just staves? */                    else if(curcurse==CXOUT) {                         if(victype == VEXCLEF) {                    /* Check for parts still on it */                              for(p = nparts; p; p--)                                   if(parts[p].pstaff == s)                                        break;                              if(p) {                                   (*palert)(     "Can't delete Staff until all its Parts\n  are Moved Off or Deleted.",                                   0 );                                   continue;                              }                    /* Decrement staff #s in parts[] */                              fgstaff(s);                              nstaves--;                              for(p = nparts; p; p--)                                   if( parts[p].pstaff >= s)                                        parts[p].pstaff--;                              dfalprts(1, nparts);                    /* Bubble down staves[] */                              strdn(staves + s, staves + s + 1,                                (nstaves - s) * sizeof(STAFF) );                              dfalstvs(s, nstaves - 1);                              rfr_lay = TRUE;                         }                    }          /* Not appropriate */               /* Beep user */               /* Clear brush? No. */                    else {                         bell();                         continue;                    }               } /* endif brush loaded */     /* Else brush is empty (victim already classified), Must Drag. */               else      /* Brush empty */               {          /* Pick-up victim to drag into cursor */                    switch(victype)                    {                    case VEXCLEF:                    /* Erase present clef */                         storf(s, FALSE);                         newclef = staves[s].clef_no; /* Parnas ain't lookin */                         diffy = my - y;                         while((*pmouce)(&mx, &my)) {  /* Staff drag loop */                              if(my == y + diffy)                                   continue;                              storf(s, FALSE);                              y = my - diffy;                              if(y < 8)          y = 8;                              if(y > 191-16-8)   y = 191-16-8;                    /* Update official StaffY */                              Ystaff(s) = y;      /* works with macro! */                              dfstaff(s, newclef, y);                    /* and use it to redraw */                              storf(s, TRUE);                              (*pflush)();                         } /*   drag staff loop */                         rfr_lay = TRUE;                         break;                    case VEXPART:                         rfr_lay = TRUE;               /* Whaddya do if user leaves part in nonsense location? */               /* Answer: Leave it as-is (put it back) */                    /* Use part #p to get duplicate "note" cursor type */                         curcurse = ph2curse(ph);                         curset(curcurse);                         diffy = my - y;     /* y is Roffset'ed */                    /* Erase present, using cursor at its exact loca */                         mxc = PARTCOL + 3 * p - 1;                    /* Drag loop */                         while((*pmouce)(&mx, &my)) {                              if(my == y + diffy)                                   continue;                              cursor(8 * mxc, y);      /* erase */                              y = my - diffy;                              if(y < 8)       y = 8;                              if(y > 191-8)   y = 191-8;                              cursor(8 * mxc, y); /* draw */                              (*pflush)();                         } /*   drag partnote loop */                    /* Erase cursor on loop exit */                         cursor(8 * mxc, y);               /* Update dragged part & redraw */                    /* What staff if any it's on */                         s = (*pfindstaff)(y);                         if(s >= nstaves)    /* If none, skip update */                              break;                         staffy = Ystaff(s);                         ph = newhilo(ph, curcurse, y, staffy);                         parts[p].philo = ph;                         oldclef = staves[parts[p].pstaff].clef_no;                         parts[p].pstaff = s;                    /* transpose .slots when staff is changed */                         newclef = staves[s].clef_no;                         fixslot(p, oldclef, newclef);                         dfalprts(p, p);                         break;    /* dragged part */                    default:                         bell();                    }          /* Always clear brush after drag */                    curset(CARROW);               } /* brush empty */          } /* if victim area  -- endif palette -vs- victim areas */     } /* main Loop */} /* laymen() *//* eof ~Vm640/STAVES.C   */