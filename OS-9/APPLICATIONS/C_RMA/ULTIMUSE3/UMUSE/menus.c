/* file ~VM640/MENUS.C  nee BMENS.C    --4A-- * Text Menus and choices reached from Main (MUSED) graphic menu. * Some may be text, others graphic. * textmenu()'s next to last arg is 2 or 3 less than _NITEM, *  and == no. of chars in string not counting initial \n.*/#define FRAG 1#include <stdio.h>#include "wmuse.h"#include "mencodes.h"#include "cursors.h"#include "windows.h"#include "vmem.h"#include "fcnptrs.h"/* #include "soowee.h" *//* Note: Channel #s are kept 0--15, as actually transmitted */extern ubyte     chans[NPARTS + 1];extern direct ubyte     midinnmin, midinnmax;extern direct byte  accentwt;extern bool     partens[NPARTS + 1], chanens[16];extern direct sexy    nparts, curcurse,    velo,       /* MIDI note attack velocity */    transp,     /* # semitones to shift play */    secmin;extern direct Index    undind, lftind, gbarind, gind, xgoal;extern direct short     xgoal, numer, denom;extern direct bool     compact, rfr_scr, midipak, midiser, mididev, instren, clocken,     midievts, scrclock, pldebug, smf;extern EVENT     undevent, zevent;extern direct Time    length;extern direct sexy     nparts,     curcurse;extern ubyte     levels[];extern char     *vols, filename[], pfdat1[];bool evtenter(), barmenu();sexy hexc2i();/* Soowee calls to "Um3M" switch thru here */bool main(what, arg1, arg2)  char    what;  int     arg1, arg2;    /* or whatever type */{     switch(what) {     case 'm': midimen();     break;     case 'i': instrmen();    break;     case 's': instrsho();    break;     }     what = *pfdat1;     /* to pull in d347.r */} /* Um3M's main() *//******* MIDI Part->Channel Assignment Package *//* clonemid() moved to bt.c *//* Give '+' for TRUE and '-' for FALSE */char conoff(what)  bool    what;{     return(what ? '+' : '-');}midimen() {     ubyte     work[NPARTS + 1];     char      buff[BUFFSIZE], c;     bool needwin;     sexy      q, pl, pu, chan;     Reg int   p;     _strass(work, chans, NPARTS+1);    /* was strdn() */     needwin = TRUE;     /* 1st time only */     while(TRUE) {          if(needwin) {               wcreate(MIDI_LCOL, MIDI_TOPY, MIDI_CWID, MIDI_NITEMS,                 TRUE, WSDOUBLE);               needwin = FALSE;          }          (*pprintf)("\014      MIDI MENU\n");          (*pprintf)(" Part  Chan   Part  Chan\n");          for(p = 1; p <= NPARTS/2; p++) {               q = p + NPARTS/2;               (*pprintf)(" %c%c--> %c%-2d    %c%c--> %c%-2d\n",                 conoff(partens[p]), i2hexc(p),                 conoff(chanens[work[p]]), work[p] + 1,                 conoff(partens[q]), i2hexc(q),                 conoff(chanens[work[q]]), work[q] + 1);          }          prmenu(MEN_MIDI, NULL);    /* this does NOT open a window */          c = (*ptextmen)(MIDI_LCOL, MIDI_TOPY+2, MIDI_CWID/2,            2, 2, 16, TRUE);          if( c < 0)     /* actually typed */               c = -c;          else               c = "\n192a3b4c5d6e7f8g  oiwpurkntq+-ml" [c];          (*pputchar)(c);          p = hexc2i(c);          if(p) {        /* is it Hex? */                    if(p <= NPARTS) {                    (*pprintf)("-->");                    (*pgets)(buff);                    chan = atoi(buff);                    if(chan)                         work[p] = (chan - 1) & 15;     /* User typo here will turn part ON, not OFF -- less confusing */                    else                         partens[p] = ( *buff != '-');               }               continue;          }/* Not a part number */          switch(c)          {          case '#':               (*pprintf)(" '#' means a Part No. 0 - 9, a - g.");               break;          case 'p':        /* Play whole piece */          case 'w':        /* Play from Window (screen) */               _strass(chans, work, NPARTS+1); /* First, Update it */               if(pldebug) {                    wkill();  /* this MIDI menu */                    needwin = TRUE;               }               (*pputchar)('\n');               (*pplay)( (c=='w') ? lftind : 0, nevents - 1);               if(rfr_scr) {     /* ^C, back to score NOW! */                    wkill();                    return;               }               break;            /* else stay in main menu */          case 'l':               lvlsmen();     /* Does open an offset overlaid window */               wkill();       /* and doesn't close it */               break;     /* Just to avoid beeps */          case 3:        /* ^C after Play */          case 5:        /* BREAK after Play */               break;          case 'o':               (*pprintf)("  -->");               (*pgets)(buff);               chan = atoi(buff);               if( !chan)                    break;               chan = (chan - 1) & 15;               (*pprintf)("(ENTER for all parts)\nFrom part:");               if(pl = onehex() ) {                    (*pprintf)(" thru part:");                    if( !(pu = onehex()) )                         pu = NPARTS;               }               else {         /* Do 'em all */                    pl = 1;                    pu = NPARTS;               }               for(p = pl; p <= pu; p++)                    work[p] = chan;               break;          case 'i':               for(p = NPARTS + 1; --p; )                    work[p] = p - 1;               break;          case '+': /* Turn a channel on or off */          case '-':               (*pprintf)(" Channel: ");               (*pgets)(buff);               chan = atoi(buff);               if( !chan)                    break;               chanens[(chan - 1) & 15] = (c == '+');               break;/* Non-channel MIDI modes */          case 'm':               mmodesmen();   /* does own wkill() */               break;/* Menu operations */          case 't': /* Tutti, turn on all parts & chans */               if((*pyesno)(" Turn on All Parts?"))                    for(p = nparts + 1; --p; )                         partens[p] = TRUE;               if((*pyesno)(" Turn on All Channels?"))                    for(p = 16; --p >= 0; )                         chanens[p] = TRUE;               break;          case 'q': /* Quiet, turn off all parts & chans */               if((*pyesno)(" Shut off All Parts?"))                    for(p = NPARTS+1; --p; )                         partens[p] = FALSE;               if((*pyesno)(" Shut off All Channels?"))                    for(p = 16; --p >= 0; )                         chanens[p] = FALSE;               break;          case 'r':               _strass(work, chans, NPARTS+1);               break;          case '\n':     /* ENTER (formerly 'k', Keep & exit) */          case 'u':      /* Update */               _strass(chans, work, NPARTS+1);               if(c == 'u')                    break;          case 'n':      /* Never mind */               wkill();               return;          case 'k': /* Klone chans to follow flagships */               (*pclonmid)(1, nparts, work);    /* all parts */               break;          default:               bell();          } /* switch */     } /* while */ } /* midimen() */mmodesmen() {  /* MIDI Modes grafix submenu */     sexy oldcurse;     char ch;     oldcurse = curcurse;     curset(CBUTTON);     do {      /* while(ch != 0) */          menu(MEN_MMOD);          (*pprintf)("%d%d%d%d%d%d%d", midiser, midipak, mididev, smf,            instren, clocken, midievts);          (*pprintf)("%2d\n%3d\n%3d\n%d%3d\n%2d\n%3d\n\n",            velo, midinnmin, midinnmax, scrclock, transp, secmin,            accentwt);          ch = (*pmenukey)("rmdf icevnx utsa\n", MMOD_LCOL, MMOD_CWID,                 MMOD_TOPY, MMOD_BOTY);          wkill();          switch(ch) {          case 'a':               dialogue(0);               accentwt = getdefp( "Accent Volume Boost [%d]: ", accentwt);               wkill();               break;          case 'm':               if(midipak = !midipak)                    smf = mididev = FALSE;               break;          case 'r': /* RS-232 port */               if(midiser = !midiser)                    smf = FALSE;               break;          case '/':          case 'd': /* /MIDI Device */               if(mididev = !mididev)                    smf = midipak = FALSE;    /* MUST keep these mutex */               break;          case 'f':               pldebug = (smf = !smf);               midiser = midipak = mididev = FALSE;               break;          case 'i':               instren = !instren;               break;          case 'c':               clocken = !clocken;               break;          case 'e':               midievts = !midievts;               break;          case 'u':               scrclock = !scrclock;               break;          case 's':               dialogue(0);               secmin = clamp(getdefp(                 " Seconds per Minute [%d]: ", secmin), 20, 180);               wkill();               break;          case 't':               dialogue(0);               transp = clamp(getdefp(" SemiTones [%d]: ", transp),                 -24, 24);               wkill();               break;          case 'v':               dialogue(0);               velo = clamp(getdefp(" Master MIDI Volume [%d]: ", velo),                 -127, 127);               wkill();               break;          case 'n':               dialogue(0);               midinnmin = clamp(getdefp(" Min. MIDI Note No. [%d]: ",                 midinnmin), 1, 127);               wkill();               break;          case 'x':               dialogue(0);               midinnmax = clamp(getdefp(" Max. MIDI Note No. [%d]: ",                 midinnmax), 1, 127);               wkill();               break;          case '\n':               ch = 0;   /* bust out of loop */               break;          default:               bell();          }     } while(ch);     curset(oldcurse);}/******** MIDI Volume Levels Menu & Manipulater *//* Does not kill own window; midimen() caller must! */lvlsmen() {     char obuff[40], buff[BUFFSIZE];     int  v, delta, top, bot;     char cm, ch;     menu(MEN_LEVELS);     for( ; ; ) {          (*pprintf)("\014 MIDI Volume Levels\n\n");          (*pprintf)(" # EXPR  VALUE\n");          for(v = 0; v < NLEVELS; v++)               (*pprintf)(" %d  %3s  %3d\n", v, vols + 4 * v, levels[v]);          (*pprintf)("\n E = Even spacing\n\n  # of Level to change: ");          cm = (*ptextmen)(LVL_LCOL, LVL_TOPY, LVL_CWID, 1, 3, 10, TRUE);          if(cm < 0)               ch = -cm;          else               ch = "\n01234567 e" [cm];          (*pputchar)(ch);          if(ch == '\n')      /* Return to calling menu */               break;/* Distribute levels 1 thru 6 linearly between 0's and 7's values.*  Yes, this works backwards too! */          if(ch == 'e') {               (*pprintf)("\n(ENTER for all 0 to 7)\n");               (*pprintf)(" From Level # ");               (*pcharmaus)(buff);               if( (ch = *buff) == '\n') {                    bot = 0;  top = NLEVELS - 1;               }               else {                    bot = hexc2i(*buff) & (NLEVELS-1);                    (*pprintf)("\n   To Level #");                    top = onehex() & (NLEVELS-1);                    if(top - bot < 2)                         continue;               }               delta = levels[top] - levels[bot];               for(v = top;  --v > bot;  )                    levels[v] = levels[bot] + ((v - bot) * delta) / (top-bot);          }          else {               v = ch - '0';               if((v > 7) || ( v < 0))  {    /* illegal char */                    bell();                    continue;               }               (*psprintf)(obuff, "\n#%d's New Value [%%d]: ", v);               levels[v] = getdefp(obuff, levels[v]) & 127;          }     }} /* lvlsmen() *//* eof ~Vm640/MENUS.C */