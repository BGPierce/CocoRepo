/* file L2/APPEND.C Finally writing some Append code 94/3/21 */#include "wmuse.h"#include "fcnptrs.h"#include "windows.h"#include "titles.h"#include "vmem.h"#define CopyObjP(d,s) _strass(d,s,SEVENT)extern int     read(), write();     /* needed for pointers */extern EVENT   *events, zevent;/* None of these arrays is R/O: */extern STAFF staves[NSTAVES];extern PART  parts[NPARTS + 1]; /* Parts are ORG 1, not 0! *//* This IS Read-Only! */extern CLEF  clefs[];extern short     instvals[NINSTRS];extern char     instnams[NINSTRS] [10],     filename[SFILENAME],     percsynth[24];extern ubyte     chans[NPARTS + 1],     levels[NLEVELS],     percmids[17];extern Index     nevents;     /* must keep 16 bits (short) */extern short                  /* Parts of Score File, MUST keep 16 bits */     scorelvl, nstaves, numer, denom, secmin, transp;extern ubyte     scrclock;     /* Also in score file, 8 bits */extern sexy     xgoal, nbars, nzones, nparts;extern direct Index     lftind, ritind, gind;extern direct sexy     curcurse, keysig;extern direct Time     length;extern direct bool     readonly, rfr_scr, rfr_tit, rfr_bar;extern ubyte     *evtarray,          /* actually a pointer to base of malloc'ed */     *evtartop,          /* to last malloc'ed byte */     *evtarnxt;          /* to next (1st unused) byte */void        fnamenu();   /* Should use this, but don't yet *//* Read and append given filename (sans extent) to*  current score.  Reject if irreconcileable differences.*/bool appendio(fname)  char     *fname;{/* Vars starting with "ic" are "dupes" of curent score's globals, * but prefixed "ic" for InComing score: */     PART     icparts[NPARTS+1];     STAFF    icstaves[NSTAVES];     EVENT    tempevt;     int      did, didread;     long     whereto;     /* corrects for too-long scores */     ubyte    icscrlvl, icnparts;     short    icnstaves, icnumer, icdenom, icnevents, icsecmin;     int      cuclef, icclef;     int      evtsiz, evtsleft;     /* a la "evtarsiz" */     short    icevtsiz;               /* must match file */     ubyte    cuhilo, ichilo, icea;     PART     *ptptr;     bool     ok = TRUE;     /* innocent until ... */     Index    icbegin;     int      chan, prt, mismatch;     Reg EVENT *evp;     wcreate(14, 150, 50, 14, TRUE, WSDOUBLE);/* Assume filename has room for 4 more chars */     addext(fname, ".ume");     chan = open(fname, 1);     if(chan < 2) {          (*pprintf)("\007No '%s'\n\l", fname);          (*phit)();          wkill();          return(FALSE);     }/* File is open, proceed. */     read(chan, &icscrlvl, 1);     read(chan, &icnparts, 1);     icnparts &= 31;     read(chan, &icnstaves, 2);     read(chan, &icnumer, 2);     read(chan, &icdenom, 2);     read(chan, &icnevents, 2);     read(chan, icparts, (icnparts + 1) * sizeof(PART));     read(chan, icstaves, icnstaves * sizeof(STAFF));/* Pass several tests before proceeding. * Luckily there are no show-stopper data after the score!*//* If version numbers differ, warn user and update to Max */     if(icscrlvl > scorelvl) {          /* (*pprintf)("Raising Version to %d, OK.\n", icscrlvl); */          scorelvl = icscrlvl;     }/* Fewer incoming parts is OK.  More, I dunno... *//*     if(icnparts < nparts) {          (*pprintf)("Fewer Incoming parts, OK.\n");     }*/     if(icnparts > nparts) {          (*pprintf)("I QUIT; more Incoming parts!\n");          (*phit)();          wkill();          return(FALSE);     }/* The most important check:*  Each numbered Part must have same Clef between Current & Incoming*    scores.  Anything else is user's minor problem,*  except: Don't mix old-style "hollow" Perc parts with anything else!*/     mismatch = 0;     for(prt = 1; prt <= icnparts; prt++) {          cuhilo = (ptptr = parts + prt) -> philo;          cuclef = (staves + (ptptr->pstaff)) ->clef_no;          ichilo = (ptptr = icparts + prt) -> philo;          icclef = (icstaves + (ptptr->pstaff)) ->clef_no;          if(cuclef != icclef) {               mismatch++;               (*pprintf)("Clefs mismatch Part %d!\n", prt);          }          if( (cuhilo ^ ichilo) & PERC) {               mismatch++;               (*pprintf)("Mismatched old 'Hollow' Perc, Part %d!\n", prt);          }     }     if(mismatch) {          (*pprintf)("I QUIT: %d Errors!\n", mismatch);          (*phit)();          wkill();          return(FALSE);     }/* OK, ATP!  Let's go! */     wkill();       /* use only alert() from here on *//* Insert a double bar to flag junction point */     CopyObjP(&tempevt, &zevent);     tempevt.show.INCTYPE = DUBARLINE;     evp = i2p(nevents);      /* 1st open slot */     nevents += 2;     CopyObjP(evp, &tempevt);     evp = plusplus();/* Any Timesig is fine, if accurate.  Make sure it is!*  Else just stick a 2nd double barline. */     if(icnumer && icdenom) {          tempevt.show.INCTYPE = TIMESIG;          tempevt.show.TSNUMER = icnumer;          tempevt.show.TSDENOM = icdenom;     }     CopyObjP(evp, &tempevt);     icbegin = nevents;          /* Save index to 1st object of new score *//* Unfix the current score, so both will fix together */     barswap();/* The main events ... */     nevents += icnevents;     /* before they hatch? *//* In case memory runs out before whole score reads in: */     whereto = lseek(chan, 0l, 1) + (long)icnevents * (long)SEVENT;  /* Check new total nevents against NEVENTS */     if(nevents > NEVENTS) {          nevents = NEVENTS;          (*pprintf)("WARNING: Score cut short!\n");          (*phit)();     }/* At last -- move some data *//* Read one event at a time; sub-light, but so what? */     evp = i2p(icbegin);     for(did = 0; did < icnevents; did++, evp = plusplus() ) {          didread = read(chan, (ubyte *)evp, SEVENT);          if(didread != SEVENT)    /* read error */               break;     }     if(did != icnevents) {          /* some sort of disk error */          ok = FALSE;          nevents -= (icnevents - did);     }/* Next line fixes read-in score */     barswap();                    /* Swabs Read-in */     lseek(chan, whereto, 0); /* as if all events read *//* Add current score's Length to all Startimes in Incoming*  objects as well as to the 2 items we stuck in */     for(evp = i2p(icbegin - 2); curind < nevents; evp = plusplus() )          evp->startime += (Etime)length;/* Display the new "joint", centered */     xgoal = 40;          /* Halfway across screen */     gind = icbegin;/* Trailing items -- how to handle? *//* Even look at secmin?  Warn user if different? *//* Try to do anything with Instrs?  Renumber? *//* Warn of diffs in Channel Assignments Table? */     skipread(chan, 2 + sizeof(instvals) + sizeof(instnams) + sizeof(chans));/* Just ignore these *//* Shareware scores have MIDI Levels here.  SCRLVL-3 should have! *//* But some sharewares labeled "2" lack them, so give free credit for ==2.*//* To save prog RAM, just test now for Events (level >= 9), * since no point in skipread'ing all this junk except to get * to the Events.*/     if(icscrlvl >= 9) {          skipread(chan, sizeof(levels));/* Most certainly vill ignore this! *//* Title/Info Banner */          skipread(chan, TLEN*(TLINES+1) );/* Some of these warn user if different *//* Percmids *could* be remapped if different, someday *//* Level 6 Genvol Levels and Percussion MIDI note numbers,*  plus L7 MIDI Transpose */          skipread(chan, 8 + 17 + 24 + sizeof(scrclock) + 2);/* AT LAST -- Append incoming pseudo-inline MIDI Events to current table */          evtsiz = ievtused();     /* current */          evtsleft = evtartop - evtarnxt + 1;          ok &= (read(chan, &icevtsiz, 2) == 2);          if(ok && (icevtsiz > 1) ) {               icevtsiz--;          /* omit leading EA byte */               did = icevtsiz - evtsleft;               if(did > 0) {                    (*palert)("Some Events cut!", 0);                    icevtsiz = evtsleft;               }     /* Check, but discard, the EA byte */               read(chan, &icea, 1);               if(icea != 0xEA)                    (*palert)("ESB not 234, =", 1, icea);     /* Finally, read the events */               (*pswapevts)(TRUE);               ok &= (read(chan, evtarnxt, (int)icevtsiz) == icevtsiz);               (*pswapevts)(FALSE);               if(did > 0)          /* skip any unread events */                    skipread(chan, did);               evtarnxt += icevtsiz;     /* non-Parnas! */     /* Add offset difference to all events in incoming */               evtsiz--;     /* offset, w/out EA */               for(evp = i2p(icbegin); curind < nevents; evp = plusplus() ) {                    if( !evp->part                      && ((evp->show.INCTYPE == IPEVT) || (evp->show.INCTYPE == ISEVT))                      && ((char)evp->show.IEVTBYT0 >= 0) )                         *((short *)(&evp->show.IEVTBYT0)) += evtsiz;               }          } /* if read ievtsize OK */     } /* if iscrlvl >= 9, Events */     close(chan);     if( !ok)          (*palert)("Append read errors.\n", 0);     return(ok);} /* appendio() *//* Fcn to pretend to read next N bytes of given integer channel,*  positioning disk head where you wud've ended up.*  To restore error checking, use the longer commented-out form.*/skipread(chan, nofbytes)  int     chan, nofbytes;{/*     long whereto;     whereto = lseek(chan, 0l, 1) + (long)nofbytes;     lseek(chan, whereto, 0);*/     lseek(chan, (long)nofbytes, 1);}/* Return no. of event bytes currently in use */int ievtused() {     return(evtarnxt - evtarray);}/* eof L2/APPEND.C */