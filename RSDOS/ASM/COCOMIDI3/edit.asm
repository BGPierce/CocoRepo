* EDIT/TXT* Edit the MIDI buffer* For CoCo MIDI 3* (C) 1988 by Lester HandsMAXSYS EQU 6 max. # of sys. events* edit MIDI buffer*Edit PROC S_MPTR LBSR GETPOS LDX S_MPTR,S CALL DspPage,(S_MPTR,S)* display and edit eventA@ CALL Note,REGX display note event CMPD #0 BNE D@ CALL NextEvnt,REGX TFR D,X BRA A@D@ CALL EdEvnt,REGX TFR D,X CMPD #$FFFF check for BREAK BNE A@ CLR TRAK_FLG enable filterZ@ ENDP* editing positions (XPOS) for events*NOTEPOS FCB 0,10,13,18,23,27,$FF* Edit a displayed event* Returns -1 if BREAK is pressed* otherwise returns current event address* LOCAL L_CNTEdEvnt PROC S_PTR* set cursor position to first editing position LEAX NOTEPOS,PCR LDB ED_POS,PCR LDA B,X STA XPOS,PCR* get keyboard inputA@ LBSR MOVEB@ LBSR INKEY DEC a@,PCR BNE C@ LDB #10 flashing cursor STA a@,PCR LDB [CURSADR] EORB #$40 STB [CURSADR]C@ TSTA BEQ B@ LDX CURSADR LDB 1,X ANDB #$40 PSHS B LDB ,X ANDB #$BF ORB ,S+ STB ,X* check for break CMPA #BREAK BNE D@ LDD #$FFFF STD S_PTR,S BRA Z@* do commandD@ TFR A,B LEAX ED_KEYS,PCR PSHS X LDX S_PTR+2,S LBSR DoCmd LEAS 2,S CLR FILT_FLG,PCR STX S_PTR,S STX ED_ADR,PCR* redisplay current line CALL Note,REGX* check cursor position LBSR CHKPOS LEAY NOTEPOS,PCR LDB ED_POS,PCR LDA B,Y STA XPOS,PCR BRA A@Z@ LDD S_PTR,S ENDPa@ FCB 10 cursor flash count************************************************** All of the following routines that start with* EK_ are called from EdEvnt through DoCmd. They* all expect that register X points to the current* MIDI event, and they all return that pointer.*************************************************EK_LEFT PSHS X LDB ED_POS,PCR BEQ Z@ DECB STB ED_POS,PCR LEAX NOTEPOS,PCR LDA B,X STA XPOS,PCRZ@ PULS X,PCEK_RIGHT PSHS X INC ED_POS,PCR LBSR CHKPOS LEAX NOTEPOS,PCR LDA ED_POS,PCR LDB A,X BMI Z@ STB XPOS,PCRZ@ PULS X,PCEK_RECRD LDD 0,X CMPX #$FFFF BNE A@ CMPX BUFFER1 BHI B@ CLRA CLRB BRA A@B@ LDD -EVNSIZE,XA@ STD ARG1 CALL Record,REGX,ARG1 CALL GoTo,[MEM_LINE] TFR D,X LBSR CLS CALL DspPage,REGX RTS LOCAL L_CNT,L_PTREK_PLAY PROC LDD 0,X get event time*        LBSR    SetBrBt* round off time to nearest beat CALL Divide,(0,X),TIMEBASE LDD [S.X,S] get event time PSHS X subtract ticks to SUBD ,S++ get whole # of beats STD ARG2 LDX S.X,S CALL Play,REGX,ARG2 TFR D,X STD L_PTR,S LDA #8 STA L_CNT,SA@ CALL PrevEvnt,REGX TFR D,X DEC L_CNT,S BNE A@ CLR XPOS CLR YPOS LBSR MOVE CALL DspPage,REGXB@ CMPX L_PTR,S BHS C@ LBSR EK_DOWN BRA B@C@ STX S.X,S ENDPEK_SPACE LDD ,X CMPD #$FFFF BEQ Z@ CALL PlayNote,REGX LBSR EK_DOWNZ@ RTSEK_UP CMPX BUFFER1 BLS Z@ CALL PrevEvnt,REGX PSHS D CMPX ,S++ BEQ Z@ TFR D,X TST YPOS,PCR BNE A@ LBSR SCROLDWN BRA Z@A@ DEC YPOS,PCRZ@ RTSEK_INSRT PROC CALL Insert,REGX CALL DspPage,REGX LDA #1 request screen updateZ@ ENDPEK_DEL LBSR CHKFILT D key (delete) TSTA BEQ B@ CALL NextEvnt,REGX TFR D,XB@ CALL Delete,REGX LBSR CHKFILT TSTA BEQ A@ CALL NextEvnt,REGX TFR D,XA@ CALL DspPage,REGX RTSEK_ENTER CLRA LDB ED_POS,PCR STD ARG2 CALL EdENTER,REGX,ARG2 RTSEK_DOWN LDD ,X CMPD #$FFFF BEQ Z@ LBSR LINEDOWN CALL NextEvnt,REGX TFR D,XZ@ RTSEK_SDWN CALL ShftMov,#EVNSIZE TFR D,X RTSEK_SUP CALL ShftMov,#-EVNSIZE TFR D,X RTS LOCAL L_CNTShftMov PROC L_DIR LDA #16 STA L_CNT,SA@ LDD L_DIR,S BMI B@ CALL NextEvnt,REGX BRA C@B@ CALL PrevEvnt,REGXC@ TFR D,X DEC L_CNT,S BNE A@ CLR XPOS,PCR CLR YPOS,PCR LBSR MOVE CALL DspPage,REGX TFR X,D ENDPEK_GOTO PROC LEAX a@,PCR CALL SetBox,REGX CALL BoxInp,REGX LBSR ClrBox CMPB #BREAK BEQ Z@ LEAX d@,PCR CALL CnvATim,REGX STD ARG1 CALL GoTo,ARG1 TFR D,X LBSR CLS CALL DspPage,REGX STX S.X,S return adrs in XZ@ ENDP*a@ FDB 5,5,23,5,*+4,b@ FDB 2,2,c@,0 text stringb@ FDB 12,2,d@,0,0 input stringc@ FCC "GOTO TIME=",0d@ FCC "1/1:0    ",0 LOCAL L_TIM,L_DIREK_SLIDE PROC LEAX a@,PCR CALL SetBox,REGX CALL BoxInp,REGX LBSR ClrBox CMPB #BREAK BEQ Z@* check for negative sign CLR L_DIR,S LEAX d@,PCR LDA ,X CMPA #'- BNE F@ DEC L_DIR,S LEAX 1,X* convert ASCII time to binaryF@ CALL CnvNotLn,REGX CMPD #0 abort if time=0 BEQ Z@ STD L_TIM,S* check for maximum negative shift LDX S.X,S restore X as ptr LDD ,X get current time CMPX BUFFER1 to music BEQ B@ SUBD -EVNSIZE,X subtract previousB@ TST L_DIR,S BPL A@ CMPD L_TIM,S BHS A@ LBSR SndErr BRA Z@* now adjust times of ALL events (global!)A@ LDD ,X CMPD #$FFFF check for end of music BEQ E@ TST L_DIR,S BPL G@ SUBD L_TIM,S BCC D@ CLRA CLRB BRA D@G@ ADDD L_TIM,S BCC D@ LDD #$FFFED@ STD ,X LEAX EVNSIZE,X BRA A@E@ LDX S.X,S CALL DspPage,REGXZ@ ENDP*a@ FDB 5,5,23,5,*+4,b@ FDB 2,2,c@,0 text stringb@ FDB 13,2,d@,0,0 input stringc@ FCC "SLIDE TIME=",0d@ FCC "0:0     ",0EK_ALL LDA #1 STA TRAK_FLG LBSR CLS LDX MEM_LINE CALL DspPage,REGX RTS* Find given event time* return address of event in D*GoTo PROC S_TIME LDX BUFFER1A@ LDD 0,X get time CMPD #$FFFF check for end BEQ D@ CMPD S_TIME,S BHS C@B@ CALL NextEvnt,REGX TFR D,X BRA A@C@ TST FILT_FLG BNE E@ LDA 7,X check track CMPA TRACK BNE B@E@ CALL PrevEvnt,REGXD@ TFR X,D ENDPEK_HELP PSHS X LEAX a@,PCR CALL SetBox,REGXA@ LBSR getchar LBSR ClrBox* do command TFR A,B LEAX ED_KEYS,PCR PSHS X LDX 2,S LBSR DoCmd LEAS 2,S PULS X,PCa@ FDB 2,1,28,14,b@,0b@ FDB 10,2,c@,*+2 FDB 2,4,d@,*+2 FDB 2,5,e@,*+2 FDB 2,6,f@,*+2 FDB 2,7,g@,*+2 FDB 2,8,h@,*+2 FDB 2,9,i@,*+2 FDB 16,4,j@,*+2 FDB 16,5,k@,*+2 FDB 16,6,l@,*+2 FDB 16,7,m@,*+2 FDB 16,8,n@,*+2 FDB 5,10,o@,*+2 FDB 5,11,p@,0c@ FCC "HELP MENU",0d@ FCC "ALL TRACKS",0e@ FCC "BLOCK MENU",0f@ FCC "CLEAR BLOCK",0g@ FCC "DELETE",0h@ FCC "GO TO",0i@ FCC "INSERT",0j@ FCC "KILL NOTES",0k@ FCC "MARK BLOCK",0l@ FCC "PLAY",0m@ FCC "RECORD",0n@ FCC "SLIDE",0o@ FCC "ENTER - BEGIN EDIT",0p@ FCC "BREAK - EXIT",0ED_POS FCB 0 editing positionED_ADR FDB 0 editing address* table for keypress routines when editingED_KEYS FCB LEFT FDB EK_LEFT FCB RIGHT FDB EK_RIGHT FCB 'P FDB EK_PLAY FCB 'R FDB EK_RECRD FCB 32 FDB EK_SPACE FCB UP FDB EK_UP FCB 'I FDB EK_INSRT FCB 'D FDB EK_DEL FCB 13 FDB EK_ENTER FCB DOWN FDB EK_DOWN FCB 'M FDB BlkMark FCB 'C FDB BlkClr FCB SHFTDOWN FDB EK_SDWN FCB SHFTUP FDB EK_SUP FCB '/ FDB EK_HELP FCB '? FDB EK_HELP FCB 'B FDB EK_BLOCK FCB 'G FDB EK_GOTO FCB 'S FDB EK_SLIDE FCB 'A FDB EK_ALL FCB 'K FDB KillNote FCB 0* check horizontal position for event display cursor* ENTRY: X=pointer to MIDI code*CHKPOS PSHS Y LDD ,X get time CMPD #$FFFF end? BNE A@ CLR ED_POS,PCR BRA Z@A@ LBSR CHKFILT B=event number LEAY a@,PCR LDA B,Y get max position CMPA ED_POS,PCR compare with current BHS Z@ STA ED_POS,PCRZ@ PULS Y,PCa@ FCB 3,5,4,4 max pos for events FCB 3,3,3,3 $80-$F0* start actual modification of events* S_MPTR: pointer to MIDI event* S_POS:  edit position* LOCAL CHAR L_STR,10EdENTER PROC S_MPTR,S_POS LDD S_POS,S TSTB LBNE B@* position 0: event time LDD [S_MPTR,S] CMPD #$FFFF check for end LBEQ Z@ LEAX L_STR,S LDD [S_MPTR,S] STD ARG2 CALL CnvTime,REGX,ARG2 CALL StrPad,REGX,#9 CALL GetStr,REGX,#9 CMPD #BREAK LBEQ Z@ CALL CnvATim,REGX LDX S_MPTR,S STD ,X set new event time CMPX BUFFER1 BEQ N@ CMPD -EVNSIZE,X is the time in the BLO S@ right sequence?N@ CMPD EVNSIZE,X BHI S@ LBRA Z@S@ LEAY L_STR,S time out of order: LDB #EVNSIZE save eventT@ LDA ,X+ STA ,Y+ DECB BNE T@ CALL Delete,(S_MPTR,S) delete the event INC FILT_FLG CALL GoTo,(L_STR,S) find where it goes CLR FILT_FLG TFR D,X CALL Insert,REGX insert the event LEAY L_STR,S LDB #EVNSIZEU@ LDA ,Y+ STA ,X+ DECB BNE U@*        LDA     YPOS*        STA     L_CNT,S LBSR CLS CALL DspPage,MEM_LINE LDX MEM_LINE IFEQ 1 ******V@ TST L_CNT,S BEQ W@ LBSR EK_DOWN DEC L_CNT,S BRA V@W@ ENDC  ****** STX S.X,S LBRA Z@B@ CMPB #1 BNE C@* position 1: event type toggle LDX S_MPTR,SI@ LDA 2,X ADDA #$10 CMPA #$80 BHI A@ ORA #$90A@ STA 2,X LBSR CHKFILT TSTA BNE I@ LBRA Z@C@ CMPB #2 LBNE D@* position 2: event value LDX S_MPTR,S LDA 2,X CMPA #$F0 BLO L@ LBSR EdSysID LBRA Z@L@ CMPA #$E0 check for pitch wheel BLO E@ LDD #5 number of editable digits STD ARG2 LDB 3,X get LSB value LSLB LDA 4,X get MSB value LSRA RORB BRA G@E@ CMPA #$9F check for note on/off BHI K@ LDA 3,X get pitch PSHS X LEAX L_STR+2,S LBSR CNVPITCH CALL GetStr,REGX,#3 LBSR CNVNOTE PULS X STA 3,X LBRA Z@K@ LDD #3 STD ARG2 CLRA LDB 3,XG@ LEAX L_STR,S LBSR BINDEC CALL GetStr,REGX,ARG2 LBSR atoi LDX S_MPTR,S PSHS A LDA 2,X ANDA #$F0 CMPA #$E0 PULS A BNE H@ LSLB ROLA LSRB STB 3,X STA 4,X LBRA Z@H@ STB 3,X LBRA Z@D@ CMPB #3 LBNE F@* position 3: channel (or data) LDX S_MPTR,S LDB 2,X get status byte CMPB #$F0 check for system msg BHS M@ ANDB #$0F keep channel # INCB CLRA LEAX L_STR,S LBSR BINDEC CALL StrPad,REGX,#2 CALL GetStr,REGX,#2 LBSR atoi CMPD #0 BHI P@Q@ LBSR SndErr LBRA Z@P@ CMPD #16 BHI Q@ DECB ANDB #$0F LDX S_MPTR,S LDA 2,X ANDA #$F0 PSHS A ORB ,S+ STB 2,X LBRA Z@M@ CMPB #$F1 tempo or clock? BHI O@ LDD 3,X LEAX L_STR,S LBSR BINDEC CALL StrPad,REGX,#5 CALL GetStr,REGX,#5 LBSR atoi LDX S_MPTR,S STD 3,X LBSR CPCalc calculate CPERIOD STD 5,X (just in case!) LBRA Z@O@ CMPB #$F3 link or message? BHI R@ CALL EdMsg,REGX LBRA Z@R@ CMPB #$F5 bytes? LBNE Z@ CALL EdBytes,REGX LBRA Z@F@ CMPB #4 BNE J@* position 4 LDX S_MPTR,S CLRA LDB 4,X LEAX L_STR,S LBSR BINDEC CALL StrPad,REGX,#3 CALL GetStr,REGX,#3 LBSR atoi LDX S_MPTR,S STB 4,X BRA Z@J@ CMPB #5 BNE Z@* position 5 (note length) LEAX L_STR,S STX ARG1 LDX S_MPTR,S CALL NoteLen,ARG1 LEAX L_STR,S CALL StrPad,REGX,#5 CALL GetStr,REGX,#5 CMPD #BREAK BEQ Z@ CALL CnvNotLn,REGX LDX S_MPTR,S STD 5,X BRA Z@X@ NOP  error extZ@ ENDP* edit the data part of a system message event*EdMsg PROC S_PTR LEAX MESSAGES,PCR LDY S_PTR,S LDB 3,Y get message # LDA #16 bytes/message MUL LEAX D,X CALL StrPad,REGX,#14 CALL GetStr,REGX,#14 LDA 2,Y is this a LINK? CMPA #$F2 no trim if not BNE Z@ CALL StrTrim,REGXZ@ ENDP* edit a system event byte (just id byte)* assigns a new message # to a message event* ENTRY: X=pointer to event*EdSysID PROC LDA 2,X ANDA #$0F INCA CMPA #MAXSYS BLS A@ CLRAA@ CMPA #2 BLO B@ CMPA #3 BHI B@ LEAY MESSAGES,PCR find an empty message CLRBC@ TST ,Y BEQ D@ LEAY 16,Y INCB CMPB #16 BLO C@D@ STB 3,X put message # in eventB@ ORA #$F0 STA 2,X ENDP* memory positions (addresses) of each display line*MEM_LINE RMB 32,0* display event information in English* S_MPTR points to event in MIDI buffer* returns 0 if nothing displayed* returns 1 if event displayed* LOCAL L_FILTNote PROC S_MPTR LDX S_MPTR,S* check filterA@ LDD 0,X CMPD #$FFFF BEQ C@ LBSR CHKFILT displayable CMPB #8 LBHI X@ TSTA LBNE X@ STD L_FILT,S* check block markers, set invert flag if neededC@ LDD BLK_STRT,PCR CMPD #$FFFF BEQ D@ CMPD [S_MPTR,S] BHI D@ LDD BLK_END,PCR CMPD #$FFFF BEQ D@ CMPD [S_MPTR,S] BLO D@ LDA #$FF STA TINVERT* update MEM_LINED@ LDB YPOS,PCR LSLB LEAY MEM_LINE,PCR STX B,Y* display time LDA NOTEPOS,PCR STA XPOS,PCR LBSR MOVE LBSR ERALIN LDD 0,X get time CMPD #$FFFF BNE B@ check for ending LEAX j@,PCR LBSR PUTS BRA Y@B@ LDX [S_MPTR,S] CALL PrtTime,REGX* lookup address of display routine and do it LDX S_MPTR,S LDD L_FILT,S LEAU a@,PCR LSLB  convert event # LSLB  to offset LEAU B,U LDY ,U++ LDU ,U JSR ,U BRA Y@X@ CLRA CLRB BRA Z@Y@ LDD #1Z@ CLR TINVERT ENDP** table of data routine addresses (absolute)a@ FDB b@,DSPNOFF Note off FDB c@,DSPNON Note on FDB d@,DSPKPRE Key pressure FDB e@,DSPCTRL Control change FDB f@,DSPEVN1 Program change FDB g@,DSPEVN1 Channel pressure FDB h@,DSPPWHL Pitch wheel FDB i@,DSPSYS System event*b@ FCC "NF=",0 note offc@ FCC "NO=",0 note on FCC " V=",0d@ FCC "KP=",0 key pressure FCC " P=",0e@ FCC "CC=",0 control change FCC " D=",0f@ FCC "PC=",0 program changeg@ FCC "CP=",0 channel pressureh@ FCC "PW=",0 pitch wheeli@ FCC "SE=",0 system events*j@ FCC "END OF BUFFER",0* display a system event* ENTRY: X=pointer to MIDI event*        Y=pointer to text* FORMAT: time,status byte (channel=ID)*        data (2 bytes) such as metronome tempo*        raw data (2 bytes) such as CPERIOD or ptr.*        and track #* ID byte assignments:*        0=TEMPO 1=CLOCK 2=LINK 3=MESSG 4=PAUSE*        5=BYTES* LOCAL CHAR L_STR,6DSPSYS PROC* display identifier LBSR DSPE1 LDB 2,X get ID ANDB #$0F CMPB #MAXSYS check for maximum BHI A@ supported type # LEAX a@,PCR LDA #5 MUL ABX BRA B@A@ LEAX b@,PCRB@ LBSR PUTS* now display data portion LDA NOTEPOS+3,PCR STA XPOS LBSR MOVE LDX S.X,S LDA 2,X check event type CMPA #$F1 tempo or clock? BHI C@ LDD 3,X get data word LBSR pBINDEC BRA Z@C@ CMPA #$F3 link or messg? BHI D@ LBSR DspMESSG BRA Z@D@ CMPA #$F5 bytes? BNE E@ LBSR DspBYTESE@ CMPA #$F6 wait for?Z@ ENDP*a@ FCC "TMPO",0 FCC "CLCK",0 FCC "LINK",0 FCC "MESG",0 FCC "PAUS",0 FCC "BYTE",0 FCC "WTFR",0b@ FCC "UNDF",0* convert number of bytes in B pointed to by Y* to a hex string pointed to by X. $FF is an end* marker for the byte array.* LOCAL L_CNTCnvBytes PROC STB L_CNT,SA@ LDA ,Y+ get byte CMPA #$FF quit if end marker BEQ B@ LBSR BINHEX LEAX 2,X LDA #32 insert a space STA ,X+ DEC L_CNT,S BNE A@B@ CLR ,X end of string marker ENDP* edit a BYTES system event. ENTRY: X points to event* LOCAL CHAR L_PTR,13EdBytes PROC S_PTR LEAY 3,X STY ARG2 LEAX L_PTR,S CALL CnvBytes,#4,ARG2,REGX CALL StrPad,REGX,#12 CALL GetStr,REGX,#12 STY ARG2 CALL HexSBin,REGX,ARG2,#4 ENDP* display the MIDI bytes of a BYTES system event* ENTRY: X points to event* LOCAL CHAR L_PTR,13DspBYTES PROC LEAY 3,X point to bytes STY ARG2 LEAX L_PTR,S CALL CnvBytes,#4,ARG2,REGX LBSR PUTS ENDP* display a message for an event/link event* ENTRY: X points to event*DspMESSG PSHS X LDA 3,X get message # LDB #16 MUL LEAX MESSAGES,PCR LEAX D,X LBSR PUTS PULS X,PC* display note off* ENTRY: X=pointer to MIDI event*        Y=pointer to explanatory text*DSPNOFF LBSR DSPE1 LDA 3,X get MIDI pitch LBSR pCNVPTCH LBRA DSPCHAN* display note on* ENTRY: X=pointer to MIDI event*        Y=pointer to explanatory text*DSPNON PSHS X LBSR DSPE1 LDA 3,X get MIDI pitch LBSR pCNVPTCH LBSR DSPCHAN LBSR DSPE3* display length of note LDA NOTEPOS+5,PCR STA XPOS,PCR LBSR MOVE CALL NoteLen,#0 PULS X,PC* display key pressure* ENTRY: X=pointer to MIDI event*        Y=pointer to explanatory text*DSPKPRE LBSR DSPE1 LDA 3,X get MIDI pitch LBSR pCNVPTCH LBSR DSPCHAN LBRA DSPE3* display control change* ENTRY: X=pointer to MIDI event*        Y=pointer to explanatory text*DSPCTRL PSHS X LBSR DSPE1 CLRA LDB 3,X get MIDI pitch LBSR pBINDEC LBSR DSPCHAN LBSR DSPE3 PULS X,PC* display pitch wheel event* ENTRY: X points to the MIDI event*        Y points to the text*DSPPWHL LBSR DSPE1 LDB 3,X get LSB value LSLB LDA 4,X get MSB value LSRA RORB LBSR pBINDEC LBRA DSPCHAN* display an event that has only a single data byte* ENTRY: X points to the MIDI event*        Y points to the text*DSPEVN1 PSHS X LBSR DSPE1 CLRA LDB 3,X LBSR pBINDEC LDX 0,S LBSR DSPCHAN PULS X,PC* display the first item text of an event* ENTRY: Y points to the text* EXIT:  Y points to start of next string*DSPE1 PSHS X LDA NOTEPOS+1,PCR STA XPOS,PCR LBSR MOVE TFR Y,X LBSR PUTS TFR X,Y PULS X,PC* display the channel number* ENTRY: X points to the MIDI event*DSPCHAN PSHS X LDA NOTEPOS+3,PCR STA XPOS,PCR LBSR MOVE LDB 2,X get status byte ANDB #$0F keep channel # INCB CLRA LBSR pBINDEC PULS X,PC* display 3rd item in an event* ENTRY: X=pointer to MIDI event*        Y=pointer to text* EXIT:  Y=points to next string*DSPE3 PSHS X LDA NOTEPOS+4,PCR SUBA #3 STA XPOS,PCR LBSR MOVE EXG Y,X LBSR PUTS EXG X,Y CLRA LDB 4,X get (velocity) LBSR pBINDEC PULS X,PC* Play a single note; S_MPTR points to an event* LOCAL L_CNTPlayNote PROC S_MPTR LDX S_MPTR,S LEAX 2,X LDA #3 STA L_CNT,SA@ CLR MIDISTAT LDA ,X+ CMPA #$F0 ignore system events BHS Z@ CMPA #$C0 check status byte BLO F@ to determine number CMPA #$DF of bytes to send BHI F@ DEC L_CNT,SF@ LBSR MIDI_OUT CLRBB@ DECB BNE B@ DEC L_CNT,S BNE A@ LDX S_MPTR,S LDA 2,X did we play a note on? CMPA #$9F BHI Z@* note length delay LDD #$5000C@ SUBD #1 NOP BNE C@* note off LEAX 2,X LDA ,X+ LBSR MIDI_OUT LDB #2D@ CLRAE@ DECA BNE E@ LDA ,X+ CMPB #1 BNE G@ CLRAG@ PSHS B LBSR MIDI_OUT PULS B DECB BNE D@Z@ ENDP* print converted MIDI pitch* input in A* LOCAL CHAR L_PTR,4pCNVPTCH PROC LEAX L_PTR,S LBSR CNVPITCH LBSR PUTS ENDP* Convert MIDI pitch to keyboard (ASCII) representation* Input in register A* ASCII string written to memory pointed to by X*CNVPITCH PSHS D,X,Y CLRBA@ INCB SUBA #12 count the # of octaves BCC A@B@ ADDA #12 DECB PSHS A multiply note # by 3 LSLA ADDA ,S+ PSHS B LDB KEY CMPB #'S BEQ K@ LEAY b@,PCR BRA L@K@ LEAY a@,PCRL@ LEAY A,Y LDA ,Y+ STA ,X+ LDA ,Y BEQ C@ STA ,X+C@ PULS A ADDA #'0 STA ,X+Z@ CLR ,X PULS D,X,Y,PCa@ FCC "C",0,0 FCC "C#",0 FCC "D",0,0 FCC "D#",0 FCC "E",0,0 FCC "F",0,0 FCC "F#",0 FCC "G",0,0 FCC "G#",0 FCC "A",0,0 FCC "A#",0 FCC "B",0,0*b@ FCC "C",0,0 FCC "D-",0 FCC "D",0,0 FCC "E-",0 FCC "E",0,0 FCC "F",0,0 FCC "G-",0 FCC "G",0,0 FCC "A-",0 FCC "A",0,0 FCC "B-",0 FCC "B",0,0** convert ASCII pitch representation to binary* ENTRY: X=pointer to ASCII string* EXIT:  A=binary equivalent*CNVNOTE PSHS X,Y LDA ,X+ CMPA #'A check for valid entry BLO G@ CMPA #'G BHI G@ LDB ,X CMPB #'- BNE I@ LEAY b@,PCR LDB #1 BRA D@I@ LEAY a@,PCR CLRB* find entry in tableD@ CMPA ,Y BEQ E@ INCB LEAY 3,Y BRA D@E@ LDA ,X+ CMPA #32 BEQ E@ CMPA #'#  check for sharp BNE F@ INCB LDA ,X BRA M@F@ CMPA #'- check for flat BNE M@ DECB LDA ,XM@ PSHS B SUBA #'0 convert octave to binary LDB #12 MUL ADDB ,S+ TFR B,A BRA H@G@ LBSR SndErr LDA #64H@ PULS X,Y,PC* check the MIDI filter and report* disabled if FILT_FLG>0* track not checked if TRAK_FLG>0* ENTRY: X=MIDI event pointer* EXIT:  A=0 if not filtered out*        A>0 if event is filtered out*        A=$FF if error (not a status byte)*        B=event number (1-7)*CHKFILT PSHS X LDA 2,X get status byte TSTA BPL X@ TST FILT_FLG BNE A@ TST TRAK_FLG BNE A@ LDB 7,X get track # CMPB TRACK BNE X@A@ LEAX a@,PCR LSRA LSRA LSRA LSRA ANDA #7 TFR A,B LDA A,X ANDA MFILTER,PCR TST FILT_FLG BEQ Z@ CLRA BRA Z@X@ LDD #$FFFFZ@ PULS X,PCa@ FCB 1,2,4,8,$10,$20,$40,$80* return pointer to next MIDI event* S_MPTR: pointer to current MIDI event*NextEvnt PROC S_MPTR LDY #EVNSIZE LDX S_MPTR,SA@ PSHS X check for 1 before LDD BUFFER1 buffer start SUBD ,S++ CMPD #EVNSIZE BEQ B@ LDD ,X check for end CMPD #$FFFF BEQ Y@ if advancingB@ LEAX EVNSIZE,X LDD ,X CMPD #$FFFF check for end BEQ D@ LDA 2,X LDB 7,X LBSR CHKFILT TSTA BEQ D@ CMPX BUFFER1 BHI B@ check for start BRA Y@D@ TFR X,D BRA Z@Y@ LDD S_MPTR,SZ@ ENDP* return pointer to previous MIDI event* S_MPTR: pointer to current MIDI event*PrevEvnt PROC S_MPTR LDY #-EVNSIZE LDX S_MPTR,S CMPX BUFFER1 check for start BEQ Y@ if backing upB@ LEAX -EVNSIZE,X LDD ,X CMPD #$FFFF check for end BEQ D@ LDA 2,X LDB 7,X LBSR CHKFILT TSTA BEQ D@ CMPX BUFFER1 BHI B@ check for start BRA Y@D@ TFR X,D BRA Z@Y@ LDD S_MPTR,SZ@ ENDP* display page of events starting at cursor position* LOCAL L_CURSDspPage PROC S_MPTR LDD CURSADR save current STD L_CURS,S cursor position CLR XPOS,PCR LDX S_MPTR,SA@ LBSR MOVE CALL Note,REGX CMPD #0 make sure an event BEQ B@ was displayed LDD 0,X check for end of music CMPD #$FFFF BEQ C@ LDA YPOS check for end of screen INCA CMPA #16 BEQ Z@ STA YPOSB@ CALL NextEvnt,REGX TFR D,X BRA A@C@ LDA YPOS if end of music found INCA  make sure bottom of CMPA #16 display is blank BEQ Z@ STA YPOS LBSR MOVE LBSR ERALIN BRA C@Z@ LDD L_CURS,S restore cursor STD CURSADR LBSR GETPOS ENDP* delete an event at given pointer* also delete a message if a system message*Delete PROC S_MPTR LDX S_MPTR,S LDD ,X check for end CMPD #$FFFF BEQ Z@ LDA 2,X check for message event CMPA #$F2 BLO A@ CMPA #$F3 BHI A@ LDA 3,X get message # LDB #16 MUL LEAY MESSAGES,PCR CLR D,Y delete messageA@ CALL FindEnd,BUFFER2 STD ARG2 move both buffers down LDD S_MPTR,S STD ARG3 ADDD #EVNSIZE STD ARG1 CALL MoveDown,ARG1,ARG2,ARG3 LDD BUF1END SUBD #EVNSIZE STD BUF1END LDD BUFFER2 SUBD #EVNSIZE STD BUFFER2Z@ ENDP* insert (duplicate) an event at given pointer* the pointers for BUF1END and BUFFER2 are adjusted* LOCAL L_TMPInsert PROC S_PTR* make sure there is enough room CALL FindEnd,BUFFER2 STD L_TMP,S LDD BUF2END SUBD L_TMP,S CMPD #EVNSIZE*2 BLO Z@ LDD S_PTR,S STD ARG1 LDD L_TMP,S STD ARG2 ADDD #EVNSIZE STD ARG3 CALL MoveUp,ARG1,ARG2,ARG3 LDD BUF1END ADDD #EVNSIZE STD BUF1END LDD BUFFER2 ADDD #EVNSIZE STD BUFFER2* if we're at an end of music marker, then* make it a note event LDX S_PTR,S LDD ,X CMPD #$FFFF BNE Z@ CMPX BUFFER1 set time to 0 if BNE A@ at the start of LDD #0 the buffer BRA B@ ELSEA@ LDD -EVNSIZE,X get previous timeB@ STD 0,X set event time LDD #$9040 STD 2,X set status+pitch STB 4,X set velocity LDD TIMEBASE set length STD 5,X LDA TRACK set track STA 7,XZ@ ENDP* make ascii note length: X points to a note event* if S_STR=0 then print it,* else store letters in S_STR* LOCAL L_TIK,L_PTR CHAR L_STR,7NoteLen PROC S_PTR LDY S_PTR,S decide where ascii BNE C@ letters will be put LEAY L_STR,SC@ STY L_PTR,S LDX 5,X get note length CALL Divide,REGX,TIMEBASE STX L_TIK,S remainder is # ticks LDX L_PTR,S LBSR BINDEC convert # beatsD@ TST ,X+ look for end of string BNE D@ LDA #': STA -1,X LDD L_TIK,S LBSR BINDEC convert # ticks LDX L_PTR,S CLRBA@ INCB TST ,X+ Look for end of string BNE A@ LDX L_PTR,S CMPB #6 BLS B@ LDA #'+ CLRB STD 4,XB@ LDD S_PTR,S are we supposed to BNE Z@ print this? LBSR PUTSZ@ ENDP* Print time as ASCII string (bar/beat:tick format)* S_PTR points to time (event time or note length)* LOCAL CHAR L_STR,10PrtTime PROC S_TIM LDX S_TIM,S STX ARG2 LEAX L_STR,S CALL CnvTime,REGX,ARG2 LBSR PUTS ENDP* convert time to ASCII string (bar/beat:tick)* pointer to string storage space (S_PTR) required* LOCAL L_TK,L_BTCnvTime PROC S_PTR,S_TIM LDX S_TIM,S CALL Divide,REGX,TIMEBASE STX L_TK,S put ticks in L_TK STD ARG1 CLRA LDB BAR STD ARG2 CALL Divide,ARG1,ARG2 STX L_BT,S put beats in L_BT LDX S_PTR,S INCB  bar # starts with 1 LBSR BINDECA@ TST ,X+ move X to point to BNE A@ first zero byte LDA #'/ STA -1,X LDD L_BT,SC@ INCB  beat # starts with 1 LBSR BINDECB@ TST ,X+ BNE B@ LDA #': STA -1,X LDD L_TK,S LBSR BINDEC ENDP* convert ASCII note length string (beat:tick)* alternate formats are "beat" and ":tick"* value returned in D* LOCAL L_ACUMCnvNotLn PROC S_PTR CLRA CLRB STD L_ACUM,SA@ LDX S_PTR,S LBSR atoi STD ARG1 BEQ B@ CALL Mult,ARG1,TIMEBASE ADDD L_ACUM,S STD L_ACUM,S* look for ":"B@ LDX S_PTR,SC@ LDA ,X+ BEQ Z@ CMPA #': BNE C@ LBSR atoi ADDD L_ACUM,S STD L_ACUM,SZ@ LDD L_ACUM,S ENDP* convert ASCII time string (measure/beat:tick)* value returned in D* LOCAL L_ACUMCnvATim PROC S_PTR CLRA CLRB STD L_ACUM,S* look for "/" in time LDY S_PTR,SA@ LDA ,Y+ BEQ B@ CMPA #'/ BNE A@ LDX S_PTR,S LBSR atoi TSTB BEQ D@ SUBB #1 bar # starts with 1D@ STY S_PTR,S STD ARG1 CALL Mult,ARG1,MEASURE STD L_ACUM,SB@ LDX S_PTR,S LBSR atoi TSTB BEQ E@ SUBB #1 beat # starts with 1E@ STD ARG1 CALL Mult,ARG1,TIMEBASE ADDD L_ACUM,S STD L_ACUM,S* look for ":" LDX S_PTR,SC@ LDA ,X+ BEQ Z@ CMPA #': BNE C@ LBSR atoi ADDD L_ACUM,S STD L_ACUM,SZ@ LDD L_ACUM,S ENDP* set block markers* ENTRY: X points to current MIDI event* LOCAL L_CURSBlkMark PROC LDD 0,X check for end marker CMPD #$FFFF BEQ X@D@ LDY BLK_STRT CMPY #$FFFF BNE A@ STD BLK_STRT BRA B@A@ LDY BLK_END CMPY #$FFFF BNE X@ STD BLK_ENDB@ LDD BLK_STRT CMPD BLK_END BLO C@ LDY BLK_END STD BLK_END STY BLK_STRTC@ LDD CURSADR STD L_CURS,S CLR XPOS,PCR CLR YPOS,PCR LBSR MOVE CALL DspPage,MEM_LINE LDD L_CURS,S STD CURSADR LBSR GETPOS LBSR SndOK BRA Z@X@ LBSR SndErrZ@ ENDP* clear block markers* LOCAL L_CURSBlkClr PROC LDD #$FFFF STD BLK_STRT STD BLK_END LDD CURSADR STD L_CURS,S CLR XPOS CLR YPOS LBSR MOVE CALL DspPage,MEM_LINE LDD L_CURS,S STD CURSADR LBSR GETPOS ENDP* end of file: EDIT/TXT