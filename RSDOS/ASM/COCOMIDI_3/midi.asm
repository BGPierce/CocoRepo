* MIDI/TXT* the MIDI play and record routines* for CM3* (C) 1988 by Lester Hands* macro for outputting MIDI data in register A* used only in situations where speed is critical*MOUT MACRO TSTA  check for a status byte BPL A@ CMPA #$F0 BHS A@ CMPA MIDISTAT BEQ B@ STA MIDISTATA@ LDB [MSTAT] make sure ACIA BITB #2 is ready to accept data BEQ A@ STA [MDATA]B@ ENDM* set PIAs for the high speed IRQ (HSYNC)* set variables for IRQplay*SetHIRQ LDA #$34 STA $FF03 INCA STA $FF01 LDD #1 STD CPCOUNT STB METCOUNT LDA #1 STA TICKS CLR IRQACTIV LBSR TVON RTS* set PIAs for the slow speed IRQ*SetSIRQ LDA #$34 STA $FF01 INCA STA $FF03 RTS* ask for starting time for play or record* return -1 if error*StrtAt PSHS X LEAX a@,PCR CALL SetBox,REGX CALL BoxInp,REGX LBSR ClrBox CMPB #BREAK BEQ X@* make sure user has not entered a tick (:xx) value* since playback must start on a whole beat LEAX c@,PCRB@ LDA ,X+ BEQ C@ CMPA #': BNE B@ LDA #32 pad from : to endE@ STA -1,X of string with spaces TST ,X+ BNE E@C@ LEAX c@,PCR CALL CnvATim,REGX BRA Z@X@ LDD #-1Z@ PULS X,PC*a@ FDB 6,5,20,5,*+4,b@ FDB 2,2,*+4,0 FCC "START AT:",0b@ FDB 12,2,*+6,0,0c@ FCC "1/1   ",0 LOCAL L_TIMPLAY PROC CLRA  don't ask for start CLRB  time if in slave mode TST SLAVE BNE D@ LBSR StrtAt CMPD #-1 BEQ Z@D@ STD L_TIM,S CLRA CLRB STD LINKPTRA@ LDB #1 disable the filter STB FILT_FLG,PCR CALL GoTo,(L_TIM,S) STD ARG1 LDD L_TIM,S STD ARG2 CALL Play,ARG1,ARG2 CLR FILT_FLG,PCR enable filter LDD LINKPTR BEQ Z@ CALL LoadLink,LINKPTR CMPD #$FFFF check for error BEQ Z@ CLRA CLRB BRA D@Z@ CLRA CLRB ENDP* play recorded MIDI data* until keypress or end of recording* returns address of current event in register D* LOCAL L_POSPlay PROC S_MPTR,S_CLK LBSR WAIT LBSR ChkSOLO TST CLOKFLAG BEQ M@ CALL SendSPP,(S_CLK,S)M@ LDD S_CLK,S STD CLOCK reset clock STD CLOCKslv CLR MIDISTAT LDX S_MPTR,S reset buffer pointer STX PLAYPTR LDA #$FF STA DONE CLR STOP LDA #1 STA SYNCFLAG LBSR ClrPNB ORCC #$50 disable interrupts TST SLAVE BNE E@ LEAX IRQmast,PCR LEAY FIRQmast,PCR BRA O@E@ LEAX IRQslave,PCR LEAY FIRQslav,PCRO@ STX $010D set up new IRQ vector STY $0110 LBSR SetHIRQ CLR $FF02 prepare for fast read TST SLAVE BEQ J@ LEAX PLAYBOXS,PCR BRA K@J@ LEAX PLAYBOXM,PCRK@ CALL SetBox,REGX CALL SetBarBt,CLOCK LBSR SetSpd TST SLAVE BEQ D@ CLR POSNFLAG CLR SYNCFLAG LDA #3 initialize ACIA STA [MSTAT] master reset LDA #$95 set 8 bits, no parity STA [MSTAT] enable receiv LBSR MPI3 enable MPI ANDCC #$BF enable FIRQH@ LDA $FF00 wait until a song pos. ANDA #$7F ptr. or start signal CMPA #$7F has been received. BNE B@ TST POSNFLAG BEQ H@ CALL GoTo,SNGPOSPT STD PLAYPTR INC SYNCFLAG CALL SetBarBt,SNGPOSPTD@ ANDCC #$AF enable interruptsA@ TST STOP BNE B@F@ LDA KEYINP check for keypressG@ ANDA #$7F CMPA #$7F*        BEQ     L@*        LDA     SLAVE*        LBSR    QuickIn*        CMPA    #32 BNE B@*        LBSR    PlayPAUSL@ TST DONE check for end of recording BNE A@ LDX #PLNTBUFR check for all notes offC@ LDD ,X BNE A@ LEAX 4,X CMPX #PLNTBUFE BNE C@B@ ORCC #$50 disable interrupts LDA #$15 STA [MSTAT] LBSR ALLOFFN@ TST SLAVE BEQ I@ LDA #1 STA SLAVE STA SYNCFLAGI@ LEAX NEWIRQ,PCR STX $010D LBSR SetSIRQ LBSR MPI4 ANDCC #$EF enable IRQ LBSR ChkSOLO LBSR WAIT wait for key offZ@ LBSR ClrBox LDD PLAYPTR ENDPPLAYBOXS FDB 6,5,20,8,*+4,0 FDB 5,2,c@,*+2 FDB 7,4,e@,*+2 FDB 3,6,d@,0c@ FCC "PLAYING...",0e@ FCC "001/01",0d@ FCC "AS:  CL:  IN:",0PLAYBOXM FDB 6,5,20,8,*+4,0 FDB 5,2,b@,*+2 FDB 7,4,c@,*+2 FDB 8,6,d@,0b@ FCC "PLAYING...",0c@ FCC "001/01",0d@ FCC "IN:",0* check the SOLO bit of the TFLAGS* if one is set, then flip all top 2 bits*ChkSOLO PSHS X LDX #TFLAGS LDB #10 number of tracksA@ LDA ,X+ BITA #$40 check SOLO bit BNE B@ DECB BNE A@ PULS X,PCB@ LDX #TFLAGS LDB #10 number of tracks PSHS BC@ LDA ,X LSLA  flip top 2 bits RORB LSLA RORB ANDB #$C0 PSHS B LDA ,X ANDA #$3F ORA ,S+ STA ,X+ DEC ,S BNE C@ PULS B,X,PC* FIRQ routine that is called when the ACIA* receives a MIDI byte (slave version)*FIRQslav PSHS D LDA [MDATA] get MIDI byte* check for clock message CMPA #$F8 clock? BNE B@ COM $0571 Y=11, X=17 on screen TST <SLAVE ignore clock if start LBPL Z@ or cont. not yet received LDD <CLOCKslv ADDD #4 BCC A@ CLR <DONEA@ STD <CLOCKslv STD <CLOCK LDD <CPCslave LSRA RORB LSRA RORB STD <CPERIOD LDD #1 STD <CPCOUNT STB TICKslav CLRB STD <CPCslave BRA Z@* process A0-EF eventsB@ CMPA #$F0 BHS D@ COM $0576 Y=11, X=22 on screen TST <SLAVE BPL Z@ no input until startedC@ STA [MBUFPTR] INC <MBUFPTR+1 BRA Z@* check for song position pointer messageD@ CMPA #$F2 BNE F@ LDB #2E@ LDA [MSTAT] BITA #1 BEQ E@ LDA [MDATA] PSHS A DECB BNE E@ PULS D LSLB LSRA RORB LSLB  multiply by 24 ROLA LSLB ROLA LSLB ROLA PSHS D LSLB ROLA ADDD ,S++ STD <SNGPOSPT INC <POSNFLAG BRA Z@F@ CMPA #$F8 BLO C@* check for start clock message CMPA #$FA start? BNE G@ INC <POSNFLAG CLRA CLRB BRA H@* check for continue clock messageG@ CMPA #$FB continue? BNE I@ LDD <SNGPOSPTH@ STD <CLOCK STD <CLOCKslv LDA #$80 set slave flag to STA <SLAVE indicate ready to play BRA Z@* check for stop clock messageI@ CMPA #$FC BNE J@ TST <SLAVE ignore if not started BPL Z@ LDA #1 STA <STOP STA <SLAVE* check for active sensingJ@ CMPA #$FE BNE Z@ COM $056C Y=11, X=12 on screenZ@ TST $FF22 acknowlege interrupt PULS D RTI* FIRQ routine that is called when the ACIA* receives a MIDI byte (master version)*FIRQmast PSHS A LDA [MSTAT] check for errors ANDA #$24 BNE Z@ LDA [MDATA] get MIDI byte CMPA #$F8 ignore all real time BHS Z@ messages STA [MBUFPTR] INC MBUFPTR+1 COM $0571 Y=11, X=17 on screenZ@ PULS A TST $FF22 acknowlege interrupt RTI* kill all notes (note off messages on all channels)* useful for synths that don't implement the "all* notes off" controller* LOCAL L_NOT,L_CHNKillNote PROC LDA #$90 STA L_CHN,SA@ LDA #0 STA L_NOT,SB@ LDA L_CHN,S LBSR MIDI_OUT LDA L_NOT,S LBSR MIDI_OUT CLRA LBSR MIDI_OUT CLRAC@ DECA  delay loop BNE C@ INC L_NOT,S LDA L_NOT,S CMPA #$80 BLO B@ INC L_CHN,S LDA L_CHN,S CMPA #$A0 BLO A@ ENDP* send all notes off command to MIDI* LOCAL L_CNTALLOFF PROC* first send note off messages for all notes in* the PLNTBUFR LDX #PLNTBUFRE@ LDD ,X++ BEQ F@ LDA ,X LBSR MIDI_OUT LDA 1,X LBSR MIDI_OUT CLRA LBSR MIDI_OUTF@ LEAX 2,X CMPX #PLNTBUFE BNE E@ LDB #15 STB L_CNT,SA@ LEAX ALLOFFDT,PCRD@ LDA ,X+ set channel CMPA #$FF check for end BEQ C@ BPL B@ ORA L_CNT,S status bytesB@ LBSR MIDI_OUT have channel fixed BRA D@C@ DEC L_CNT,S BPL A@* send clock end if clock is enabled TST CLOKFLAG BEQ Z@ LDA #$FC send clock end LBSR MIDI_OUTZ@ CLRA CLRB ENDP*ALLOFFDT FCB $B0,$7B,$40 MIDI all notes off FCB $B0,$79,$00 reset all controllers FCB $FF,0,0,0,0 end of data markerIRQslave INC <CPCslave+1 BNE IRQmast INC <CPCslave* Timing interrupt.* Keeps track of the MIDI clock and system clock.* The first part is re-entrant, allowing timing* to be updated and music to be played simultaneously.* The non-reentrant part plays music.** update the CPCOUNT: this is the number of HSYNC* interrupts needed to make 1 system "tick"IRQmast LDD <CPCOUNT SUBD #1 BEQ M@ STD <CPCOUNTZ@ LDA $FF00 STA <KEYINP RTIM@ LDD <CPERIOD STD <CPCOUNT INC <CLOCK+1 BNE V@ INC <CLOCK BNE V@ CLR <DONEV@ INC <TICKS TST <IRQACTIV BNE Z@* start of non-reentrant part of interrupt INC <IRQACTIV ANDCC #$EF enable IRQ* check if we're ready for a MIDI clockL@ TST <SLAVE BEQ Y@ TST <TICKslav BEQ J@ CLR <TICKslav BRA K@Y@ LDA <TICKS SUBA #4 4 ticks=1 MIDI clock BMI J@ STA <TICKS TST <CLOKFLAG BEQ K@ LDA #$F8 MOUT  MIDI output* if a MIDI clock was sent, see if metronome* should be clicked (24 MIDI clocks/beat)K@ DEC <METCOUNT BNE L@* update the bar/beat display every beat* this routine works directly with data on the screen* to save time LDX #$052D Y=9, X=13 on screen LDA <BEAT_CNT INCA  CMPA <BAR BHI c@ STA <BEAT_CNT LDD 4,X INCB  CMPB #$7A BLO b@ LDB #$70 INCA b@ STD 4,X BRA e@c@ LDD #$7071 beat overflow STD 4,X set beat # to 01 LDD 1,X increment bar # INCB  CMPB #$7A BNE d@ LDB #$70 INCA  CMPA #$7A BNE d@ LDA #$70 INC ,Xd@ STD 1,X LDA #1 STA BEAT_CNT* make the click for the metronomee@ LDA a@ ORA #3 STA $FF20 COM a@ LDA <METRONOM STA <METCOUNT BRA L@* now do the actual work of playing musicJ@ TST <SYNCFLAG abort if the sync BNE T@ flag is clear (slave CLR <IRQACTIV mode, waiting for LBRA Z@ synchronization)* go through the storage area, compare times* when time matches current, send note offT@ LDX #PLNTBUFRG@ LDD ,X skip if empty BEQ H@ CMPD <CLOCK BHI H@ LDA 2,X get status byte MOUT  MIDI output LDA 3,X get pitch MOUT  MIDI output CLRA  zero velocity MOUT  MIDI output CLRB STD 0,X release for next noteH@ LEAX 4,X move to next one CMPX #PLNTBUFE at the end yet? BLO G@* now examine the current event to be played* and see if the time is right LDX <PLAYPTRA@ LDD ,X get event clock CMPD #$FFFF BNE B@ check for end CLR <DONEE@ STX <PLAYPTR update pointer CLR <IRQACTIV LBRA Z@B@ CMPD <CLOCK compare with actual clock BHI E@* check mute flags before trying to play anything LDA 7,X get track # LDU #TFLAGS check for mute flag TST A,U LBPL D@* play first two MIDI bytes (minimum number)* if not a system event LDA 2,X get first byte CMPA #$F0 check for system event LBHS C@ MOUT  MIDI output LDA 3,X get second byte MOUT  MIDI output* process notes if present LDA 2,X CMPA #$9F BHI O@ LDA 4,X get velocity MOUT LDU #PLNTBUFRF@ LDD ,U look for a place BEQ I@ in storage area LEAU 4,U CMPU #PLNTBUFE BLO F@ INC $05FF indicate overflow BRA D@I@ LDD 2,X get status and pitch STD 2,U LDD 5,X get note length ADDD 0,X convert to time of STD ,U note off, save it BRA D@* now process A0-EFO@ CMPA #$C0 see how many bytes follow BLO Q@ program change and CMPA #$E0 channel pressure use BLO D@ only 2 bytesQ@ LDA 4,X MOUT  MIDI output* advance pointer to next event and loop backD@ LEAX EVNSIZE,X LBRA A@* process system eventsC@ CMPA #$F0 BNE P@ tempo change? TST <SLAVE BNE P@ LDD 5,X get tempo STD <CPERIOD LDD #1 STD <CPCOUNT BRA D@P@ CMPA #$F1 CLOCK on/off? BNE W@ TST <SLAVE BNE W@ LDB 4,X STB <CLOKFLAG BEQ R@ LDA #$FB continue BRA S@R@ LDA #$FC stopS@ MOUT BRA D@W@ CMPA #$F2 LINK? BNE X@ STX <LINKPTR CLR <DONE BRA D@X@ CMPA #$F3 MESSG? BNE U@ LDD CURSADR PSHS D LDD #SCRNWIDE*8+9+$400 STD CURSADR LBSR DspMESSG PULS D STD CURSADR BRA D@U@ CMPA #$F4 PAUSE? BNE N@ LBSR PlayPAUS BRA D@N@ CMPA #$F5 BYTE? BNE D@ LBSR PlayBYTE BRA D@a@ FCB 0 Metronome click flag* display the BAR/BEAT on the playbox* and set up BAR_CNT and BEAT_CNT*SetBarBt PROC S_TIM LEAX a@,PCR LDY #$052DD@ LDA ,X+ STA ,Y+ BNE D@ LDX S_TIM,S CALL Divide,REGX,TIMEBASE STD ARG1 LDB BAR CLRA STD ARG2 CALL Divide,ARG1,ARG2 INCB  bar # starts at 1 STB BAR_CNT TFR X,D remainder=beat STB BEAT_CNT LDX #$0531 Y=9, X=17 on screen CMPB #9 BHI A@ LEAX 1,XA@ LBSR BINDEC LDX #$052D Y=9, X=13 on screen LDB BAR_CNT CLRA CMPB #99 BHI B@ LEAX 1,X CMPB #9 BHI B@ LEAX 1,XB@ LBSR BINDEC LDX #$052D Y=9, X=13 on screen LDB #6C@ LDA ,X convert ascii to ORA #$40 display letters STA ,X+ on the screen. DECB BNE C@ LDA #'/+$40 STA -3,X LDA #$60 STA ,X ENDP*a@ FCC "001/01",0PlayBYTE PSHS X LEAX 3,X LDB #4A@ LDA ,X+ CMPA #$FF BEQ Z@ LBSR MIDI_OUT DECB BNE A@Z@ PULS X,PCPlayPAUS PSHS X,CC TST SLAVE BNE Z@ ORCC #$50 disable interrupts LDD CURSADR PSHS D LDD #SCRNWIDE*8+8+$400 STD CURSADR LEAX a@,PCR LBSR PUTS LBSR getchar LBSR WAIT LDD #SCRNWIDE*8+8+$400 STD CURSADR LEAX b@,PCR LBSR PUTS PULS D STD CURSADR LDA #$95 set 8 bits, no parity STA [MSTAT] enable receivZ@ PULS X,CC,PCR*a@ FCC "PAUSED-TAP A KEY",0b@ FCC "                ",0* clear the play note buffer*ClrPNB PSHS X LDX #PLNTBUFRA@ CLR ,X+ CMPX #PLNTBUFE BLO A@ PULS X,PC* output to MIDI the byte in A*MIDI_OUT PSHS B MOUT PULS B,PC LOCAL L_TIMRECORD PROC LBSR StrtAt CMPD #-1 BEQ Z@ STD L_TIM,S LDB #1 disable the filter STB FILT_FLG,PCR CALL GoTo,(L_TIM,S) STD ARG1 LDD L_TIM,S STD ARG2 CALL Record,ARG1,ARG2 CLR FILT_FLG,PCRZ@ ENDP* record MIDI data until keypress* S_PTR is a pointer to BUFFER1* S_TIME is the starting time for recording* LOCAL L_88,L_ABRT,L_ENDRecord PROC S_PTR,S_TIME LDD CURSADR save cursor position STD L_88,S LBSR ChkSOLO TST CLOKFLAG BEQ S@ CALL SendSPP,(S_TIME,S)S@ CLR PNCH_FLG LDD BLK_STRT ask if user wants to CMPD #$FFFF punch in/out if blocks BEQ V@ are set LDD BLK_END CMPD #$FFFF BEQ V@ CMPD S_TIME,S BLO V@ LEAX e@,PCR CALL SetBox,REGX LBSR getchar LBSR ClrBox CMPA #3 LBEQ O@ CMPA #'Y BNE V@ LDD #-1 cut marked block LBSR BlkCut without screen update INC PNCH_FLGV@ LBSR WAIT LDD BUF2END set up an end address DECA STD L_END,S LEAX MIDIBUF,PCR STX MBUFPTR CLR L_ABRT,S clear abort flag LBSR ClrPNB LDD S_TIME,S STD CLOCK STD CLOCKslv CLR MIDISTAT LDY S_PTR,S set play buff STY PLAYPTR LDY BUFFER2 zero buffer2 LDD #$FFFF STD ,Y LEAY -EVNSIZE,Y STY RECPTR CLR MCOUNT CLR STOP LDA #1 STA SYNCFLAG LDA #$90 set default status STA MSTATUS byte=note on LDA #$FF STA KEYINP* set up hardware ORCC #$50 disable interrupts TST SLAVE BNE H@ LEAX IRQmast,PCR set new IRQ vector LEAY FIRQmast,PCR BRA T@H@ LEAX IRQslave,PCR LEAY FIRQslav,PCRT@ STX $010D STY $0110 LBSR SetHIRQ LDA #3 initialize ACIA STA [MSTAT] master reset LDA #$95 set 8 bits, no parity STA [MSTAT] enable receive int. LBSR MPI3 enable MPI CLR $FF02 prepare for fast key read* put "recording" notice on screen TST SLAVE BEQ Y@ LEAX PLAYBOXS,PCR BRA I@Y@ LEAX PLAYBOXM,PCRI@ CALL SetBox,REGX CALL SetBarBt,CLOCK LDD #$4EB Y=7, X=11 on screen STD CURSADR LEAX b@,PCR change "PLAY" to LBSR PUTS "RECORD" LBSR ChkPunch TST SLAVE BEQ J@* in slave mode, wait here until we receive a* position indicator or until a key is pressed CLR POSNFLAG CLR SYNCFLAG ANDCC #$BF enable FIRQR@ LDA <KEYINP ANDA #$7F CMPA #$7F LBNE Z@ TST POSNFLAG BEQ R@ INC FILT_FLG CALL GoTo,SNGPOSPT CLR FILT_FLG STD PLAYPTR INC SYNCFLAG CALL SetBarBt,SNGPOSPTJ@ LDX MBUFPTR LDY RECPTR ANDCC #$AF enable interrupts* loop to get input from input buffer,* timestamp it, and put it in the main buffer* X points to input buffer, Y to the event bufferA@ TST STOP LBNE Z@ LDA KEYINP check for key ANDA #$7F CMPA #$7F LBNE Z@ LBSR ChkPunch CMPX MBUFPTR,PCR wait until data BEQ A@ is available* now get data from MIDI buffer LDA ,X is this a status byte? BPL E@* check for end of system exclusive message CMPA #$F2 song position ptr? BEQ X@ CMPA #$F7 BNE U@X@ CLR MSTATUS LBRA G@* check for start of system exclusive messageU@ STA MSTATUS keep status byte CMPA #$F0 check for sys excl. LBEQ G@* now enter an eventC@ TST PNCH_FLG BMI W@ LDY RECPTR LEAY EVNSIZE,Y CMPY L_END,S check for end BLO K@ INC L_ABRT,S BRA Z@K@ LDA TRACK set track byte STA 7,Y previous event STY RECPTR LDD CLOCK STD ,Y++ LDA MSTATUS STA ,Y+W@ LDA MSTATUS LDB #2 determine number of CMPA #$C0 bytes needed BLO D@ CMPA #$DF BHI D@ DECBD@ STB MCOUNT BRA G@* byte detected <128; check for system exclusiveE@ LDB MSTATUS BEQ G@ CMPB #$F0 BEQ G@* check for running status TST MCOUNT check for end BNE F@ previous message TST MSTATUS BEQ G@ EXG X,D increment just the DECB  LSB of X EXG D,X BRA C@F@ TST PNCH_FLG BMI c@ STA ,Y+c@ DEC MCOUNT* update input buffer pointer (just LSB)G@ TFR X,D update just LSB INCB  input buffer TFR D,X will be circular LBRA A@* all done; clean upZ@ ORCC #$50 disable interrupts LBSR ALLOFF LBSR ChkSOLO LEAX NEWIRQ,PCR STX $010D LDA #$15 STA [MSTAT] LBSR MPI4 TST SLAVE BEQ Q@ LDA #1 STA SLAVE STA SYNCFLAGQ@ LBSR SetSIRQ LDY RECPTR LEAY EVNSIZE,Y LDD #$FFFF end of record STD ,Y++ set end of music LBSR ClrBox* display abort message if appropriate TST L_ABRT,S BEQ M@ LBSR Bell LEAX a@,PCR CALL SetBox,REGXL@ LBSR getchar LBSR ClrBox* ask user if he wants to keep this takeM@ LEAX d@,PCR CALL SetBox,REGXN@ LBSR INKEY CMPA #'Y BEQ P@ CMPA #'N BEQ O@ BRA N@* massage recorded data and merge into main bufferP@ LBSR ChkNtOff LBSR GetNtLen LBSR MergeBufO@ LBSR ClrBox ANDCC #$EF enable IRQ ENDP*a@ FDB 8,5,16,5,*+4,0 FDB 2,2,*+4,0 FCC "BUFFER FULL!",0*b@ FCC "RECORD ON ",0*d@ FDB 6,5,19,5,*+4,0 FDB 2,2,*+4,0 FCC "KEEP THIS TAKE?",0*e@ FDB 7,5,17,5,*+4,0 FDB 2,2,*+4,0 FCC "PUNCH IN/OUT?",0* check punch in/out times and change the display* if necessary*ChkPunch TST PNCH_FLG BNE B@ RTSB@ PSHS X LDD CLOCK CMPD BLK_STRT BLO A@ CMPD BLK_END BHI A@* punch should be "ON" TST PNCH_FLG BPL Z@ LDA #1 STA PNCH_FLG LDD #$04F2 Y=7, X=18 on screen STD CURSADR LEAX a@,PCR LBSR PUTS BRA Z@* punch should be "OFF"A@ TST PNCH_FLG BMI Z@ LDA #$81 STA PNCH_FLG LDD #$04F2 Y=7, X=18 on screen STD CURSADR LEAX b@,PCR LBSR PUTSZ@ PULS X,PC*a@ FCC "ON ",0b@ FCC "OFF",0* convert all note off events to note on with* zero velocity*ChkNtOff PROC LDX BUFFER2A@ LDD ,X CMPD #$FFFF BEQ Z@ LDA 2,X get status byte CMPA #$90 note off? BHS B@ ORA #$90 make note on STA 2,X CLR 4,X zero velocityB@ LEAX EVNSIZE,X BRA A@Z@ ENDP* get note lengths and store them in the event buffer* delete note off events* delete filtered events* LOCAL L_NOTEGetNtLen PROC LDX BUFFER2 LEAX -EVNSIZE,X* first look for a note on eventA@ LEAX EVNSIZE,X LDD ,X check for end CMPD #$FFFF BEQ D@ LDD 2,X get status byte CMPA #$9F note on? BHI A@ TST 4,X check velocity BEQ A@* now find corresponding note off event TFR X,Y STD L_NOTE,SB@ LEAY EVNSIZE,Y LDD ,Y check for end CMPD #$FFFF BEQ C@ LDD 2,Y get status byte CMPD L_NOTE,S compare BNE B@ TST 4,Y check velocity BNE B@* note found, length=difference in times LDD ,Y note found: SUBD ,X get length STD 5,X BRA A@* note not found, so make length -1C@ LDD #$FFFF STD 5,X BRA A@* now delete all note on events with velocity* and all filtered eventsD@ LDX BUFFER2 TFR X,YE@ LDD ,X check for end CMPD #$FFFF BEQ H@ LBSR CHKFILT TSTA BEQ F@J@ LEAX EVNSIZE,X BRA E@F@ CMPB #1 check for note BNE I@ TST 4,X check velocity BEQ J@I@ LDB #EVNSIZEG@ LDA ,X+ STA ,Y+ DECB BNE G@ BRA E@H@ STD ,YZ@ ENDP* display the incoming MIDI bytes in hex format* new line at each status byte*MONITOR PROC PSHS CC ORCC #$50D@ LBSR WAIT LBSR CLS LEAX a@,PCR LBSR PUTSA@ LDA [MSTAT] BITA #1 is data available? BEQ C@ LDA [MDATA] PSHS A print it LSRA LSRA LSRA LSRA BSR E@ PULS A ANDA #$0F BSR E@ BRA G@E@ CMPA #9 BLS F@ ADDA #7F@ ADDA #'0 LBRA ChrOutG@ LDD CURSADR ADDD #2 STD CURSADR CMPD #$600 BHS B@C@ LDA $FF00 check for keypress ANDA #$7F CMPA #$7F BEQ A@B@ LBSR getchar CMPA #BREAK BNE D@Z@ PULS CC ENDP*a@ FCC "MIDI MONITOR",13,0* send song position pointer message*SendSPP PROC S_CLK LDD S_CLK,S BNE C@ LDA #$FA BRA D@C@ TST SPP_FL is SPP is enabled? BMI Z@ LDA #$F2 LBSR MIDI_OUT LDD S_CLK,S STD ARG1 CALL Divide,ARG1,#24 LSLB ROLA LSRBB@ PSHS A TFR B,A send LSB first LBSR MIDI_OUT PULS A LBSR MIDI_OUT CLRA LDD SPP_FL LBSR Delay60 LDA #$FB continue commandD@ LBSR MIDI_OUTZ@ ENDP* delay for number of 60ths of second in D*Delay60 PROC L_AMT,L_IRQ,L_CC STD L_AMT,S BEQ Z@ TFR CC,A STA L_CC,S ORCC #$50 disable interrupts LDX $010D set new IRQ vector STX L_IRQ,S LEAX NEWIRQ,PCR STX $010D LDD L_AMT,S ANDCC #$EF enable IRQA@ SYNC SUBD #1 BNE A@ ORCC #$50 restore IRQ vector LDD L_IRQ,S STD $010D LDA L_CC,S TFR A,CCZ@ ENDP* end of file: MIDI/TXT