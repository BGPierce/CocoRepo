*********************************                              **         A D O S - 3          **                              **         VERSION 1.01         **          (C) 1988            **      Arthur J. Flexser       **       SpectroSystems         **                              ********************************** 3/24/88BAUDRT EQU   87     600 BAUD* RELOCATE COMMAND DISPATCH TABLE TO LEAVE ROOM FOR NEW* COMMAND KEYWORDS.  MODIFY DISPATCH* ROUTINE TO USE RIGHT HIGH TOKEN UNDER "DISABLE"       ORG   $C220       SUBA  #$CE       CMPA  $134   NO. OF CMDS       BHS   A@     NOT DISK BASIC TOKEN       LDX   #NEWDSP  NEW TABLE       JMP   $ADD4A@     ADDA  #$CE   UNDO SUBTR       JMP   [$141] PROCESS HIGH TOKEN       NOP       NOP       NOP       ORG   $D7DD  1ST FREE ADDR* RELOCATED CMD DISPATCH TABLENEWDSP FDB   DIR   DIR  CE* DIR REDIRECTED TO PRINT FREE GRANS       FDB   $CDE9 DRIVE  CF       FDB   $CFE0 FIELD D0       FDB   $D080 FILES D1       FDB   $C6C2 KILL D2       FDB   $C99A LOAD D3       FDB   $D026 LSET D4       FDB   $C98B MERGE D5       FDB   $CF3F RENAME D6       FDB   $D025 RSET D7       FDB   $C932 SAVE D8       FDB   $CF8A WRITE D9       FDB   $D65B VERIFY DA       FDB   $D146 UNLOAD DB       FDB   $D4AB DSKINI DC       FDB   $D175 BACKUP DD       FDB   $D2CC COPY DE       FDB   $D3FF DSKI$ DF       FDB   $D474 DSKO$ E0       FDB   DOS   DOS  E1TOKEND EQU   *-2HITOK  EQU   $CE+(TOKEND-NEWDSP)/2NUMCMD EQU   HITOK-$CE+1* NEW CMD WORDS INTO CMD TABLE       ORG   $C1DB       FCC   /DO/,'S+$80* PALETTE DATA FOR FOREGROUND* AND BACKGROUND COLORS* (PALETTE NO., VALUE)PTABLE FCB   0,$12  40/80 BACKG       FCB   8,0    40/80 FOREG       FCB   12,0   32-COL FOREG       FCB   13,$12 32-COL BACKGZBAK40 EQU   *-7ZFOR40 EQU   *-5ZFOR32 EQU   *-3ZBAK32 EQU   *-1* PATCH FOR FREE GRANULE FINDER* TO ALLOW ALL 158 GRANS TO BE* USED ON 80-TRACK DRIVESGRNPAT PSHS  X,B       ABX      USE UNSIGNED ADD       LDB   ,X       COMB       PULS  X,B,PC* DSKCON PATCH FOR DIFFERENT* STEP RATES FOR DIFFERENT DRIVESDRESET LDA   #3STPADJ LDB   $EB    DRIVE NO.       LDX   #STPTAB       SUBA  B,X    ADJUST CONST       STA   $FF48  FALL INTO TWASTE* USED BY DSKCON TO AVOID* PREMATURE TIMEOUT UNDER HISPDTWASTE LDA   $FF48* SHORT DELAY SUBR FOR HIGHSPEED* DISK I/OWASTE  PSHS  U,Y,X,DP,B,A,CC       PULS  U,Y,X,DP,B,A,CC,PCZC200  EQU   *-1    SHOULD BE $C200       REORG* LAST AVAIL ADDR FOR CMDS=$C200       ORG   $C798       NOP       JSR   GRNPAT       BEQ   $C7CD       REORG* PATCH DSKCON FOR LENGTHENED* TIMEOUT       ORG   $D6E4       JSR   TWASTE       REORG* PATCH DSKCON RESTORE FOR DOUBLE-SIDED HEAD-BANG       ORG   $D6CA       NOP         REPLACE NOPS WITH       NOP         ANDB #1 FOR DOUBLE-SIDED       CLR   B,X       JSR   DRESET       REORG* PATCH DSKCON TO USE A SELECTABLE STEP RATE* FOR EACH DRIVE       ORG   $D724       JSR   STPADJ       REORG       ORG   $D527   DSKINI       JSR   STPADJ  THANKS, ROGER       REORG* PUT NO. OF  CMDS INTO RAM TABLE AT $134       ORG   $C0F6       FCB   NUMCMD REVISED NUMBER OF COMMANDS       REORG* PATCH SEEK TRACK ROUTINE TO  ** RESTORE HEAD TO ZERO IF THIS ** IS THE FIRST TIME THIS DRIVE ** WAS SELECTED.                *       ORG   $D711       NOP        FOR INSERTION OF ANDB #1       NOP        FOR DOUBLE-SIDED HEAD-BANG CURE       ABX       JSR   HDBNGP       REORGHDBNGP LDB   ,X   FIRST USE OF       CMPB  #$FF       PSHS  X    THIS DRIVE?       BNE   A@   (IS TRACK NO. =$FF?)       JSR   $D6C5 YES, GO TO TRACK 0       CLRB       SET B=TRACK 0A@     STB   $FF49 SET TRACK NO.       PULS  X,PC* PATCH TO ERROR DRIVER TO STORE* ERROR LINE NUMBER AS WORKING* LINE NUMBER.  FROM RAM PATCH* AT $AC70ERPTC  CMPX  #$ABE7 IS THIS ERROR PROCESSING?       BNE   A@     NO, WE'RE PROCESSING BREAK KEY       LDD   <$68 ERROR LINE NO.       STD   <WLINE  TO WORKING LINEA@     JMP   $BDC5 &RTS TO REGULAR PROCESSING* PATCH TO BREAK KEY CHECK DURING* "LIST" TO ENABLE ARROW KEY REPEAT* AND TO STORE LAST LISTED LINE* FOR RPTCMD FUNCTION.* (FROM RAM PATCH AT $A551)KEYPAT BSR   CHECKD       BEQ   BRKCHK       PSHS  U,X,B,A       LDU   #LINE  RPTCMD BUFFER       BSR   MOVNUM  MOVE LINE NO. THERE       LDD   4,S     U (= ADDR OF TERMINATOR+1) TO D       SUBD  #$2DD   GET (LENGTH OF TEXT+1) TO B       PSHS  B  THE +1 ALLOWS FOR SPACE AFTER LN. #       BSR   SAVLN1  MOVE TEXT TO RPTCMD BUFFER       PULS  B       ADDB  <$56    ADD LENGTH OF LINE #       INCB          ALLOW FOR TERMINATOR       STB   SAVEB   SAVE LENGTH       PULS  A,B,X,UBRKCHK JSR   $ADEB   BREAK KEY CHECKKEYRPT PSHS  X       LDX   #$FFFF       STX   $155       LDX   #$3000  DELAY CONSTZDELAY EQU   *-2       JSR   $A7D3   DELAY       PULS  X,PCMOVNUM LDX   #$3DB ADDR OF ASCII WK AREA       LDB   <$56  CHAR COUNT       JSR   $A59A MOVE TO LINEINPUT BFR       LDB   <$56  GET CHAR CT       INCB       LDA   #$20  SPACE       STA   ,U+       INCB       TFR   U,XBRTS   RTSSAVLIN LDU   #LINE       STB   SAVEBSAVLN1 LDX   #$2DD       JMP   $A59A  MOVE BYTES* PATCH TO "NEW" ROUTINE TO CLEAR* WORKING LINE NO.NEWPTC CLR   <WLINE       CLR   <WLINE+1A@     LDX   <$19       CLR   ,X+       RTS* SUBR TO CHECK IF NEW FEATURES* HAVE BEEN DISABLEDCHECKD PSHS  A       LDA   #$13       CMPA  $134       PULS  A,PC* PATCH DIR ROUTINE TO ALLOW FOR 2-COLUMN (CAT) COMMAND       ORG   $CC12       JSR   CATPTC       REORGDIR    BSR   CHECKD  DISABLED?       LBEQ  $CBCF   YES       JMP   DIR1     NO, DO MODIFIED DIR* 2-COLUMN DIRECTORY (CAT)CATPTC BSR   CHECKD  DISABLED?       LBEQ  $BDCC   YES       JMP    CATPT1  NO, DO CAT OR CATP* FIX "ZERO OUT GAT" BUG       ORG   $C70CBUGLOC JSR   BUGFIX       BNE   BUGLOC       REORG* USE PREVIOUS EXTENSION AS DEFAULT* FOR DESTINATION FILENAME IN* RENAME AND COPY COMMANDS       ORG   $CF7A       JMP   EXTPTC       REORG* EDIT PATCHES* STORE LISTED LINE AS WORKING LINE (FROM $B7A8)WLINE  EQU   $F5EDPAT  STD   <WLINE       JMP   $BDCC   & RTS* STORE INSERTED LINE AS WORKING LINE (FROM $ACAD)EDPAT2 STX   <WLINE       JMP   $B821   & RTS* ALLOW COPY <FILENAME> TO <DRIVE #>       ORG   $D2DE       JSR   COPTCH       REORGCOPTCH BSR   CHECKD       BNE   COPTC1EXTPTC LDX   #$954  FIX DEFAULT EXTENSION       JMP   $C88A* PATCH TO GIVE OPTION TO CONTINUE COPY OR RENAME* AFTER AN ?AE ERROR       ORG   $CF85       LBNE  AEPTCH       REORGAEPTCH BSR   CHECKD       LBEQ  $AC46   ?AE ERROR       BRA   AEPTC1* PATCH FUNCTION INTERPRETER FOR* NEW QUASI-FUNCTIONSFNINTR BSR   CHECKD       BEQ   SNERR       CMPA  #TOPTOK       BHI   SNERR       SUBA  #$A9  ADJUST       BLO   SNERR       LDX   #JMPADR       JMP   $ADD4  INTERPRETSNERR  JMP   $B277  SN ERROR* PATCH FILE NAME EXPRESSION DECODER TO CONVERT* FILENAME TO UPPERCASE       ORG   $C8A1       JSR   FNPTCH       REORGFNPTCH BSR   CHECKD       LBEQ  $8748* UNDER "DISABLE" OPTION, FROM* HERE ON CAN BE OVERWRITTEN* PATCH FILENAME PARSER TO* CONVERT LOWERCASEZFN    JSR   $8748 GET FILENAMESTART IN X*                  AND NO. OF CHARS IN B       PSHS  X,B,A       LDX   7,S       CMPX  #$CF45 LEAVE ALONE IF 1ST RENAME ARG       BEQ   X@       CMPX  #$CF5B ANOTHER RENAME CALL       BEQ   X@       TSTB      BLANK FILENAME?       BEQ   X@       LDX   2,S GET FILENM STRTB@     LDA   ,X+       BSR   CONVT       STA   -1,X       DECB       BNE   B@X@     PULS  A,B,X,PC* WARM RESET SEQUENCE       ORG   $C0CD       FDB   WRMPTC       REORGPRTFLG EQU   $F3WRMPTC NOP       CLR   <PRTFLG PRT OFF       LDX   #PATTPD       JSR   PACHR1 INSTALL RAM PATCHES       TST   $E000   TEST FOR COCO 3       BNE   A@       JSR   SETCLR  AND FOREGD/BKGRD COLORS, BORDER       LDA   <SMODE (0=SLOW; 1=FAST)       JSR   WRMENT REESTABLISH SELECTED CPU SPDA@     JMP   $C0D5   NORMAL WARM START* PATCH COPY CMD TO ALLOW* "COPY <FILENAME> TO <DRIVE #>"COPTC1 LDX   $A6       PSHS  X   SAVE POINTER       JSR   $B156 EVALUATE EXPRESSION       LDX   #$1A9 RESET STRING       STX   <$0B  STACK PTR       PULS  X       STX   $A6 RESTORE PARSE PTR       TST   <$6 STRING EXPRESSION?       BMI   EXTPTC  YES, DO REGULAR COPY       JMP   $D169  CHECK DRIVE NO. & STOREAEPTC1 LDX   #AEMSG-1       JSR   $B99C PRT MSGB@     JSR   $A1B1 GET RESPONSE       ANDA  #$DF   CONVERT TO UPPER CASE       CMPA  #3    BREAK?       BEQ   IDLE       CMPA  #'N       BNE   C@       JSR   $A282  ECHO CHARIDLE   JMP   $AC73  LINE INPUT MODEC@     CMPA  #'Y       BNE   B@       JSR   $A282       JMP   $C6C8  KILL OLD VERSION TO AVOID*                   POSSIBLE ?DF ERROR & RTSAEMSG  FCB   $0D       FCC   \Replace? \       FCB   0CONVT  CMPA  #$61  CONVERT TO UPPERCASE IF LOWER       BLO   Y@       CMPA  #$7A       BHI   Y@       ANDA  #$DFY@     RTS* DIRECTORY WITH FREE GRANS* AND DIRP (TO PRINTER)DIR1   BSR   CHECKP  TO PRINTER?       JSR   $CBCF   REGULAR DIR ADDR       LDX   #FREMSG-1       JSR   $B99C   PRINT MSG       JSR   $CDCE   GET FREE GRANULES       JSR   $B3ED   CONVERT TO INTEGER IN D       BSR   NOUT    PRINT* JSR $ADFB TO WAIT FOR KEYPRESS* OMITTED HERE TO SAVE 3 BYTESNOPRT  JSR   $B958   PRINT CR       CLR   <PRTFLG PRT OFFRRTS   RTSFREMSG FCC   / Free = /       FCB   0* CAT COMMAND (2-COL DIRECTORY)* CATP GOES TO PRINTERCOLFLG EQU   $C3CAT    CLR   <COLFLG FLAG FOR 1ST OR 2ND COL       BSR   DIR1      STACK CONTENTS WILL BE USED TOCATRTS RTS             DISTINGUISH CAT FROM DIR IN PATCHCATPT1 LDX   6,S  CHECK IF DOING CAT OR DIR       CMPX  #CATRTS       BEQ   CATONNOUT   JMP   $BDCC  CONTINUE DOING A DIRCATON  LDX   2,S       LDB   $0D,X       JSR   $CC44  GET GRANS       TFR   A,B       CMPB  #10    2 DIGIT #?       BHS   B@       JSR   $B9AC  PRINT SPACEB@     CLRA       BSR   NOUT   PRINT GRANS       COM   <COLFLG       BNE   A@       JSR   $B958 CR IF 2ND COL       BRA   X@A@     JSR   $B9AC  PRINT A SPACE IF 1ST COLX@     LEAS  2,S    KILL RET ADD       JMP   $CC2C  CONTINUE DOING A CAT* FIX CAT LAYOUT (REMOVE SPACE)       ORG   $CC0F       NOP       NOP       REORGCHECKP CMPA  #'P       BNE   RRTS       JMP   PRTON* PATCH TO CHROUT FOR "PRT" CMD* INSERT PATCH IN CHROUT HOOK AT $167       ORG   $C106       FDB   PRTPTC       REORGPRTPTC TST   <$6F       BNE   X@       PSHS  A       LDA   <PRTFLG       CMPA  #$55       PULS  A       BNE   X@       JSR   $A2BF  TO PRINTERX@     JMP   $CB4A  NORMAL CHROUT* CONTROL-KEY ABBREVIATED INPUT* AND PATCH TO ALLOW LOWERCASE EDIT COMMANDS* INSERT PATCH IN GET CHAR HOOK AT $16B       ORG   $C108       FDB   INPTCH       REORGINPTCH TST   $6F SCREEN?       LBNE  $C58F ORIGINAL HOOK       PSHS  X       LDX   8,S       CMPX  #$8560 IN EDIT MODE?       BNE   D@       PULS  X       LEAS  2,S   KILL RETURN       JSR   $A179 GET EDIT CMD       JMP   CONVT CONVERT TO UPPERCASE & RTSD@     CMPX  #DIRMD  RETURN IF NEITHER DIRECT MODE* WITHOUT CMD REPEAT FEATURE, USE $AC7F FOR DIRMD       BEQ   E@       CMPX  #AUTOMD NOR AUTO MODEE@     PULS  X       BNE   RTS2       JSR   $A1B1 WAIT FOR KEYPRESS       CMPB  #240  LINE ALMOST FULL?       BLO   Y@Z@     LEAS  2,S  RETURN TO LINE INPUT ROUTINE       CLR   $70  DO BUFFER FLAGRTS2   RTSY@     PSHS  A       LDA   #$EF  CTRL KEY?       STA   $FF02       LDA   $FF00       ANDA  #$48  TEST FOR EITHER DOWN ARROW OR CTRL       CMPA  #$48       PULS  A       BEQ   Q@    BRANCH IF NEITHER KEY DOWN       CMPA  #4    F2 KEY?       BNE   R@       LDA   #$10   COLOR OFFCFLIP  LDU   #$E03C       TST   -9,U       BEQ   S@       CLRA         COLOR ONS@     STA   -9,U       ADDA  #3       STA   ,U       STA   9,U       JSR   $E019 SET TEXT REGS       CLRA        SO WE FALL THROUGH TO Z@R@     JSR   CONVT CONVERT TO UPPERCASE       LDU   #WTABLEB@     TST   ,U       BEQ   Q@ FOR POSSIBLE DOWN ARROW PROCESSING       CMPA  ,U+       BEQ   OUTPUTN@     TST   ,U+       BPL   N@       BRA   B@OUTPUT LDA   ,U+       BMI   C@   LAST CHAR HAS $80 ADDED       INCB       CHAR CTR       STA   ,X+  PUT IN LINE INPUT BFR       JSR   $A282 AND ON SCREEN       BRA   OUTPUTC@     ANDA  #$7F  REMOVE THE $80Q@     CMPB  #1   NO CHARS ON LINE?       BNE   Z@   EXIT IF LINE NOT EMPTY       CMPA  #9   RIGHT ARROW?       BNE   T@       LDD   <WLINE       STD   $2B       CLR   <EFLAG       JMP   $8536  EDIT LINET@     CMPA  #$0A DOWN ARROW?       BNE   U@       BSR   LOCATE GET ADDR OF WORKING LINE TO X       BCS   H@    IF WORKING LINE HAS BEEN DELETED,       TFR   U,X   THEN USE NEAREST LINE AFTERH@     STX   $66   STORE ADDR OF SUBSEQUENT LINEX@     BEQ   IDLE2 EXIT TO IDLE LOOP IF NO NEXT LINE       LDU   2,X  GET LINE NO. OF THAT LINE       STU   $2B       JMP   $B793  LIST LINEU@     CMPA  #$5E   UP ARROW?       BNE   Z@       BSR   LOCATE       CMPX  $19  ALREADY AT TOP?       BLS   IDLE2 EXIT TO IDLE LOOP IF SO       LDX   <PRVLN  GET ADDR OF PREVIOUS LINE       BRA   H@IDLE2  LDS   <$21  RESTORE STACK       JMP   $AC7C TO IDLE LOOP* LOCATE ADDR OF WORKING LINELOCATE LDD   <WLINE       JMP   $AD03* FROM RAM PATCH AT $AD0E TO STORE* PREVIOUS LINEPRVLN  EQU   $BDFNDPAT STX   <PRVLN       LDX   ,X       JMP   $AD05* LOWER CASE PATCH* (INSERTED AT $1A4 TOKENIZE HOOK BY COLD START)LCPTCH TST   $6F KEYBD?       LBNE  $8304 NO, EXIT       LEAS  2,S KILL RTRN AD* PRE-TOKENIZING STUFF* RESERVE A STACK BYTE FOR FLAG.* IF FLAG=0, CONVERSION TO UPPERCASE TAKES PLACE.* FLAG=0 EXCEPT FOR INSIDE QUOTES OR FOLLOWING APOSTROPHE       CLR   ,-S  FLAG=0       LDX   $A6NEXT   LDA   ,X+  GET CHAR       BEQ   OUT       CMPA  #$22 QUOTE       BNE   ON       COM   ,S       BRA   NEXTON     TST   ,S       BNE   NEXT       CMPA  #$27 APOSTROPHE       BNE   DOIT       STA   ,S       FCB   $8C  SKIP NEXT INSTDOIT   BSR   STORUP CHANGE TO UPPERCASE       BRA   NEXTOUT    LEAS  1,S   RESTORE STACK       JSR   $B824 TOKENIZE* POST-TOKENIZING STUFF TO TREAT FILE NAMES AS A SPECIAL* CASE OF CONVERSION TO UPPERCASE EVEN THOUGH IN QUOTES.* WHEN QUOTE IS ENCOUNTERED, PRECEDING TOKEN IS CHECKED* TO SEE IF SYNTAX IMPLIES A FILENAME       LDX   #$2DC  $2DC=START OF TOKENIZED LINENEXT2  LDA   ,X+       BEQ   OUT2       CMPA  #$22 QUOTE?       BNE   NEXT2       PSHS  X,BBKSCN  LDA   ,-X       CMPX  $A6 PAST BEGINNING OF LINE?       BEQ   THRU       CMPA  #$80 FIND PREVIOUS TOKEN       BLO   BKSCN       LDB   ,-X  CK TOKEN BEFORE IT       CMPX  $A6  IF NOT BEYOND LINE START       BEQ   CHTBL       CMPB  #$FF DISREGARD FUNCTION TOKEN       BEQ   THRUCHTBL  LDU   #TOKTBLLOOP   CMPA  ,U+       BEQ   FIXIT       CMPU  #TABEND+1       BNE   LOOPTHRU   PULS  X,B       BRA   NEXT2FIXIT  PULS  X,BA@     LDA   ,X+       BEQ   OUT2       CMPA  #$22 END QUOTE?       BEQ   NEXT2       BSR   STORUP CONVERT TO UPPERCASE       BRA   A@OUT2   JSR   $8304 LET EXTENDED FIX RETURN ADDRESS       RTS      (CAN'T USE JMP)STORUP  JSR   CONVT CONVERT TO UPPERCASE       STA   -1,X       RTS* LIST OF TOKENS THAT A FILENAME CAN FOLLOWTOKTBL FCB   $D3 LOAD(M)       FCB   $D8 SAVE(M)       FCB   $8E RUN(M)       FCB   $D6 RENAME       FCB   $DE COPY       FCB   $A5 TO       FCB   $D2 KILL       FCB   $99 OPEN       FCB   $D5 MERGE       FCB   $98 CSAVE(M)TABEND FCB   $97 CLOAD(M)* RUNM COMMAND* INSERT PATCH ADDRESS IN "RUN" HOOK AT $194       ORG   $C124       FDB   RNPTCH       REORGRNPTCH CMPA  #$4D     'M?       BEQ   RUNM       JMP   $C990    REG HOOKRUNM   JSR   $CEE5    DO A LOADM       CLR   $FF40    DISK MOTOR OFF       LEAS  2,S      KILL RTN       JMP   $A545    DO AN EXEC*-----------------------**                       ** ADD THE / COMMAND TO  ** BASIC TO ALLOW REPEAT ** (AND EDIT) OF THE     ** PREVIOUS COMMAND      ** ENTERED FROM THE KYBD **-----------------------** INSERT PATCH TO GO IN LINE INPUT VECTOR AT $183       ORG   $C118       FDB   RPTCMD       REORG* EFLAG=0 IF COMING FROM EDIT,* $FF IF COMING FROM SLASH CMDEFLAG  EQU   $C3SAVEB  EQU   $1D6LINE   EQU   $1D7RPTCMD LDX   2,S       CMPX  #$AC7F DIRECT MODE?       BNE   RTS       LEAS  2,S       JSR   $A393  GET CMD LINEDIRMD  BCS   RTS  BREAK KEY PRESSED       PSHS  X,A,U,CC       LDA   1,X   1ST CHAR OF LINE       BEQ   RETURN NO COMMAND LINE, IGNORE       TST   $E000  COCO 3?       BNE   RETURN NO, RTS       CMPA  #'/    SLASH?       BNE   SAVLN   NO, SAVE LINE       TST   2,X     ANYTHING ELSE ON LINE?       BNE   SAVLN  YES, IGNORE SLASH       LDA   #$FF       STA   <EFLAG* AND FALL THROUGH TO STEDIT* FROM OVERLAYED CODE AT $8578STRTAG TST   <EFLAG       LBEQ  $8538STEDIT LDX   #LINE       LDU   #$2DD       LDB   SAVEB       STB   $D7  LINE LENGTH       JSR   $A59A STORE LINE       LDA   #1       STA   <$D8* AND FALL THROUGH TO XEDIT* FROM OVERLAYED CODE AT $8585LNLIST TST   <EFLAG       LBEQ  $854DXEDIT  LDA   #'<       JSR   $A282  DISPLAY <       JMP   $8555* FROM OVERLAYED CODE AT $8592EEXIT  TST   <EFLAG       BNE   A@       STX   <$A6   TO PARSE PTR       JMP   $ACA8  INSERT NEW LINE NO.A@     LDB   <$D7SAVLN  JSR   SAVLINRETURN PULS  X,A,U,CC,PC* FROM OVERLAYED CODE AT $85A5QEXIT  TST   <EFLAG       LBEQ  $AC73  TO IDLE LOOP       PULS  X,A,U,CC       COMA     SIMULATE BREAKRTS    RTS* FROM HERE ON CAN BE OVERWRITTEN* PROVIDED NEW CMDS AREN'T USED* AUTO LINE NUMBER COMMANDCURLIN EQU   $C3INCR   EQU   $C5OLDVEC EQU   $66AUTO   LDX   #10       STX   CURLIN CURRENT LINE NO.       STX   INCR LINE NO. INCR.       LDX   $183       STX   OLDVEC SAVE OLD VECTOR       JSR   <$A5       BEQ   A@     NO ARGS       JSR   $AF67  EVAL 1ST ARG       LDD   <$2B       STD   CURLIN       JSR   <$A5       BEQ   A@     NO 2ND ARG       JSR   $B26D  SN ERR IF NEXT BYTE NOT COMMA       JSR   $AF67  EVAL 2ND ARG       LDD   <$2B       STD   INCRA@     LDX   #PATCH       STX   $183       LEAS  2,S    KILL RETURN ADDR       JMP   $AC7C  TO IDLE LOOPPATCH  TST   <$6F   SCREEN?       BNE   Z@       LEAS  2,S       LDD   CURLIN       JSR   $BDCC LINE # TO SCRN & WK AREA       LDU   #$2DD LINE INP BFR       JSR   MOVNUM MOVE LINE NUMBER THERE       PSHS  A,B,X       LDD   CURLIN       JSR   $AD03 SET CARRY IF NO PRE-EXISTING LN       PULS  A,B,X       BCS   B@       LDA   #'*B@     JSR   $A282       PSHS  B       JSR   $A39A  GET INPUT LINEAUTOMD BCS   X@   BREAK KEY PRESSED, EXIT       CMPB  ,S+  ANY CHARS IN LINE?       BEQ   Y@   NO, SIMULATE BREAK TO EXIT       PSHS  CC,A,B,X,U       JSR   SAVLIN SAVE LINE FOR CMD REPEAT       LDD   CURLIN       ADDD  INCR INCREMENT LINE NO.* ELIMINATE NEXT TEST; SAVE A COUPLE BYTES*      BCS   C@      TOO BIG       CMPD  #63999       BHI   C@      TOO BIG       STD   CURLINC@     PULS  CC,A,B,X,U,PCX@     LEAS  1,SY@     COMA          SET CARRY TO SIMULATE BREAKZ@     LDX   <OLDVEC REMOVE PATCH       STX   $183       RTS* TABLE OF COMMAND ABBREVIATION WORDS* FOR INPTCH ROUTINEWTABLE FCC   /Rrun/,'"+$80       FCC   /Uload/,'"+$80       FCC   /Isave/,'"+$80       FCC   /Frunm/,'"+$80       FCC   /Jloadm/,'"+$80       FCC   /Ksavem/,'"+$80       FCC   /Ddata/,$20+$80       FCC   /Cca/,'t+$80       FCC   /Xexe/,'c+$80       FCC   /Llis/,'t+$80       FCC   /Eedi/,'t+$80       FCC   /Mmo/,'n+$80       FCC   /Aaut/,'o+$80       FCC   /Vcopy/,'"+$80       FCC   /Zrun"/,'x+$80       FCC   /Tthe/,'n+$80       FCC   /Nnex/,'t+$80       FCC   /Ggot/,'o+$80       FCC   /Pfori/,'=+$80       FCB   $5E   UP ARROW       FCC   /run"boo/,'t+$80       FCC   /H&/,'H+$80       FCB   $0C     CLEAR KEY       FCC   /"to/,'1+$80       FCC   /1fast/,$0D+$80       FCC   /2slow/,$0D+$80       FCC   /7?#-2/,',+$80       FCC   /8chr$/,'(+$80       FCB   0   TERMINATOR       FCB   13[$FF]  FREE BYTES       INCL  ADOS32.ASM