* "SCAN <FILENAME> <<,OFFSET>>" CMD* PRINTS START, END, EXEC ADDRS.* OF ML DISK FILE.* CAN TAKE OPTIONAL OFFSET AFTER* FILENAME.* "SCANP" OUTPUTS TO PRINTER* IF USED WITH ASCII FILE, WILL* LIST THE FILE.SCAN   JSR   CHECKP       JSR   $CEDF GET FILENAME, DEF. EXT OF BIN       JSR   $C959 OPEN FILE       LDA   <$6F       STA   <DUNIT       LDD   $957  GET FILE TYPE       CMPD  #$200 ML?       BEQ   M@* LIST ASCII FILEL@     JSR   $C597 GET A BYTE       TST   <$70  EOF?       BEQ   N@    NO, CONT       JSR   $A42D CLOSE FILEZ@     JMP   NOPRT PRT OFF & RTSN@     CLR   <$6F       JSR   $A282 CHROUT       BSR   BRCH  BRK KEY CHK       BRA   L@* FIND ADDRS FOR ML FILEM@     LDX   <$8A  = 0       JSR   $A5   GET BYTE       BEQ   A@       JSR   $B26D COMMA, ELSE ?SN ERROR       JSR   $B73D GET OFFSETA@     STX   <$D3       JSR   $A5C7 ?SN ERROR IF NOT END OF LNF@     BSR   BRCH   BRK KEY CHK       JSR   $CCE2  GET A BYTE       PSHS  A       JSR   $CF37  GET 2 BYTES       TFR   D,X       STD   <LEN       JSR   $CF37  GET 2 BYTES       ADDD  <$D3   ADD OFFSET       STD   <ADD       LDA   ,S+    PULS A, SET FLAG       BNE   D@E@     JSR   $C597  GET CHAR, SET EOF FLAG AT $70       LDB   <$70       LBNE  $C334  ?IE ERROR       LEAX  -1,X       BNE   E@       LDX   #LAB1       BSR   OUTP1       LDX   #LAB2       LDD   <ADD       ADDD  <LEN       SUBD  #0001       BSR   OUTP       BRA   F@D@     JSR   $A42D  CLOSE FILE       LDX   #LAB3       BSR   OUTP1       BRA   Z@     EXITBRCH   LDA   <DUNIT       STA   <$6F       JMP   $ADEB  CHK BRK KEYOUTP1  LDD   <ADDOUTP   CLR   <$6F       BSR   PRSTR  PRINT LABEL* USE ROM ROUTINES TO CONVERT* D REGISTER TO SCREEN ASCIIHEXOUT STD   <$52       BSR   A@  NEED JSR BECAUSE OF LEAS 2,S       LDX   #$1A9       STX   <$0B   RESET STRING STACK       LDX   #$3D9  PRINT DISK ADDRPRSTR  PSHS  AB@     LDA   ,X+       BEQ   X@       JSR   $A282 CHROUT       BRA   B@X@     PULS  A,PCA@     JSR   $8BE0  HEX$ ROUTINE CONVTS $52-3*                   TO ASCII STRING AT $3D9LAB1   FCB   $0D       FCC   /Start:/,0LAB2   FCC   / End:/,0LAB3   FCC   / Exec:/,0ADD    EQU   $C3LEN    EQU   $C5DUNIT  EQU   $66* "MON<<HEX ADDRESS>>" COMMAND* MEMORY EXAMINE AND CHANGE;* WORKS MUCH LIKE ZBUG.* HOLDING SHIFT DOWN CAUSES* UP AND DOWN ARROW KEYS TO RPT.STAGE  EQU   $C3 0=STG1; FF=STG2MAX    EQU   $C4 MAX NO. DIGITSOLDHK  EQU   $C5ADR    EQU   $F8HADR   EQU   ADR-1CONTS  EQU   $67HCONTS EQU   CONTS-1MON    LDX   $16B   GET CHAR HOOK       STX   OLDHK       LDX   #GETCH       STX   $16B       TSTA         ANY ARGUMT?       BEQ   ENTKEY       BSR   DISPLA YES, DISPLAY       BRA   LINEINDISPLA BSR   GETHEXDSP0   LDD   <ADR       BSR   HEXOUT PRT ADDRDSP1   LDA   #'/       BSR   OUTCH       BSR   SPC    PRT SPACE       LDB   [ADR]       CMPB  #$20   CONTENTS PRINTABLE ASCII?       BLS   B@       CMPB  #$80       BHS   B@       TFR   B,A    YES, PRTB@     BSR   OUTCH  NO, SPACE       BSR   SPC2   + 2 SPACES       CMPB  #$10       BHS   A@       LDA   #'0    PRT LEADING 0 IF < $10       BSR   OUTCHA@     CLRA       BSR   HEXOUT PRT CONTENTS       BSR   SPC2   2 SPACES* INITIALIZE STG. 2 (POST-SLASH)STG2   LDD   #$FF02 STAGE 2       STD   STAGE  2 DIGITS MAXLNINIT LDX   #$2DD  LN INPUT BFR       STX   $A6    TO BASIC PTR       LDB   #1     CHAR CTR       RTSA@     BSR   POKEENTKEY LDD   #$0004 STAGE 0       STD   STAGE  4 DIGIT MAX       LDA   #':       BSR   OUTCHLINEIN JSR   $A390  GET LINEENT1     EQU   *       BCC   A@     EXIT IF BREAK       BSR   POKE   DO POKE BEFORE EXITINGEXIT   LDX   OLDHK       STX   $16B       JMP   $AC73POKE   CMPB  #1       BEQ   A@       TST   STAGE       BEQ   A@       BSR   LNINIT       LDX   #HCONTS-1       BSR   GH0   EVALUTE NEW VALUE       LDB   CONTS       STB   [ADR] POKE IT INA@     RTSSPC2   BSR   SPC    PRT 2 SPACESSPC    LDA   #$20OUTCH  JMP   $A282  CHROUTGETHEX LDX   #HADR   STORAGEGH0    CLR   ,X       CLR   1,X       CLR   2,X       JSR   <$A5   GET CHAR       JMP   $8821  DO &H, RTS* ROUTINE TEMPORARILY INSERTED* IN GET CHAR HOOKGETCH  LDY   6,S       CMPY  #ENT1    FOR DISENGAGE ON RESET       LEAS  2,S       BNE   EXITGETCH1 JSR   $A1B1  WAIT FOR KEYPRESS       CMPA  #3     BREAK       BEQ   X@       CMPA  #$0D   CR       BEQ   X@       CMPA  #8     BS       BEQ   X@       CMPA  #$0A   DOWN AR       BNE   B@G@     CLR   ,X     TERMINATOR       BSR   POKE       LDD   <ADR       ADDD  #1D@     STD   <ADR       JSR   KEYRPT KEY REPEAT       JSR   $B958  PRINT CRE@     LBSR  DSP0   DISPLAY       BRA   GETCH1B@     CMPA  #$5E   UP ARROW?       BNE   C@I@     CMPB  #1       BNE   BEEP       BSR   OUTCH       LDD   <ADR       SUBD  #1       BRA   D@C@     CMPA  #'/       BEQ   SLASH       JSR   $90AA  SET CARRY IF NON-NUMERIC       BCC   Y@       ANDA  #$DF   UPPERCASE       JSR   $B3A2  SET CARRY IF NOT A LETTER       BCS   BEEP       CMPA  #'G       BHS   BEEPY@     CMPB  MAX       BHI   BEEPX@     CLR   ,X   TERMINATOR       RTSSLASH  TST   STAGE       BNE   BEEP       CMPB  #1 AT LINE BEGIN?       BEQ   E@       CLR   ,X   TERMINATOR       LBSR  LNINIT       BSR   GETHEX  EVAL ADDR.       LBSR  DSP1    DISPLAY       BRA   GETCH1  STG 2 INPUTBEEP   PSHS  A,B,X       LDD   #$6401       STA   $8C       JSR   $A951 BEEP       PULS  A,B,X       BRA   GETCH1* "PRT" CMD FOR SENDING SCRN* OUTPUT TO PRINTER AS WELLPRT    SUBA  #$AA TOKEN FOR OFF       BEQ   PRTOFF       CMPA  #($88-$AA) ON TOKEN?       JSR   $A5C9 NO, ?SN ERRORPRTON  LDA   #$55  ENABLE PRTPRTOFF STA   <PRTFLG       JMP   <$9F  BUMP PTR, RTS* DOS ROUTINE SIMILAR TO THAT IN* TANDY DISK BASIC VER 1.1DOS    LDD   #$200 READ/DRIVE 0       STD   $EA       LDD   #$2201  TRACK 34, SECTOR 1       STD   $EC       LDD   #$2600  SET READ       STD   $EE    ADDRESSA@     JSR   $D66C DSKCON       LDA   $F0       LBNE  $A619 I/O ERROR       INC   $EE   INC POINTER       INC   $ED   INC SECTOR       LDA   $ED       CMPA  #19    ALL SECTORS?       BLO   A@        LOOP       LDD   $2600       CMPD  #$4F53 "OS" ?       LBEQ  $2602RESET  CLR   <$71       RESET* DISABLE COMMAND* THIS CMD DISABLES MOST ADDED FEATURES, AND* FREES UP MEMORY FROM ABOUT $D900 UP, SHOULD* THIS BE NECESSARY FOR COMPATIBILITY REASONS.DTABLE FCB   2       FDB   $16B       FDB   $C58F  UNHOOK INPTCH       FCB   2       FDB   $183       FDB   $C6B7  UNHOOK RPTCMD       FCB   2       FDB   $195       FDB   $C990  UNHOOK RUNM       FCB   2       FDB   $1A4       FDB   $8304  UNHOOK LCPTCH       FCB   2       FDB   $168       FDB   $CB4A  UNHOOK PRTPTTC       FCB   1       FDB   $134       FCB   $13    DISABLE "DOS" CMD       FCB   1       FDB   $11A       FCB   $FF    UPPERCASE MODE       FCB   2       FDB   $0072       FDB   $C0D4  REG. WARM ST.       FCB   0      TERMINAT0RDISABL LDX   #DTABLE       BRA   PACHR1* PATCH COLD START ROUTINE     ** SET ALL TRACK #'S TO $FF FOR ** FLAG TO INDICATE DRIVE NEVER ** USED BEFORE & TURN VERIFY ON.*       ORG   $C0C2       JSR   COLDPT       NOP       REORGBORDER EQU   $12WID32  EQU   $F652WID40  EQU   $F65CWID80  EQU   $F679COLDPT CLR   $11A  COME UP IN LOWER CASE       BSR   PATCHR INSERT PATCH* TEST FOR COCO 3 SO WON'T CRASH* IMMEDIATELY IF ADOS-3 IS USED* IN A COCO 1/2.       TST   $E000 (=0 ON COCO 3)       BNE   A@       JSR   WID32 (OR WID40 OR WID80)ZWIDTH EQU   *-2       BSR   SETCLR SET SCREEN COLOR CHARACTERISTICS       BSR   SLOW   (OR FAST)ZSPD   EQU   *-1A@     ANDCC #$AF  ENABLE IRQ       JMP   $C0DD & RTS* SLOW AND FAST MPU-SPEED COMMANDSSMODE  EQU   $F4  (=1 FOR FAST, 0 FOR SLOW)FBAUD  EQU   2*BAUDRT+5SLOW   FCB   $CC  OPCODE FOR LDD IMMEDIATE       FCB   $00       FCB   BAUDRTZBAUD  EQU   *-1       BRA   A@FAST   FCB   $CC  OPCODE FOR LDD IMMEDIATE       FCB   $01       FCB   FBAUDZFBAUD EQU   *-1A@     STA   SMODE       STB   $96WRMENT LDU   #$FFD8       STA   A,U       RTS* SET UP SCREEN COLOR CHARACTERISTICSSETCLR       NOP         FOR INSERTION       NOP         OF "RGB" CMD       NOP         (JSR $E674)ZRGB   EQU   *-3       LDA   #BORDERZBORD  EQU   *-1       JSR   $F766 SET BORDER COLOR* SET PALETTES 0,8,12,13 FOR DEFAULT* FOREGROUND, BACKGROUND COLORSPALETS LDU   #PTABLEA@     LDD   ,U++       STA   $2C    PALETTE NO.       STB   $C0    VALUE       JSR   $E60F  SET PALETTE VALUE       CMPU  #PTABLE+8 DONE?       BNE   A@XRTS   RTS* COLD START STUFF FOR COCO 3PATCHR LDX   #PATCHSPACHR1 LDB   ,X+ NO. OF BYTES       BEQ   XRTS  TERMINATOR?       LDU   ,X++ DESTINATION       JSR   $A59A MOVE B BYTES FROM X TO U       BRA   PACHR1* FIRST 3 PATCHES FOR COLD START ONLYPATCHS FCB   4       FDB   $97E       FCB   4[$FF] HEAD BANG INIT       FCB   2       FDB   $1A4       FDB   LCPTCH LOWERCASE PATCH       FCB   1       FDB   $987       FCB   $FF    VERIFY ON* THE FOLLOWING PATCHED ON TEPID* AS WELL AS COLD STARTPATTPD FCB   3       FDB   $C0C6       LDX   #$C125 ADOS COPYRIGHT MSG* CHANGE JSR $167 TO LBSR $167 AT* BEGINNING OF CHROUT TO SUPPRESS* EQUALS SIGN FOR CTRL KEY       FCB   3       FDB   $A282       FCB   $17,$5E,$E2* CHANGE OK PROMPT TO ">"       FCB   2       FDB   $ABEE       FDB   $3E00* REAL LOWERCASE ON 32-COL SCRN       FCB   3       FDB   $95CA       JMP   LCASE* DON'T RESET SCREEN WIDTH TO 32* AND DON'T CLEAR ATTRIBUTE BYTE* ON COLD START.       FCB   3       FDB   $E390       FDB   $E38D STORE TO DUMMY LBRN ARG       FCB   $D7  STB (WAS STD)* PUT NEW CMDS IN FUNCTION LIST AFTER "ERLIN"CMDPTC FCB   (ENDPTC-*-3)       FDB   $E27ENEWNMS FCC   /AUT/,'O+$80       FCC   /CA/,'T+$80       FCC   /SCA/,'N+$80       FCC   /DISABL/,'E+$80       FCC   /MO/,'N+$80       FCC   /PR/,'T+$80       FCC   /SLO/,'W+$80       FCC   /FAS/,'T+$80* JUMP TABLEJMPTAB FDB   $E573 LPEEK $A9       FDB   $E5B1 BUTTON $AA       FDB   $E85C HPOINT $AB       FDB   $E4E9 ERNO $AC       FDB   $E4FD ERLIN $AD       FDB   AUTO $AE       FDB   CAT $AF       FDB   SCAN $B0       FDB   DISABL $B1       FDB   MON $B2       FDB   PRT $B3       FDB   SLOW $B4       FDB   FAST $B5ENDPTC EQU   *TOPTOK EQU   $A8+(ENDPTC-JMPTAB)/2NUMFNS EQU   TOPTOK-$A8OFFSET EQU   $E27E-NEWNMSJMPADR EQU   JMPTAB+OFFSET*MODIFY CMD TABLE       FCB   1       FDB   $E167       FCB   NUMFNS*MODIFY CMD INTERPRETER       FCB   2       FDB   $E1C0       FDB   JMPADR       FCB   2       FDB   $8166       FDB   FNINTR FUNCTION INTERP* ENABLE 60-HZ IRQ SO WON'T HANG* ON WARM START WHEN HITS THE* "SYNC" IN THE PALETTE ROUTINE       FCB   1       FDB   $FF03       FCB   $35       FCB   1       FDB   $FE08       FCB   0  SET ATTRIB BYTEZATTR  EQU   *-1* MODIFY EDIT COMMAND SO THAT* SLASH COMMAND CAN USE SAME CODE       FCB   2       FDB   $81F2       FDB   EDIT   RE-ROUTE EDIT CMD       FCB   5       FDB   $8578       FCB   $8D,$20  BSR CR       JMP   STRTAG       FCB   5       FDB   $8585       FCB   $8D,$13  BSR CR       JMP   LNLIST       FCB   11       FDB   $8592       FCB   $8D,$06  BSR CR       LDX   #$2DD       JMP   EEXITCR     JMP   $B958  PRINT CR       FCB   5       FDB   $85A5       FCB   $8D,$F3  BSR CR       JMP   QEXIT       FCB   2       FDB   $B7A9       FDB   EDPAT  SAVE WORKING LINE       FCB   2       FDB   $ACAE       FDB   EDPAT2 SAVE WORKING LINE* DON'T PRINT PROMPT AFTER LIST* SO WE DON'T SEE IT WHEN USING* UP AND DOWN ARROWS TO SCROLL PGM.* ALSO, RESET STACK AFTER USING* ARROW KEYS.       FCB   2       FDB   $B79D       FDB   IDLE2* PATCH TO "FIND ADDRESS OF LINE"* SO THAT IT ALSO REMEMBERS WHERE* PREVIOUS LINE WAS       FCB   3       FDB   $AD0E       JMP   FNDPAT* PATCH "NEW" CMD TO CLEAR WORKING LINE NO.       FCB   4       FDB   $AD19       JSR   NEWPTC       NOP* PATCH ERROR HANDLER TO TRANSFER* ERROR LINE NO. TO WORKING LINE NO.       FCB   2       FDB   $AC71       FDB   ERPTC* PATCH "LIST" BREAK KEY CHECK TO* ENABLE ARROW KEY REPEAT       FCB   2       FDB   $A552       FDB   KEYPAT* KEY REDEFINITIONS       FCB   1       FDB   $A3A6       FCB   4     F2 KEY CLEARS SCREEN       FCB   1       FDB   $868F       FCB   4     F2 KEY EXITS EDIT INSERT MODE       FCB   0 TERMINATOR* CUSTOM LOGO (MUST NOT GO BEYOND $C17E)       ORG   $C126       FCC   /  A D O S - 3 Disk Basic V1.01/,$0D       FCC   /  (C) 1988   Arthur J. Flexser/,$0D,$0D,0* "ZERO OUT GAT" BUG FIXBUGFIX CLR   ,U+       CMPU  #$700       RTS* PATCH FOR 32-COL LOWERCASELCASE  ORA   #$50ZBDR32 EQU   *-1       STA   $FF22       PULS  A,B,X,PC* NEW EDIT COMMAND ENTRY POINTEDIT   LDB   #0    PRESERVE CARRY, DON'T USE CLR       STB   <EFLAG       JMP   $8533 TO REGULAR EDIT* DATA FOR STEP RATES, DRIVES 0-3STPTAB FCB 0,0,0,0 SET FOR 30 MSZC17F  EQU   *     SHD BE $C17F       REORGZZZ    EQU   *-1* ZZZ SHOULD EQUAL $DFFF* CHANGE TO LOWER CASE       ORG   $D272       FCC   /Insert sourceInsert destination /       FCC   /diskette and/,$0D       FCC   /press/* RANDOM FILE BUG FIX       ORG   $CACD       FCB   $0A* COPY BUG SEMI-FIX       ORG   $D2ED       FCB   $80* DSKINI BUG FIX       ORG   $D4FF       CLR   <$EC       CLR   <$EA* ANOTHER RANDOM FILE BUG FIX       ORG   $D0AB       NOP       NOP       NOP* INSERT JMP TO DELAY SUBR AT* VARIOUS PLACES TO ENABLE* RELIABLE HI-SPEED DISK I/O       ORG   $D75E       JSR   WASTE       NOP       ORG   $D52A       JSR   WASTE       NOP       ORG   $D6D1       JSR   WASTE       NOP       ORG   $D6F1       JSR   WASTE       NOP       ORG   $D727       JSR   WASTE       NOP       ORG   $C0EE       JSR   WASTE       NOP* DO REGULAR BREAK KEY CHECK ON* DIR SO WON'T BE SLOWED BY KEY* REPEAT ROUTINE       ORG   $CBEE       FDB   $ADEB* 3/24/88