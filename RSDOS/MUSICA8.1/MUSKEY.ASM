
* MUSKEY/TXT
* Updated 10-26-87
* Contains all the Key Command routines
* Does not contain any of the support subroutines

MENTAB FCB 94 MOVE CURSOR UP
 FDB CURSUP
 FCB 10 MOVE CURSOR DOWN
 FDB CURSDN
 FCB 9 ADVANCE CURSOR
 FDB CURSAD
 FCB 8 BACKUP CURSOR
 FDB CURSBK
 FCB 93 SCREEN ADVANCE 12 NOTES
 FDB CURFWD
 FCB 21 SCREEN SHIFT BACK
 FDB CURBAK
 FCB 95 SHIFT UP ARROW
 FDB CURUPO
 FCB 91 SHIFT DOWN ARROW
 FDB CURDNO
 FCB 12 CLEAR MEMORY (SHIFT CLEAR)
 FDB CLEAR
 FCB 13 ENTER NOTE
 FDB KEYENT
 FCB 'A
 FDB KEYA APPEND SPECIAL PROGRAM
 FCB 'B
 FDB KEYB RESET TO START OF COMPOSITION
 FCB 'C
 FDB KEYC CHANGE WAVE FORM TABLE POINTERS
 FCB 'D
 FDB KEYD DELETE
 FCB 'E
 FDB KEYE MOVE TO END OF MUSIC
 FCB 'F
 FDB KEYF FLAT
 FCB 'G
 FDB KEYG GENERATE NEW WAVEFORM TABLE
 FCB 'H
 FDB KEYH SELECTIVE DISPLAY (HIGHLIGHT)
 FCB 'I
 FDB KEYI INSERT
 FCB 'J
 FDB KEYJ SELECT JOYSTICK INPUT
 FCB 'K
 FDB KEYK SAVE FILE
 FCB 'L
 FDB KEYL LOAD FILE
 FCB 'M
 FDB KEYM BARLINE (MEASURE)
 FCB 'N
 FDB KEYN KEY SIGNATURE
 FCB 'O
 FDB KEYO SET OPTIONS
 FCB 'P
 FDB KEYP PLAY
 FCB 'Q
 FDB KEYQ QUICK MOVE TO BAR #
 FCB 'R
 FDB KEYR REST
 FCB 'S
 FDB KEYS SHARP
 FCB 'T
 FDB KEYT FIND TABLE POINTERS
 FCB 'U
 FDB RETURN not implemented yet
 FCB 'V
 FDB KEYV CHANGE VOICE
 FCB 'W
 FDB KEYW WRITE SCREEN TO PRINTER
 FCB 'X
 FDB KEYX EXCHANGE VOICES
 FCB 'Y
 FDB KEYY COPY FROM ONE VOICE TO ANOTHER
 FCB 'Z
 FDB KEYZ EXIT TO BASIC
 FCB ':
 FDB KEYCOL : REPEAT
 FCB '*
 FDB KEYAST * Play all files
 FCB '-
 FDB KEYHYP - DELETE BLOCK OF MUSIC
 FCB '@
 FDB SETSTE @ SELECT STEREO/TV OUTPUT
 FCB ';
 FDB KEYSMC ; WRITE TITLE
 FCB ',
 FDB KEYCOM , BAR NUMBER DISPLAY
 FCB '.
 FDB KEYPER . COPY SECTION
 FCB '<
 FDB RPTMRK < Repeat marker
 FCB '>
 FDB PRTMRK > Part marker
 FCB '/
 FDB KEYSIG / SET KEY SIGNATURE
 FCB '?
 FDB HELP ? HELP
 FCB 0 END OF TABLE MARKER

KEYENT JSR DRAW0 enter note
KEYEN0 TST EPLFLG test for play after entry
 BEQ KEYEN1
 LDX ADDRES
 LDA 9,X change next chord descriptor
 CLR 9,X to an end of music marker
 PSHS A,X
 DEC PALFLG
 JSR KEYP
 CLR PALFLG
 JSR SETGRA
 PULS A,X
 STA 9,X restore next chord descriptor
KEYEN1 JMP PRTMEM

KEYD JSR DELETE
 JMP PRTMEM

KEYI JSR INSERT
 JSR PRTMEM
 TST [ADDRES] TEST FOR OPTION
 BMI KEYI2
KEYI1 JMP UPDATE
KEYI2 CLRA
 LDB NVALU
 JSR LOOKUP
 STB [ADDRES]
 JSR KEYR
 BRA KEYI1

KEYE LDD FINISH
 SUBD #9*12
 CMPD #STAMUS
 LBLE RETURN
 STD ADDRES
 JSR SETXY
 LDA #28
 STA XVAR
 LDD FINISH
 STD ADDRES
 RTS

SETXY LDA #4
SETXY1 STA XVAR
 LDA #58
 STA YVAR
 JMP UPDATE

KEYB LDD #STAMUS RESET TO START OF MUSIC
 STD ADDRES
 JMP SETXY

CURFWD JSR CURSAD move cursor forward
 LDD ADDRES until keypress
 CMPD FINISH
 BEQ CURFW1
 JSR GETKEY
 TSTA
 BEQ CURFWD
CURFW1 RTS

CURBAK JSR CURSBK MOVE CURSOR BACK
 LDD ADDRES UNTIL KEYPRESS
 CMPD #STAMUS
 BLE CURBA1
 JSR GETKEY
 TSTA
 BEQ CURBAK
CURBA1 RTS

CURUPO LDB YVAR MOVE UP 1 OCTAVE
 SUBB #21
 CMPB #15
 BGE CURUOA
 LDB #16
CURUOA STB YVAR
 RTS

CURDNO LDA YVAR MOVE DOWN 1 OCTAVE
 ADDA #21
 CMPA #100
 BLO CURDOA
 LDA #100
CURDOA STA YVAR
 RTS


KEYF DEC FLAT SET FLAT FLAG
 CLR SHARP
 RTS

KEYH LDU #SELMSG
 JSR DSPMSG
KEYHA JSR GETKEY
 CMPA #'0 INPUT MUST BE 0-4
 BLO KEYHA
 CMPA #'5
 BGE KEYHA
 SUBA #'0 CONVERT TO HEX
 STA VDISP SAVE VOICE # IN FLAG
 JMP UPDATE

SELMSG FCC "HIGHLIGHT VOICE (0=NONE):"
 FDB $A700

CLEAR LDU #CLRMSG CLEAR MEMORY
 JSR DSPMSG
CLEARA JSR GETKEY GET RESPONSE
 BEQ CLEARA
 CMPA #'Y IF RESPONSE IS "Y" (YES) THEN CLEAR
 LBNE CLRMES
 CLR STFLAG
 LEAS 2,S
 JMP ST00

CLRMSG FCC "OK TO CLEAR MEMORY?"
 FDB $AC00

KEYL PSHS A KEEP EXIT CODE
 LDX #LOADM
 TST TAPEIO check tape I/O flag
 BNE TAPLOD
 LDY #MUSEXT Y POINTS TO "MUS" EXTENSION
 PSHS X
 JSR DIRECT
 PULS X
 LDD #$D344 SET DISK LOAD TOKEN
KEYL2 STA ,X IN BASIC PROGRAM
 STB 5,X
 PULS A RESTORE EXIT CODE
KEYL3 JMP KEYZ
TAPLOD LDD #$9754 SET TAPE LOAD TOKEN
 BRA KEYL2

MUSEXT FCC "MUS"

KEYK PSHS A
 LDX #SAVEM
 TST TAPEIO
 BNE KEYK2
 LDD #$D844 SET DISK SAVE TOKEN
 JMP KEYL2
KEYK2 LDD #$9854 SET TAPE SAVE TOKEN
 JMP KEYL2

SETSTE COM STEREO select STEREO PAK/Mono
SETSTA TST STEREO
 BEQ SETSTB
 LDA #'S
 BRA SETSTC
SETSTB LDA #$60 (SCREEN CODE FOR SPACE)
SETSTC STA MEMADR+16
 RTS

KEYJ COM JSTFLG
 CLR FLAT
 CLR SHARP
 RTS

KEYA LDY #CMDEXT LOAD COMMAND
 JSR DIRECT
 LDA #'A
 JMP KEYZ

CMDEXT FCC "CMD"

KYSMC0 JSR CLRTTL
KEYSMC LDX #TITLE semicolon command: write title
KEYSM0 LDA ,X
 PSHS A
 LDA #1 blink cursor on
 BSR KEYSCC
 PULS A
 BSR KEYSCC blink cursor off
KEYSM1 JSR GETKEY
 BEQ KEYSM0 wait for keypress
 CMPA #12 clear?
 BEQ KYSMC0
 CMPA #32 test for space
 BGE KEYSM6
 CMPA #13 was key=cr?
 BNE KEYSM2
 CMPX #TITLE+32 if cursor already on 2nd line
 BLO KYSM1A
 RTS then return
KYSM1A LDX #TITLE+32
KEYSM2 CMPA #9 key=forward arrow?
 BNE KEYSM3
 LEAX 1,X
 BRA KEYSM4
KEYSM3 CMPA #8 key=back arrow?
 BNE KEYSM0
 LEAX -1,X
KEYSM4 CMPX #TITLE check for boundaries
 BGE KEYSM5
 LDX #TITLE
KEYSM5 CMPX #TITLE+64 check for end
 BGE KEYSMC
 BRA KEYSM0
KEYSM6 STA ,X+ update string
 BRA KEYSM5
KEYSCC STA ,X blink cursor off
 PSHS X
 LDX #$600
 JSR DELAY
 JSR DSPTTL
 PULS X,PC

KEYPER TST MARK1 mark and move music
 BEQ KEYPM1
 TST MARK2
 LBEQ KEYPM2
KEYPR0 LDD MARK2 move: calculate length
 SUBD MARK1
 BLE KEYPM1 error? if so, make this the new 1 mark
KEYPM0 TFR D,Y Y is the counter
 STD COUNT
 LDD FINISH calculate top address
 TFR D,X
 ADDD COUNT
 TFR D,U
 CMPU #LIMMEM
 LBHI KEYPRA abort if not enough memory
 STD FINISH update finish pointer
 LEAX 1,X
 LEAU 1,U
KEYPRN LDA ,-X move top of memory up
 STA ,-U
 CMPX ADDRES
 BNE KEYPRN
 LDD MARK1 move block
 CMPD ADDRES if move to <MARK1,
 BMI KEYPBL adjust MARK1
 ADDD COUNT
KEYPBL TFR D,X
 LDU ADDRES
MOVEP LDA ,X+
 STA ,U+
 LEAY -1,Y
 BNE MOVEP
 CLR MARK1
 CLR MARK2
 JSR ENDMRK
 JSR PRTMEM
 JMP UPDATE
KEYPM1 CLR MARK2
 LDD ADDRES first mark
 STD MARK1
 LDA #'0
 STA MRKMS1
 BRA KEYPM3
KEYPM2 LDD ADDRES second mark
 STD MARK2
KEYPM3 INC MRKMS1
 LDU #MRKMSG
 JMP DSPMSG

MRKMSG FCC "MARKER "
MRKMS1 FCC "1"
 FDB $B800
ABRMSG FCC "ABORTED"
 FDB $B900

KEYCOL JSR REPEAT
 JMP UPDATE
REPEAT LDY #$0FEDF graphics byte for repeat
 LDA #$0FD note descriptor for repeat
 JSR BARRPT
 CLR COUNT count repeat bars
 LDX #STAMUS-9
KEYN1 LEAX 9,X
 CMPX ADDRES
 BHI KEYN2
 LDA ,X
 BEQ KEYN2
 CMPA #$FD
 BNE KEYN1
 INC COUNT
 BRA KEYN1
KEYN2 LSR COUNT is count odd or even?
 BCS KEYN3
 LDY #$F7FF even count
 BRA KEYN4
KEYN3 LDY #$FFFD odd count
KEYN4 LDA XVAR
 STA XVAR1
 LDA #43 calculate screen address
 STA YVAR1
 JSR CURCAL X=cursor address
 LEAX 9*32,X
 BSR KEYN5
 LEAX 6*32,X
 BSR KEYN5
 LEAX 30*32,X
 BSR KEYN5
 LEAX 6*32,X
 BSR KEYN5
KEYN5 TFR Y,D write dots
 ANDA ,X
 ANDB 1,X
 STD ,X
 RTS

KEYM LDY #$0FEFF graphics byte for barline
 LDA #$0FF note descriptor for barline
BARRPT STA [ADDRES] write barline or repeat
 JSR BLANK
 LDA XVAR
 STA XVAR1
 LDA #43
 STA YVAR1
 JSR CURCAL
BARRP1 TFR Y,D
 ANDA ,X
 ANDB 1,X
 STD ,X
 LEAX $20,X
 CMPX #SCREEN+$D00
 BLO BARRP1
 LDD ADDRES advance to next position if at end
 CMPD FINISH
 BLO BARRP2
 ADDD #9
 STD FINISH
 JSR ENDMRK
BARRP2 TST BARMRK test for bar numbers
 BEQ BARCT4
 LDX #STAMUS count number of barlines
 LDD #0 clear bar counter
 STD TEMP
BARCNT LDA ,X
 CMPA #$FF barline?
 BEQ BARCT0
 CMPA #$FD repeat bar?
 BNE BARCT1
BARCT0 LDD TEMP increment counter
 ADDD #1
 STD TEMP
BARCT1 LEAX 9,X advance to next chord
 CMPX ADDRES
 BLE BARCNT loop back if not done
 LDD TEMP
 JSR HEXBCD convert to decimal
 LDA XVAR
 STA XVAR1
 LDA #22
 STA YVAR1
 JSR CURCAL calculate display address
 LDB #3
 LDY #OUTDEC+2
 LDU #VTBSTR
BARCT2 LDA ,Y+
 CMPA #' 
 BEQ BARCT3
 STA ,U
 PSHS U,Y,X,B
 CLR HIRES set hires display
 JSR GETMS1
 PULS B,X,Y,U
BARCT3 LEAX 256,X move down to next line
 DECB
 BNE BARCT2
BARCT4 JMP PRTMEM

KEYAST TST TAPEIO check for disk I/O
 LBEQ PLYALL play all files if disk
 RTS

*Allow the entry of new waveform
*table pointers from the keyboard

KEYC JSR FNDPNT find last wave table pointers used
 LDX #PCGM0 X points to display string
 LDD STAMUS-4 transfer pointers to string
 SUBD #BASWAV+BASEWV after converting to ASCII
 ADDD #$3131
 STD ,X++
 LDD STAMUS-2
 SUBD #BASWAV+BASEWV
 ADDD #$3131
 STD ,X
 LDX #PCGM1 clear entry string
 LDD #$2020
 STD ,X
 STD 2,X
 LDB #4
KEYC0 LDA #$20 store cursor in string
 STA ,X
 PSHS B,X
 LDU #PCGM
 JSR DSPMSG
KEYC1 JSR GETKEY get keyboard input
 CMPA #13 test for <ENTER>
 BNE KEYC1A
 LDX #PCGM0
 LDY #PCGM1
 LDB #4
 JSR MOVED
 LEAS 3,S
 BRA KEYC2
KEYC1A CMPA #'0 entry must be 1-4
 BLE KEYC1
 CMPA #'5
 BGE KEYC1
 PULS B,X
 STA ,X+
 DECB decrement counter
 BNE KEYC0 get next entry if not done
KEYC2 JSR CLRMES clear message
 LDB STAMUS-5 load last tempo
 JSR CNVDC0 tempo-->decimal
 STD TEMPOS
 LDX #TEMPS1
 LDD #$2020
 STD ,X
 LDB #2 B is the number of input items counter
KEYC5 PSHS B,X
 LDU #TEMPOS
 JSR DSPMSG
KEYC5A JSR GETKEY get input
 CMPA #13 test for <ENTER>
 BNE KEYC6
 PULS B,X
 LDD TEMPOS
 STD TEMPS1
 BRA KEYC7
KEYC6 CMPA #'0 input must be 0-9
 BLO KEYC5A
 CMPA #'9
 BHI KEYC5A
 PULS B,X
 STA ,X+
 DECB
 BNE KEYC5
KEYC7 JSR CLRMES
 LDX ADDRES
 LDA ,X test for previously
 CMPA #$FE entered pointers
 BEQ KEYC8
 PSHS X
 JSR INSERT
 PULS X
 LDA #$FE
 STA ,X
KEYC8 LEAX 1,X
 LDY #PCGM1 move pointers
 BSR KEYC9
 BSR KEYC9
 LDD TEMPS1 convert tempo to binary
 SUBD #$3030
 PSHS B
 LDB #10
 MUL
 ADDB ,S+
 LSLB
 STB ,X store binary tempo in code
 LDA XVAR
 STA XVAR1
 JSR NEWPNT
 JSR CURSAD advance cursor
 JMP UPDATE
KEYC9 LDD ,Y++
 SUBD #$3131 convert to binary
 ADDD #BASWAV+BASEWV
 STD ,X++
 RTS
PCGM FCC "LAST POINTERS: "
PCGM0 FCC "    "
 FCB $8D
 FCC "NEW POINTERS (1-4): "
PCGM1 FCC "    "
 FDB $8800
TEMPOS FCC "   = LAST TEMPO"
 FCB $91
 FCC "NEW TEMPO: "
TEMPS1 FCC "  "
 FCB 0


* Waveform table synthesizer
KEYGM STA ,Y
 LDX #$100
 JSR DELAY
 PSHS Y
 LDU #HRMPNT display current pointers
 JSR DSPMSG
 PULS Y,PC

KEYG LDY #HRMPNT+3 Y=string pointer
KEYG1 LDA ,Y
 PSHS A
 LDA #1
 BSR KEYGM display, cursor on
 PULS A
 BSR KEYGM display, cursor off
 JSR GETKEY
 BEQ KEYG1
KEYG2 CMPA #13 test for <ENTER>
 LBEQ DOTBLS
KEYG3 CMPA #'0 data input must
 BLO KEYG4 BE 0-9, A-F
 CMPA #'9
 BLE KEYG3A
 LDB 1,Y if we are setting volume,
 CMPB #': hex values are not allowed
 BEQ KEYG4
 CMPA #'A
 BLO KEYG4
 CMPA #'F
 BHI KEYG4
KEYG3A STA ,Y+ update string with new data
 LDA ,Y
 BEQ KEYG
 BMI KEYG3B
 CMPA #':
 BNE KEYG1
 LEAY -2,Y
KEYG3B LEAY 3,Y
 BRA KEYG1
KEYG4 CMPA #10 down arrow?
 BNE KEYG5
 LDX #GTABLE+4
KEYG4A CMPY ,X++
 BGE KEYG4A
 TST ,X
 BEQ KEYG1
 LDY -2,X
 BRA KEYG1
KEYG5 CMPA #94 up arrow?
 BNE KEYG6
 LDX #GTABLE+12
KEYG5A CMPY ,--X
 BLE KEYG5A
 TST -2,X
 BEQ KEYG1
 LDY ,X
 BRA KEYG1
KEYG6 CMPA #8 left arrow?
 BNE KEYG7
 LDA ,-Y
 CMPA #':
 BNE KEYG6A
 LEAY -1,Y
KEYG6A CMPA #' 
 BEQ KEYG6B
 LEAY 3,Y
KEYG6B LEAY -3,Y
 CMPY #HRMPNT+3
 LBLE KEYG
KEYG7 CMPA #9 right arrow?
 LBNE KEYG1
 LDA ,Y
 JMP KEYG3
GTABLE FDB 0
 FDB HRMPNT+1
 FDB HRMPNT+3
 FDB HRMPNT+16
 FDB HRMPNT+29
 FDB HRMPNT+42
 FDB HRMPNT+52
 FDB 0

KEYCOM COM BARMRK TOGGLE BAR NUMBER
 JMP SETXY DISPLAY

KEYHYP LDD MARK2 DELETE SECTION
 TSTA
 BEQ KEYHY0
 TST MARK1
 BNE KEYHY1
KEYHY0 RTS
KEYHY1 CMPD MARK1
 LBLE KEYPRA ABORT IF MARK2<MARK1
 LDX MARK1
 STX ADDRES
 LDY MARK2
KEYHY2 LDA ,Y+
 STA ,X+
 CMPY FINISH
 BLE KEYHY2
 LEAX -1,X
 STX FINISH
 CLR MARK1
 CLR MARK2
 JSR ENDMRK
 JSR PRTMEM
 JMP SETXY


CURSUP LDA YVAR MOVE CURSOR UP
 CMPA #16
 BHI CURUP1 CHECK FOR OUT-OF-BOUNDS
 LDA #16
 STA YVAR
 RTS
CURUP1 SUBA #3
 STA YVAR
RETURN RTS

CURSAD LDD ADDRES ADVANCE CURSOR
 ADDD #9
 CMPD #LIMMEM
 BGT RETURN
 CMPD FINISH
 BHI RETURN
 STD ADDRES
 LDA XVAR
 ADDA #2
 STA XVAR
 JMP TSTSCR

CURSBK LDD ADDRES BACK CURSOR UP
 SUBD #9
 CMPD #STAMUS
 BLO RETURN
 STD ADDRES
 LDA XVAR
 SUBA #2
 STA XVAR
 JMP TSTSCR

CURSDN LDA YVAR MOVE CURSOR DOWN
 CMPA #100
 BLO CURDN1
 LDA #100
 STA YVAR
 RTS
CURDN1 ADDA #3
 STA YVAR
 RTS

* Repeat section marker (option=$FC)
RPTMRK LDU #RPTMSG
 JSR DSPMSG
RPTM00 JSR GETKEY ask for required hex key
 CMPA #'0 allow key entry of 0-9
 BLO RPTM00
 CMPA #'9
 BHI RPTM00
 SUBA #'0 convert to binary
 PSHS A
 JSR INSERT
 PULS A
 LDX ADDRES
 STA 1,X
 BSR RPTMR0
RPTM0A JSR CLRMES
 LDD ADDRES
 CMPD FINISH
 BLO RPTM0B
 ADDD #9
 STD FINISH
 JSR ENDMRK
RPTM0B JSR PRTMEM
 JSR CURSAD
 JMP UPDATE
RPTMR0 LDA XVAR
 STA XVAR1
 JSR BLANK
 LDA #'9+2 put repeat character in string
 STA CNTOPM
 LDX ADDRES
 LDA #$FC store marker in music code
 STA ,X
 LDA 1,X get repeat number
 BRA PRTMR1

RPTMSG FCC "REPEAT WHICH PART?"
 FCB 0

* Part marker (option=$FB)
PRTMRK LDD ADDRES
 PSHS D
 LDD FINISH
 STD ADDRES
 LDA #$FB count number of repeat markers in music
 JSR CNTOPT
 PULS X
 STX ADDRES
 CMPA #8 can we add another (=<9)
 BLE PRTMRA
 RTS
PRTMRA JSR INSERT
 LDA #$FB store marker in music code
 STA [ADDRES]
 BSR PRTMR0
 BRA RPTM0A
PRTMR0 LDA #'9+1 put part character in string
 STA CNTOPM
 LDA #$FB
 JSR CNTOPT count number of repeat markers in music
PRTMR1 ADDA #'0 convert binary to ASCII
 STA CNTOPM+1 store count in output string
 JSR BLANK write a blank area on screen
 LDA XVAR calculate cursor position
 STA XVAR1
 LDA #22
 STA YVAR1
 JSR CURCAL X has cursor position
 LDU #CNTOPM
 CLR HIRES select hires display
 JMP GETMS1 display part marker

* Fast play
FSTP ORCC #$50 disable interrupts
 STA $FFDF select all RAM mode
 STA $FFD9 select double speed clock
 LDX #STAMUS move music code from low to high memory
 LDY #$C000 (requires 64K)
FSTPB LDA ,X+
 STA ,Y+
 CMPX #$8000 check if we are done yet
 BNE FSTPB get another byte if not zero (end of music)
 STA $FFDE select RAM/ROM mode
 LDX #STAMUS fast play: double notes
FSTP1 LDA 0,X
 BEQ FSTP5 test for end of music
 BMI FSTP4 test for note
 LSLA double note value
 CMPA #$7F test for half and whole note
 BLO FSTP1A skip if not present
 LDA #$7F change to half note code
FSTP1A STA 0,X+
 LDB #4
 STB COUNT
FSTP2 LDD ,X
 LSRA double note pitches
 RORB
 STD ,X++
 DEC COUNT
 BNE FSTP2
 BRA FSTP1
FSTP4 LEAX 9,X advance to next chord
 BRA FSTP1 loop back
FSTP5 BSR KEYP0
 PSHS A keep last key pressed
 LDX #$C000 move high memory to low
 LDY #STAMUS
 ORCC #$50 disable interrupts
 STA $FFDF select all RAM mode
FSTP6 LDA ,X+
 STA ,Y+
 CMPY #$8000
 BNE FSTP6
 STA $FFDE select RAM/ROM mode
 ANDCC #$AF enable interrupts
 STA $FFD8 set normal speed
 TST PALFLG
 BNE FSTP7
 JSR CLRMES
 JSR UPDATE
FSTP7 PULS A,PC

* Play music
KEYP TST FSTFLG
 LBNE FSTP
KEYP0 CLR $FF02
 ANDCC #$AF enable interrupts
KEYPB LDA $FF00 test keyboard
 ORA #$80
 CMPA #$FF
 BNE KEYPB wait for key off
 CLR $FF40 turn off disk motor
 JSR CLS
 LDU #TITLE display title
 LDX #$500
 JSR GETMSG
 JSR FNDPNT find last used wave table pointers
 JSR PLAY
 CLRB
 EXG B,DP
 JSR [KEYIN] test for update option
 PSHS A
 EXG DP,B
 TST PALFLG check if flag set by PLYALL
 BNE KEYPH
 CMPA #'U test for update option
 BNE KEYPG
 LDA #4
 STA XVAR
 STX ADDRES
KEYPG TST FSTFLG check for fast play
 BNE KEYPH
 JSR UPDATE
KEYPH JSR SETGRA
 JSR CLS
 CLRB
 EXG B,DP
 JSR [KEYIN]
 EXG DP,B
 PULS A,PC

KEYQ JSR CLRMES
 LDX #KEYQM1 X points to entry string
 LDB #3 B counts number of keypresses
KEYQ0 PSHS B,X
 LDU #KEYQMS quick move to bar #
 JSR DSPMSG
KEYQ1 JSR GETKEY
 CMPA #13 'ENTER'?
 BNE KEYQ1A
 LDX #KEYQM1+3
 PULS A,Y
 BRA KEYQ1B
KEYQ1A CMPA #'0 allow keys 0-9
 BLO KEYQ1
 CMPA #'9
 BHI KEYQ1
 PULS X,B
 STA ,X+ store entry in string
 DECB done yet?
 BNE KEYQ0
KEYQ1B CLRA
 CLRB
 STD TEMP
 TFR D,Y
 LDA #1 convert ASCII to binary
 BSR KEYQ6
 LDA #10
 BSR KEYQ6
 LDA #100 now temp contains
 BSR KEYQ6 2 byte number
 LDX #STAMUS look for correct bar
KEYQ2 LDA ,X
 BEQ KEYQ5A
 CMPA #$FF is it a barline?
 BEQ KEYQ3
 CMPA #$FD is it a repeat bar?
 BNE KEYQ4
KEYQ3 LEAY 1,Y are we at the
 CMPY TEMP correct bar # yet?
 BEQ KEYQ5
KEYQ4 LEAX 9,X no; move to
 BRA KEYQ2 next chord, continue
KEYQ5 STX ADDRES
 JSR SETXY
KEYQ5A JMP CLRMES
KEYQ6 LDB ,-X
 SUBB #'0
 MUL
 ADDD TEMP
 STD TEMP
 RTS

KEYQMS FCC "BAR NUMBER: "
KEYQM1 FCC "001"
 FCB 0

KEYR LDX ADDRES
 TST ,X test for option
 LBMI KEYR3 exit if an option
 LDA XVAR display rest
 STA XVAR1
 PSHS X
 JSR BLANK
 PULS X
 LDD #0 clear out voices in chord
 STD 1,X
 STD 3,X
 STD 5,X
 STD 7,X
 TST ,X see whether we already have a note length
 BNE KEYR0
 LDB NVALU set default note length
 CLRA
 PSHS X
 JSR LOOKUP
 PULS X
 STB ,X
KEYR0 CMPX FINISH add another position if at end
 BLO KEYR1
 LEAX 9,X
 STX FINISH
 JSR ENDMRK
KEYR1 JSR TBLSR0 get rest value
 LDA ,X
 DECA
 CLR TFLAG
 CMPB #3 check for triplet rest
 BEQ KEYR1A
 CMPB #5
 BEQ KEYR1A
 BRA KEYR1B
KEYR1A INC TFLAG
KEYR1B PSHS A convert to display value
 LDA XVAR calculate address of middle of staff
 STA XVAR1
 LDA #70
 STA YVAR1
 JSR CURCAL X points to display area
 CLR COUNT counter of multiple flags
 PULS A restore rest display values
 CMPA #3 test for multiple flags
 BLE KEYR2
 SUBA #3 calculate number of flags needed
 STA COUNT
 LDA #3
KEYR2 LDB #16 calculate address of rest data
 MUL
 ADDD #REST1
 TFR D,Y now Y points to rest data
 PSHS X
KEYR2A PSHS X,Y display rest
 LDB #8 counter of number of words to display
 STB COUNT0
KEYR2B LDD ,Y++
 ANDA ,X
 ANDB 1,X
 STD ,X
 LEAX $20,X move down 1 line
 DEC COUNT0
 BNE KEYR2B
 PULS Y,X
 LEAX $60,X move display pointer down
 DEC COUNT check for multiple flags
 BGE KEYR2A
 PULS X
 TST TFLAG do we need to display triplet?
 BEQ KEYR2C
 LEAX -$100,X
 JSR PUT1C
KEYR2C JSR PRTMEM
KEYR3 RTS

* set sharp flag
KEYS DEC SHARP
 CLR FLAT
 RTS 

* find next tone table pointers
KEYT JSR CURSAD
 LDX ADDRES
KEYT1 LDA ,X
 BEQ KEYT2
KEYTC CMPA #$FE
 BEQ KEYT2
 LEAX 9,X
 TST ,X
 BNE KEYT1
KEYT2 STX ADDRES
 JMP SETXY

KEYU INC UFLAG
 JMP FSTP

KEYV LDU #VCGM
 JSR DSPMSG display prompt to enter voice number
KEYV1 JSR GETVCE change voice number: get number
 SUBA #$30 change ASCII to hex
 ASLA
 STA VOICE
 JSR CLRMES clear message area
 JMP PRTVOI
VCGM FCC "VOICE (1-4):"
 FDB $B400

KEYW JSR LOWRES write screen to printer
 LDA #6
 STA SCOUNT
 CLR TITFLG clear the title print flag
 LDD ADDRES
KEYW1 STD ADDRES
 JSR SETXY update screen
 JSR SDUMP print screen
 CMPA #3 test for break
 BEQ KEYW2
 LDD ADDRES move screen forward
 ADDD #13*9 13 notes
 CMPD FINISH check for end of music
 BLO KEYW1
KEYW2 ORCC #$50 disable interrupts
 LDD #IRQ
 STD $10D
 JSR CLS
 JMP SETGRA

* exchange voices
KEYX LDU ADDRES
KEYXA TST ,U+
 BEQ KEYXC
 BMI KEYXB
 BSR KEYXA1
 BSR KEYXA1
 BRA KEYXA
KEYXA1 LDY ,U
 LDX 2,U
 STX ,U
 STY 2,U
 LEAU 4,U
 RTS
KEYXB LEAU 8,U
 BRA KEYXA
KEYXC LDU #XCGMSG
KEYXCA JSR DSPMSG
 LDX #$7000
 JSR DELAY
KEYXE JMP CLRMES
KEYPRA CLR MARK1
 CLR MARK2
 LDU #ABRMSG
 BRA KEYXCA display abort message briefly

XCGMSG FCC "EXCHANGED"
 FDB $B700

* Copy from one voice to another
KEYY JSR CLRMES
 CLR CPYMS2
 LDU #CPYMSG copy from one
 BSR KEYYR voice to another 
 PSHS D save start voice
 LDU #CPYMSG
 BSR KEYYR
 PSHS D save copy to voice
 LDU #CHRMSG
 JSR DSPMSG 
KEYY1 JSR GETKEY get vibrato depth
 CMPA #'0 must be 0-9
 BLO KEYY1
 CMPA #'9
 BHI KEYY1
 SUBA #'0 convert to binary
 LSLA multiply by 8
 LSLA
 LSLA
 TFR A,B
 CLRA
 STD TEMP
 LDX ADDRES copy starting at present cursor position
 PULS Y,U 
KEYY2 TST ,X test for chord
 BMI KEYY3 not a chord?
 BEQ KEYY4 end of music?  
 LDD ,U copy from one voice to another
 CMPD #0
 BEQ KEYY2A
 SUBD TEMP adjust for vibrato 
KEYY2A STD ,Y
KEYY3 LEAX 9,X move to next chord 
 LEAY 9,Y
 LEAU 9,U
 BRA KEYY2 
KEYY4 JMP UPDATE
KEYYR JSR DSPMSG copy one voice to another 
 JSR GETVCE get voice to copy from
 TFR A,B
 STB >CPYMS2
 SUBB #'0 convert to binary
 LSLB
 DECB B=B*2-1
 CLRA
 ADDD ADDRES
 PSHS D,X
 JSR CLRMES
 PULS D,X,PC 

CPYMSG FCC "COPY FROM VOICE "
CPYMS2 FCB 0
CPYMS3 FCC " TO "
 FCB 0
CHRMSG FCC "DEPTH OF VIBRATO?"
 FCB 0

KEYZ LEAS 2,S EXIT TO BASIC
EXIT PSHS A
 LDY FINISH
 LEAY 1,Y
 LDA #$39
 STA ,Y+
 LDX #HRMPNT MOVE TONE TABLE POINTERS
 LDB #53+65 (65=BYTES IN TITLE)
 JSR MOVED INTO MUSIC FILE AREA
 JSR STOREV CHANGE BASIC VARIABLE
 JSR LOWRES
 LDD >OLDRES RESTORE RESET VECTOR
 STD >$72
 PULS B
 CLRA
 TFR A,DP
 JMP $B4F4 RETURN TO BASIC

** end of key command subroutines

KEYN DEC NATURL SET NATURAL FLAG
 RTS
KEYSIG LDU #KSIGMS DISPLAY PROMPT TO ENTER
 LBSR DSPMSG KEY SIGNATURE
KEYSG1 LBSR GETKEY GET NUMBER (0-7)
 CMPA #13 CHECK FOR "ENTER"
 BEQ KEYSG5
 CMPA #'0-1
 BLE KEYSG1
 CMPA #'8
 BGE KEYSG1
 STA KSIGM1
 SUBA #'0 CONVERT TO BINARY
 STA KEYNUM
 LDU #KSIGMS
 LBSR DSPMSG
KEYSG2 LBSR GETKEY GET 'S' OR 'F'
 CMPA #13 CHECK FOR "ENTER"
 BEQ KEYSG5
 CMPA #'S
 BEQ KEYSG3
 CMPA #'F
 BNE KEYSG2
 LDX #SIGTBF-1
 BRA KEYSG4
KEYSG3 LDX #SIGTBS-1
KEYSG4 STX KEYTYP
 STA KSIGM1+1
KEYSG5 LBRA CLRMES

KSIGMS FCC "KEY SIGNATURE: "
KSIGM1 FCC "0S"
 FCB 0

KEYTYP RMB 2 FLAT/SHARP KEY SIGNATURE
KEYNUM RMB 1 NUMBER OF FLATS/SHARPS
SIGTBF FCB 19,31,22 TABLE OF FLAT KEY SCREEN POSITIONS
 FCB 34,25,16,28
SIGTBS FCB 28,16,25 TABLE OF SHARP KEY SCREEN POSITIONS
 FCB 34,22,31,19
TSTKEY TST NATURL IF NATURAL FLAG IS SET
 BNE TSTKY5 OR IF NO ACCIDENTALS,
 TST KEYNUM WE ARE DONE
 BEQ TSTKY5
 TST SHARP QUIT IF A SHARP OR FLAT
 BNE TSTKY5 HAS ALREADY BEEN SET
 TST FLAT
 BNE TSTKY5
 LDA YVAR GET PITCH VALUE
TSTKY0 CMPA #34 CHECK TO SEE IF WE NEED TO
 BLE TSTKY1 REDUCE PITCH TO TOP OCTAVE
 SUBA #21 RAISE PITCH BY ONE OCTAVE
 BRA TSTKY0
TSTKY1 STA TEMP SAVE REDUCED PITCH
 LDX KEYTYP X POINTS TO PROPER TABLE
 LDB KEYNUM GET NUMBER OF ACCIDENTALS
TSTKY2 LDA B,X LOOK THROUGH TABLE
 CMPA TEMP TO SEE IF THIS NOTE
 BEQ TSTKY3 SHOULD HAVE AN ACCIDENTAL
 DECB
 BNE TSTKY2
 BRA TSTKY5
TSTKY3 CMPX #SIGTBF-1
 BEQ TSTKY4
 DEC SHARP
 BRA TSTKY5
TSTKY4 DEC FLAT
TSTKY5 CLR NATURL
 RTS

HELP JSR CLS CLEAR SCREEN
 JSR LOWRES
 JSR CLRDPA
 LDX #HLPMSG-HLPMSG+$8000 X POINTS TO HELP TEXT
HLPPRT LDA #13
 STA >COUNT 13=NUMBER OF LINES/SCREEN
HLPPR1 JSR GET64 get data from upper 32K memory
 BEQ HLPDNE IF =0, DONE
 JSR OUTKEY
 CMPA #13 IF 'CR', DECREMENT LINES
 BNE HLPPR1
 DEC >COUNT ARE WE AT THE END OF PAGE?
 BNE HLPPR1
 BSR HLPWAI
 BRA HLPPRT
HLPDNE LDA #13 DONE
 JSR OUTKEY
 BSR HLPWAI
 JSR SETDPA
 JSR CLRMES
 JMP SETGRA RESTORE GRAPHICS

HLPWAI LDU #HLPWMS ASK FOR KEYPRESS
HLPWA1 LDA ,U+
 JSR OUTKEY
 TST ,U
 BNE HLPWA1
HLPWA2 SYNC
 JSR [KEYIN] WAIT FOR KEYPRESS
 BEQ HLPWA2
 PSHS X
 JSR CLS
 PULS X,PC

HLPWMS FCB 13
 FCC "PRESS ANY KEY TO CONTINUE...    "
 FCB 0

KEYO JSR CLS
 JSR LOWRES
 LDX #OPTMSG-HLPMSG+$8000
KEYOA JSR GET64
 BEQ KEYO1
 JSR OUTPUT
 BRA KEYOA
 JSR CLRDPA
KEYO1 SYNC
 JSR [$A000]
 BEQ KEYO1
 JSR SETDPA
 CMPA #3 test for BREAK
 BEQ KEYO11
 CMPA #'F check for fast play
 BNE KEYO2
 DEC FSTFLG
KEYO2 CMPA #'L check for slow play
 BNE KEYO3
 CLR FSTFLG
KEYO3 CMPA #'S check for STEREO PAK
 BNE KEYO4
 LDB #$70
 STB MAINST+2
 INCB
 INCB
 STB MAINS1+2
KEYO4 CMPA #'O check for ORCH-90/CC
 BNE KEYO5
 LDB #$7A
 STB MAINST+2
 INCB
 STB MAINS1+2
KEYO5 CMPA #'P check for play with enter
 BNE KEYO6
 INC EPLFLG
KEYO6 CMPA #'N check for no play with enter
 BNE KEYO7
 CLR EPLFLG
KEYO7 CMPA #'T check for tape I/O
 BNE KEYO8
 DEC TAPEIO
KEYO8 CMPA #'D check for disk I/O
 BNE KEYO11
 CLR TAPEIO
KEYO11 JSR SETGRA
 JMP CLS

*Get data from upper 32K memory
*Entry: register X points to data
* Exit: register A contains data

GET64 ORCC #$50 disable interrupts
 STA $FFDF select all RAM mode
 LDA ,X+ GET DATA TO DISPLAY
 STA $FFDE select RAM/ROM mode
 ANDCC #$AF enable interrupts
 RTS
