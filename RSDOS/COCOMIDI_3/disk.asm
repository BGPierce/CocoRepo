* DISK/TXT - part of CoCoMIDI 3* (C) 1988 by Lester Hands** These disk routines use only two ROM entry points:* $ADC6 in the Basic interpreter, and the DSKCON* routine. This should maximize compatibility.DEFDRIVE EQU $95A DOS default drive #DBUFFER EQU $989 buffer for direct diskDPG FCB $0E direct pageDBUFPTR FDB DBUFFER ptr to position in bfrDBRDFLG FCB 0 =0 if no sector readSECTOR FCB 0MAXSECT FCB 0 max # of sectors in fileFILENAME FCC "        /CM3:0",0* save current music to disk* LOCAL L_CNTSave PROC* get the filename LEAX a@,PCR IFEQ DEMO LEAX NOTAVAIL,PCR ENDC CALL SetBox,REGX IFEQ DEMO *** CONDITIONAL LBSR getchar ENDC  *** END CONDITIONAL IFNE DEMO *** CONDITIONAL CALL BoxInp,REGX CMPB #BREAK LBEQ Z@ LDA FILENAME+13,PCR get drive # SUBA #'0 convert to binary LBMI Z@ CMPA #9 LBHI Z@ STA DSKDRV STA DEFDRIVE* open the file, checking for already existing file LEAX FILENAME,PCR LBSR Open LBSR LOF if length of file is CMPD #0 not zero, then first BEQ B@ delete it LBSR Close LBSR ClrBox LEAX f@,PCR ask user if he wants CALL SetBox,REGX to over-write fileC@ LBSR getchar CMPA #'Y LBNE Z@ LEAX FILENAME,PCR LBSR Kill LBSR Open* write the headers first to the disk fileB@ CALL FindEnd,BUFFER1 SUBD BUFFER1 ADDD #2 STD j@+2,PCR LEAX FHEADR,PCR main header ADDD #438 STD 6,X CALL Write,REGX,#8 LEAX 8,X tempo header PSHS X CALL Divide,#9840,CPERIOD PULS X STD 8,X CALL Write,REGX,#10 LEAX 10,X status header CALL Write,REGX,#8 CALL Write,#TFLAGS,#10 LEAX 8,X comment header CALL Write,REGX,#8 CALL Write,#COMMENTS,#130 LEAX 8,X events header CALL Write,REGX,#8 LDD j@+2 STD ARG2 CALL Write,BUFFER1,ARG2 LEAX 8,X messages header CALL Write,REGX,#8 LEAX MESSAGES,PCR CALL Write,REGX,#264 LBSR Close ENDC  *** END CONDITIONALZ@ LBSR ClrBox CLRA CLRB ENDP* IFNE DEMO *** CONDITIONALa@ FDB 4,5,24,5,b@,d@b@ FDB 2,2,c@,0 text stringc@ FCC "SAVE:",0d@ FDB 8,2,FILENAME,0,0 input string*f@ FDB 6,5,20,5,g@,0g@ FDB 2,2,h@,0 text stringh@ FCC "OVER-WRITE FILE?",0 ENDC  *** END CONDITIONAL* IFEQ DEMO *** START CONDITIONALNOTAVAIL FDB 4,5,24,5,b@,0b@ FDB 2,2,c@,0 text stringc@ FCC "NOT AVAILABLE:  DEMO",0 ENDC  *** END CONDITIONAL*FHEADR FCC "CM30" first header in file FDB 0,0  length of remaining file FCC "TMPO" tempo header (BPM) FDB 0,2  # bytes in data FDB 100  the actual tempo FCC "STAT" status header FDB 0,10  status bytes for 10 FCC "CMNT" comment header FDB 0,130  13 bytes/comment FCC "EVNT" event headerj@ FDB 0,0  # bytes to follow FCC "MSGS" messages header FDB 0,256* load disk file into memory* LOCAL L_CNT,L_SEC,L_PTRLoad PROC LBSR GetDrive CMPB #BREAK LBEQ Z@ STB FILENAME+13,PCR SUBB #'0 LBMI Z@ CMPB #9 LBHI Z@ STB DSKDRV STB DEFDRIVE set default drive #* get a disk directory and ask for filename LEAX FILENAME+9,PCR CALL Dir,REGX LDA #15 STA YPOS CLR XPOS LBSR MOVE LBSR ERALIN LEAX a@,PCR LBSR PUTS LEAX FILENAME,PCR CALL GetStr,REGX,#8 CMPB #BREAK LBEQ Z@* open the file, check for file length of zero LEAX FILENAME,PCR LBSR Open LBSR LOF CMPD #0 if length of file is BNE B@ zero, then it doesn't LBSR Close really exist; delete LEAX FILENAME,PCR LBSR Kill LEAX f@,PCR CALL SetBox,REGX LBSR getchar LBRA Z@* read the file into memoryB@ PSHS A LDA #$AF STA DISKLOAD PULS A EXG B,A convert sector cnt SUBD #1 STD ARG2 to byte count CALL Read,BUFFER1,ARG2 LBSR Close LBSR GetDMem CLR DISKLOADZ@ LDA #1 request screen update ENDP*a@ FCC "  LOAD:",0*f@ FDB 3,5,25,5,g@,0g@ FDB 2,2,h@,0 text stringh@ FCC "ERROR: FILE NOT FOUND",0* load a file as requested by a system link event* returns -1 when error occurs, else 0*LoadLink PROC S_PTR LDX S_PTR,S LDA 2,X CMPA #$F2 BEQ A@ LBSR SndErr BRA Z@A@ LDA 3,X LDB #16 MUL LEAX MESSAGES,PCR LEAX D,X* open the file, check for file length of zero LBSR Open LBSR LOF CMPD #0 if length of file is BNE B@ zero, then it doesn't LBSR Close really exist; delete LBSR Kill LBSR SndErr LDD #$FFFF BRA Z@* read the file into memoryB@ PSHS A LDA #$AF STA DISKLOAD PULS A EXG B,A convert sector cnt SUBD #1 STD ARG2 to byte count CALL Read,BUFFER1,ARG2 LBSR Close LBSR GetDMem CLRA CLRBZ@ CLR DISKLOAD ENDP* get the disk memory--move data to correct positions* LOCAL L_END,L_STGetDMem PROC* check for valid file LEAX FHEADR,PCR look for required LDY BUFFER1 file header LDD ,X++ CMPD ,Y++ BNE A@ LDD ,X++ CMPD ,Y++ BEQ C@A@ LDD #$FFFF not a valid header, STD [BUFFER1] so clear buffer LBSR SndErr BRA D@* this section ignores data structures just so we* we can get the stuff into memory quickly!C@ LDX BUFFER1 LDD 16,X get tempo LBSR CPCalc STD CPERIOD LEAY 26,X get status bytes LDU #TFLAGS LDB #10G@ LDA ,Y+ STA ,U+ DECB BNE G@ LEAY 44,X get comments LDU #COMMENTS LDB #130E@ LDA ,Y+ STA ,U+ DECB BNE E@ LEAX 182,XD@ CALL FindEnd,REGX STD L_END,S STX L_ST,S TFR D,X LEAX 2,X check for messages LDD ,X++ CMPD #'MS BNE B@ LDD ,X++ CMPD #'GS BNE B@ LEAX 4,X skip block length CLRB LEAY MESSAGES,PCRF@ LDA ,X+ STA ,Y+ DECB BNE F@B@ LBSR ClrBlock LDD L_END,S STD ARG2 LDX L_ST,S CALL MoveDown,REGX,ARG2,BUFFER1 CALL FindEnd,BUFFER1 ADDD #EVNSIZE STD BUF1END ADDD #EVNSIZE STD BUFFER2 LDD #$FFFF STD [BUFFER2]Z@ ENDP* get number of sectors in current file* returns length in D*LOF PSHS X LEAX a@,PCR LBSR BASIC LDB $600 CLRA PULS X,PC*a@ FCB $92 POKE token FCC "1536," FCB $FF,$A5 LOF FCC "(1)",0* open direct access file* file name ptr. (max of 12 characters) in X*Open PSHS X,Y LEAY b@,PCR LDB #12A@ LDA ,X+ STA ,Y+ BEQ B@ DECB BNE A@B@ STA SLOW LEAX a@,PCR LBSR BASIC LDD #DBUFFER zero the direct access STD DBUFPTR disk buffer LDA #1 STA SECTOR LBSR LOF STB MAXSECT CLR DBRDFLG PULS X,Y,PC*a@ FCB $99 OPEN token FCC \"D",#1,"\b@ FCC \            "\,0* erase a file (display disk directory first)*FKILL PSHS X IFEQ DEMO *** CONDITIONAL LEAX NOTAVAIL,PCR CALL SetBox,REGX LBSR getchar ENDC  *** END CONDITIONAL IFNE DEMO *** CONDITIONAL LDA DEFDRIVE get default drive # ADDA #'0 convert to ASCII STA c@,PCR LEAX b@+9,PCR CALL Dir,REGX LDA #15 STA YPOS CLR XPOS LBSR MOVE LBSR ERALIN LEAX a@,PCR LBSR PUTS LEAX b@,PCR CALL GetStr,REGX,#8 CMPB #BREAK LBEQ Z@ LDA c@,PCR SUBA #'0 STA DSKDRV LEAX b@,PCR LBSR Open LBSR Close LBSR Kill ENDC  *** END CONDITIONALZ@ LBSR ClrBox LDB #1 PULS X,PC* IFNE DEMOa@ FCC "  KILL:",0b@ FCC "        /CM3:"c@ FCC "1",0 ENDC* delete a file* file name ptr. (max of 12 characters) in X*Kill PSHS X,Y LEAY b@,PCR LDB #12A@ LDA ,X+ STA ,Y+ BEQ B@ DECB BNE A@B@ STA SLOW LEAX a@,PCR LBSR BASIC LBSR DiskOff LBSR SetSpd PULS X,Y,PC*a@ FCB $D2,$22 KILL tokenb@ FCC \            "\,0* turn the disk drive motor off*DiskOff STA SLOW ORCC #$50 disable FIRQ,IRQ STA ROM_ON CLR $FF40 SYNC  wait for NMI STA ROM_OFF ANDCC #$EF enable IRQ RTS* Read S_CNT number of bytes from disk into* memory pointed by S_PTR.*Read PROC S_PTR,S_CNT LDY S_CNT,S BEQ Z@ TST DBRDFLG BNE C@ LBSR ReadRaw INC DBRDFLGC@ LDU S_PTR,S LDX DBUFPTRA@ LDA ,X+ STA ,U+ CMPX #$A89 BLO B@ LBSR ReadRaw LDX #$989B@ LEAY -1,Y BNE A@ STX DBUFPTRZ@ ENDP IFNE DEMO* Write S_CNT number of bytes to disk from* memory pointed to by S_PTR.*Write PROC S_PTR,S_CNT LDY S_CNT,S BEQ Z@ LDX S_PTR,S LDU DBUFPTRA@ LDA ,X+ STA ,U+ CMPU #$A89 BNE B@ LBSR WriteRaw LDU #$989B@ LEAY -1,Y BNE A@ STU DBUFPTRZ@ ENDP ENDC* Read a sector from a direct access file* Current sector number used* Data read into direct access buffer* Sector number incremented*ReadRaw PSHS X LDA SECTOR CMPA MAXSECT BHI Z@ CLRA LDB SECTOR LEAX b@,PCR LBSR BINDEC LEAX a@,PCR LBSR BASIC INC SECTORZ@ PULS X,PC                                                                E*a@ FCB $C4,$23,$31,$2C GET#1,b@ FCB $31,0,0,0 space for 3 digits IFNE DEMO *** CONDITIONAL* Write a sector to a direct access file* Data is already in buffer, current sector is used.* Sector number incremented*WriteRaw PSHS X CLRA LDB SECTOR LEAX b@,PCR LBSR BINDEC LEAX a@,PCR LBSR BASIC INC SECTOR PULS X,PC*a@ FCB $C5,$23,$31,$2C PUT#1,b@ FCB $31,0,0,0 space for 3 digits ENDC  *** END CONDITIONAL* Close all disk files*Close PSHS X IFNE DEMO *** CONDITIONAL LDD DBUFPTR see if there is any- CMPD #DBUFFER thing in the buffer BEQ A@ LBSR WriteRaw ENDC  *** END CONDITIONALA@ LEAX a@,PCR LBSR BASIC LBSR DiskOff turn drive motor off LBSR SetSpd PULS X,PC*a@ FCB $9A CLOSE token FCC "#1",0* execute a tokenized Basic string pointed to by X.* ROMs are enabled; it is assumed that all interrupt* routines are in RAM to prevent memory conflicts.*BASIC PSHS X,Y,U,DP CLRA EXG A,DP STA DPG,PCR STA ROM_ON STX $A6 LDA ,X ANDCC #$FE JSR $ADC6 STA ROM_OFF PULS X,Y,U,DP,PC* error handling routine for ROM errors*Error ORCC #$50 LDS #STACK LDA DPG,PCR TFR A,DP PSHS B B=error code LDD #DBUFFER clear disk buffer STD DBUFPTR LBSR Close LBSR ClrBox PULS B LSRB CLRA LEAX d@,PCR LBSR BINDEC LEAX a@,PCR CALL SetBox,REGXA@ LBSR getchar LBSR ClrBox JMP Reset*a@ FDB 9,5,14,5,b@,0b@ FDB 2,2,c@,0c@ FCC "ERROR #"d@ FCC "   ",0DSKOPC EQU $EA DSKCON variablesDSKDRV EQU $EB driveDSKTRK EQU $EC trackDSKSEC EQU $ED sectorDSKBUF EQU $EE buffer addressDSKSTA EQU $F0 error code (status) LOCAL L_CNT,L_FILDir PROC S_EXT LDX S_EXT,S transfer extension LEAY f@,PCR to title string LDD ,X++ STD ,Y++ LDA ,X STA ,Y LBSR CLS LEAX d@,PCR LBSR PUTS STA SLOW LDA #3 STA L_CNT,S CLR L_FIL,S* read a directory sector from the disk LDA DEFDRIVE STA >DSKDRV LDA #3 STA >DSKSEC select sector 3A@ LDA #2 set read operation STA >DSKOPC LDA #17 STA >DSKTRK select track 17 LDD #$600 reset buffer pointer STD >DSKBUF set buffer to $600 LBSR DSKCON TST >DSKSTA test for errors LBNE X@ exit if error found* print the filenames LDX #$600B@ LDA 0,X BEQ D@ test for erased file CMPA #$FF test for last directory entry BEQ H@ LDB #8 LDY S_EXT,SC@ LDA B,X test for the right extension CMPA ,Y+ Y points to FILENAME BNE D@ INCB CMPB #11 BNE C@ LDA #32 valid filename, so LBSR ChrOut print it LDA #32 LBSR ChrOut CLR 8,X put an end of string PSHS X LBSR PUTS marker and print name PULS X INC L_FIL,S DEC L_CNT,S BNE D@ LDA #13 LBSR ChrOut LDA #3 STA L_CNT,SD@ LEAX 32,X point to next filename CMPX #$700 test for end of buffer BLO B@* at end of buffer, prepare to read another sectorE@ LDA >DSKSEC increment sector number INCA CMPA #17 check whether we are at the end of directory BHI H@ STA >DSKSEC BRA A@H@ TST L_FIL,S BNE I@ LEAX e@,PCR if no files, say so LBSR PUTS* read in the FAT sector to see how much free spaceI@ LBSR GETPOS TST XPOS BEQ J@ LDA #13 LBSR ChrOutJ@ LDA #2 STA >DSKSEC select sector 2 LDA #2 set read operation STA >DSKOPC LDA #17 STA >DSKTRK select track 17 LDD #$0600 STD >DSKBUF set buffer to $600 LBSR DSKCON TST >DSKSTA test for errors LBNE X@ exit if error found LDX #$0600 CLRBF@ LDA ,X+ CMPA #$FF is granule free? BNE G@ INCB  read enough for 40G@ TST DR40TRK BEQ K@ CMPX #$0644 BLO F@ BRA L@K@ CMPX #$0678 track disks BLO F@L@ CLRA LEAX c@,PCR LBSR BINDEC LEAX b@,PCR LBSR PUTS LDA #13 LBSR ChrOutZ@ LBSR DiskOff turn disk motor off LBSR SetSpd ENDPX@ LDB #40 DOS error code (I/O) LBRA Error*a@ FCC "  ",0b@ FCC "  FREE SPACE: "c@ FCC "   ",0d@ FCC "  DIRECTORY OF "f@ FCC "CM3 FILES:",13,13,0e@ FCC "  NO FILES",0DSKCON CLRA TFR A,DP STA ROM_ON JSR [$C004] STA ROM_OFF LDA DPG TFR A,DP RTS* ask user for drive number* returns drive number (ASCII) in B* if BREAK is pressed, returns 3 in B*GetDrive PSHS X LEAX a@,PCR CALL SetBox,REGX CALL BoxInp,REGX LBSR ClrBox CMPB #3 BEQ Z@ LDB c@,PCRZ@ PULS X,PC*a@ FDB 10,5,12,5,*+4,b@ FDB 2,2,*+4,0 text string FCC "DRIVE #",0b@ FDB 9,2,c@,0,0 input stringc@ FCC "0",0* end of file: DISK/TXT