* CM3/TXT* CoCo MIDI 3* (C) 1988 by Lester Hands, all rights reserved* Assumptions about programming style:* - All subroutines preserve registers X,Y,U unless*   otherwise stated (rare exceptions!)* - Passing of parameters is generally done via the*   CALL macro; if a register is used, only X may*   be used!* - Return value from a subroutine is passed in*   register D; rarely in another register (almost*   always register X).* - A memory map with the full 64K is generally*   assumed; subroutines that enable the ROMs must*   disable them as quickly as possible. INCL CONTROLSLOW EQU $FFD8 clock speed hardwareFAST EQU $FFD9 addressesROM_ON EQU $FFDE enable ROMs IF DEBUG=0ROM_OFF EQU $FFDE enable 64K RAM ENDC IF DEBUG=1ROM_OFF EQU $FFDF ENDCINT_ON EQU $AF interrupts enableINT_OFF EQU $50 interrupts disableLEFT EQU 8 cursor key valuesRIGHT EQU 9DOWN EQU 10UP EQU 94ENTER EQU 13SHFTUP EQU 95SHFTDOWN EQU 91SHFTRGHT EQU 93SHFTLEFT EQU 21BREAK EQU 3* MIDI filter bit definitionsMF_NOTOF EQU 1 note offMF_NOTON EQU 2 note onMF_KEYPR EQU 4 key pressureMF_CTRL EQU 8 control changeMF_PROG EQU $10 program changeMF_CHPRE EQU $20 channel pressureMF_PIWHE EQU $40 pitch wheelEVNSIZE EQU 8 # bytes in an event* event structure* 2 bytes: event time ($FFFF=end)* 3 bytes: MIDI event* 2 bytes: note length* 1 byte:  track number INCL MACROS TITL1 "CM3/TXT"* this is the pointer used by the [$A002] routine* to point to the cursor*CURSADR EQU $88 cursor position address* A 256 byte buffer used by the FIRQ record routine* Same area as the disk buffer, but should cause* no conflicts. Also used as a general purpose* temporary storage area.*MIDIBUF EQU $0600 MIDI input buffer IFNE DEBUG IFNE TAPE ORG $0182 JMP START ENDC ENDC ORG $0E00 SETDP $0E JMP START* hardware addresses put here so they can be patchedMSTAT FDB $FF6E ACIA control/status registerMDATA FDB $FF6F ACIA data register* pointers to the two buffersBUFFER1 FDB BUF1ADRBUF1END FDB BUF2ADR-EVNSIZEBUFFER2 FDB BUF2ADRBUF2END FDB TOPMEM* used by the record/play routinesPLAYPTR FDB BUF1ADR pointer to MIDI buffer for play routineRECPTR FDB BUF2ADR ptr to record bufferMSTATUS FCB 0 MIDI running status byteMIDISTAT FCB 0 MIDI status byteMCOUNT FCB 0 number of bytes in messageDONE FCB 0 flag for playbackMFILTER FCB MF_NOTOF MIDI filterFILT_FLG FCB 0 filter flagTRAK_FLG FCB 0 track filter flagTRACK FCB 0 current edit/record trackKEY FCB 'S display notes as sharp/flatLINKPTR FDB 0 <>0 when a file linkMBUFPTR FDB MIDIBUF input buffer pointer* the slave flag = 0 when in master mode;*                = 1 in slave but not started*                = -1 when start or continue receivedSLAVE FCB 0 <>1 when in slave modeSTOP FCB 0 <>0 when MIDI stop receivedSNGPOSPT FDB 0 song position pointerPOSNFLAG FCB 0 <>0 when song pos. calculatedCLOCK FDB 0 master clock (ticks)CPERIOD FDB 98 clock periodCPCOUNT FDB 98 HIRQ ints/tickCLOCKslv FDB 0 slave clockCPCslave FDB 0 slave CP counterMETRONOM FCB 24METCOUNT FCB 0 clocks/beatTICKS FCB 4 # ticks to make 1 clockTICKslav FCB 0TIMEBASE FDB 96 ticks/beatMEASURE FDB 96*4 ticks/measureSYNCFLAG FCB 1 <>0 when ok to playBAR FCB 4 number of beats in a barBAR_CNT FCB 0 current bar # (play)BEAT_CNT FCB 0 current beat # (play)IRQACTIV FCB 0 >0 when IRQ already activeSTROBE FCB 0 raw keyboard inputCLOKFLAG FCB 1 >0 when MIDI clock onKEYINP FCB $FF value of $FF00BLK_STRT FDB $FFFF block markersBLK_END FDB $FFFF (actual times)PNCH_FLG FCB 0 =1 when punch in/out* SPPFL=$FFFF when SPP should not be sent* otherwise, it is the number of 60ths of a second* that should elapse between SPP and continue mssg.SPP_FL FDB 0 song pos'n ptr. flagYPOS FCB 0 vertical positionXPOS FCB 0 horizontal positionTINVERT FCB 0 >0 if text invertKEYTAB RMB 17,0 used by INKEY* used by MACROSARG1 FDB 0ARG2 FDB 0ARG3 FDB 0ARG4 FDB 0* used by Divide routine--the remainderREMAIN FDB 0MPI_SLOT FCB $33* play note buffer* Storage area for notes being played.* First word is the note length count.* Second word is the status byte and pitch.* When a count word is zero, it is available for a* new note.*PLNTBUFR RMB 64 space for 16 notesPLNTBUFE EQU * buffer end MSG "END OF DIRECT VARIABLES=",** flag for status/comment fields on main screen* =0 for status, =1 for comment field.SCFIELD FCB 0COMMENTS FCC "            ",0 FCC "            ",0 FCC "            ",0 FCC "            ",0 FCC "            ",0 FCC "            ",0 FCC "            ",0 FCC "            ",0 FCC "            ",0 FCC "            ",0* A set of 10 bytes used as track flags* bit 8: 1=on 0=off (mute)* bit 7: 1=solo (mute all tracks not solo'd)*TFLAGS RMB 10,0* System "messages": 16 bytes long, zero terminator* first byte=0 if available*MESSAGES RMB 16,0 RMB 16,0 RMB 16,0 RMB 16,0 RMB 16,0 RMB 16,0 RMB 16,0 RMB 16,0 RMB 16,0 RMB 16,0 RMB 16,0 RMB 16,0 RMB 16,0 RMB 16,0 RMB 16,0 RMB 16,0DR40TRK FCB 0 =0 if 40 track drivesSTARTUP FDB 0 =$5AF0 if already startedDISKLOAD FCB 0 =$AF if error on load fileSTART LBSR TITLEReset NOP LDS #STACK LBSR SETUP LBSR DiskOff LDD STARTUP CMPD #$5AF0 BNE A@ LDA DISKLOAD CMPA #$AF BNE A@ LBSR GetDMem CLR DISKLOADA@ LBSR SetSpd LBSR CLS COM TINVERT LEAX a@,PCR LBSR PUTS CLR TINVERT LBSR PUTSB@ LBSR StatusC@ LBSR getchar wait for selection LBSR SelTrk CMPD #1 BEQ C@ TFR A,B LEAX b@,PCR PSHS X LBSR DoCmd LEAS 2,S CMPD #0 BEQ B@ BRA A@*a@ FCC "      FILE PERFORM TRACK        ",0 FCB 13 FCC " TRACK SIZE STATUS    COMMENT",13 FCC " ----- ---- ------ ------------",0*b@ FCB 'F FDB M1FILE FCB 'P FDB M1PERF FCB 'T FDB M1TRAK FCB 'H FDB RAW FCB 0DoMenu PROC S_MPTR,S_CPTR CALL SetMenu,(S_MPTR,S) LBSR getchar TFR A,B LBSR ClrBox CMPA #BREAK BEQ X@ LDX S_CPTR,S PSHS X LBSR DoCmd LEAS 2,S BRA Z@X@ CLRA CLRBZ@ ENDPM1FILE PROC LEAX a@,PCR STX ARG1 LEAX f@,PCR CALL DoMenu,ARG1,REGX ENDP*a@ FDB 4,1,10,7,*+4,0 FDB 2,0,b@,*+2 FDB 2,1,c@,*+2 FDB 2,2,g@,*+2 FDB 2,3,d@,*+2 FDB 2,4,h@,*+2 FDB 2,5,e@,0b@ FCC "LOAD",0c@ FCC "SAVE",0g@ FCC "KILL",0d@ FCC "CONFIG",0h@ FCC "ABOUT",0e@ FCC "EXIT",0*f@ FCB 'L FDB Load FCB 'S FDB Save FCB 'K FDB FKILL FCB 'C FDB Config FCB 'A FDB About FCB 'E FDB EXIT FCB 0M1PERF PROC LEAX a@,PCR STX ARG1 LEAX i@,PCR CALL DoMenu,ARG1,REGXZ@ ENDP*a@ FDB 9,1,14,8,*+4,0 FDB 2,0,b@,*+2 FDB 2,1,c@,*+2 FDB 2,2,d@,*+2 FDB 2,3,e@,*+2 FDB 2,4,f@,*+2 FDB 2,5,g@,*+2 FDB 2,6,h@,0b@ FCC "RECORD",0c@ FCC "PLAY",0d@ FCC "KILL NOTES",0e@ FCC "CLOCK",0f@ FCC "BEATS/BAR",0g@ FCC "FILTER",0h@ FCC "MONITOR",0*       i@ FCB 'R FDB RECORD FCB 'P FDB PLAY FCB 'K FDB KillNote FCB 'C FDB SetClock FCB 'B FDB SetMeasr FCB 'F FDB SetFiltr FCB 'M FDB MONITOR FCB 0M1TRAK PROC LEAX a@,PCR STX ARG1 LEAX p@,PCR CALL DoMenu,ARG1,REGX ENDP*a@ FDB 17,1,15,6,*+4,0 FDB 2,0,b@,*+2 FDB 2,1,c@,*+2 FDB 2,2,d@,*+2 FDB 2,3,e@,*+2 FDB 2,4,f@,0b@ FCC "EDIT",0c@ FCC "MARK ALL",0d@ FCC "KEY",0e@ FCC "TRACK KILL",0f@ FCC "CLEAR ALL",0*p@ FCB 'E FDB EDIT FCB 'M FDB MarkAll FCB 'K FDB SetKey FCB 'T FDB KILL FCB 'C FDB ClearAll FCB 0* display the status of all 10 tracks* LOCAL L_TRK,L_B2 CHAR L_CNT,20 CHAR L_STR,6Status PROC CLRA CLRB STD L_TRK,S* clear out the count table LEAX L_CNT,S LDB #20A@ CLR ,X+ DECB BNE A@* count the events in each track LDX BUFFER1B@ LDD 0,X check for end CMPD #$FFFF BEQ C@ LDB 7,X get the track # CMPB #9 exclude tracks>9 BHI F@ LSLB LEAY L_CNT,S LEAY B,Y LDD ,Y ADDD #1 STD ,YF@ LEAX EVNSIZE,X BRA B@C@ LDA #4 STA YPOS* display track numberD@ LDA #3 STA XPOS LBSR MOVE LDA L_TRK+1,S ADDA #'0 LBSR ChrOut* display track size LDA #7 STA XPOS LBSR MOVE LDD L_TRK,S LSLB LEAX L_CNT,S LDD B,X LEAX L_STR,S LBSR BINDEC LBSR PUTS* display track status LDD L_TRK,S LBSR PrtStat* display comment LDD L_TRK,S LBSR PrtCmnt* loop back for next track INC YPOS INC L_TRK+1,S LDB L_TRK+1,S CMPB #10 BLO D@* display memory size LDA #15 STA YPOS CLR XPOS LBSR MOVE LEAX a@,PCR LBSR PUTS CALL FindEnd,BUFFER2 STD L_B2,S LDD BUF2END SUBD L_B2,S STD ARG1 CALL Divide,ARG1,#EVNSIZE LEAX L_STR,S LBSR BINDEC LBSR PUTS LDA #'+ LBSR ChrOut LDD L_B2,S SUBD BUFFER2 STD ARG1 CALL Divide,ARG1,#EVNSIZE LEAX L_STR,S LBSR BINDEC LBSR PUTS* display block marker times LDA #14 STA YPOS LDA #22 STA XPOS LBSR MOVE LDD BLK_STRT CMPD #$FFFF BEQ E@ LEAX b@,PCR LBSR PUTS CALL PrtTime,BLK_STRTE@ LDD BLK_END CMPD #$FFFF BEQ Z@ LDA #15 STA YPOS LDA #22 STA XPOS LBSR MOVE LEAX c@,PCR LBSR PUTS CALL PrtTime,BLK_ENDZ@ ENDP*a@ FCC "FREE:",0b@ FCC "B-",0c@ FCC "E-",0* print track MUTE/PLAY information, given track* number in register D*PrtStat PSHS B ADDB #4 STB YPOS LDA #13 STA XPOS LBSR MOVE LDX #TFLAGS PULS B restore track # TST SCFIELD check for the right BNE A@ column CMPB TRACK is this the current BNE A@ track? COM TINVERTA@ LDA B,X BMI B@ LEAX a@,PCR BRA C@B@ CMPA #$C0 check for SOLO BLO D@ LEAX c@,PCR BRA C@D@ LEAX b@,PCRC@ LBSR PUTS CLR TINVERTZ@ RTS*a@ FCC "MUTE",0b@ FCC "PLAY",0c@ FCC "SOLO",0* print the comment for the track # in register B*PrtCmnt PSHS B save track ADDB #4 STB YPOS LDA #19 STA XPOS LBSR MOVE PULS B restore track TST SCFIELD BEQ A@ CMPB TRACK BNE A@ COM TINVERTA@ LDA #13 length of each comment MUL LDX #COMMENTS LEAX D,X LBSR PUTS CLR TINVERT RTS* part of main loop: select the current track* the keyboard input is in register A* LOCAL L_DSelTrk PROC STD L_D,S LDB TRACK CMPA #UP BNE B@ TSTB BEQ Z@ DEC TRACK BRA D@B@ CMPA #DOWN BNE C@ CMPB #9 BEQ Z@ INC TRACK BRA D@C@ CMPA #LEFT BNE A@ TST SCFIELD BEQ Z@ CLR SCFIELD BRA D@A@ CMPA #RIGHT BNE F@ TST SCFIELD BNE Z@ INC SCFIELD BRA D@F@ CMPA #ENTER BNE Z@ TST SCFIELD BEQ G@ LBSR EdCmnt BRA E@G@ LDX #TFLAGS toggle mute/play flag LDA B,X CMPA #$80 BLO H@ CMPA #$C0 BLO J@ EORA #$C0 BRA I@J@ ORA #$40 BRA I@H@ EORA #$80I@ STA B,X BRA E@D@ CLRA LBSR PrtStat LBSR PrtCmntE@ CLRA LDB TRACK LBSR PrtStat LBSR PrtCmnt LDD #1 action taken flag STD L_D,S change D return valueZ@ LDD L_D,S ENDP* edit a track comment; track number in register B*EdCmnt PROC PSHS B ADDB #4 STB YPOS LDB #19 STB XPOS LBSR MOVE PULS B restore track number LDA #13 length of each comment MUL ADDD #COMMENTS STD ARG1 CALL GetStr,ARG1,#12 ENDP* set up correct configuration* LOCAL L_DEFConfig PROC LEAX a@,PCR CALL SetBox,REGX CALL BoxInp,REGX LBSR ClrBox CMPB #BREAK BEQ Z@ LBSR CnvCnfig IFNE TAPE IFNE DEMO *** CONDITIONAL LEAX r@,PCR CALL SetBox,REGX LBSR getchar LBSR ClrBox CMPA #'Y BNE Z@ LDA DEFDRIVE STA L_DEF,S LEAX s@,PCR LBSR Open LEAX h@,PCR CALL Write,REGX,#40 LBSR Close LDA L_DEF,S STA DEFDRIVE ENDC  *** END CONDITIONAL ENDCZ@ CLRA CLRB ENDP*a@ FDB 2,2,26,13,*+4,g@ FDB 2,2,b@,*+2 text strings FDB 2,4,c@,*+2 FDB 2,5,d@,*+2 FDB 2,6,e@,*+2 FDB 2,7,f@,*+2 FDB 2,8,n@,*+2 FDB 2,9,o@,*+2 FDB 2,10,q@,0b@ FCC "NOTES OFF:",0c@ FCC "40 TRACK DRIVE?:",0d@ FCC "BACKGROUND COLOR:",0e@ FCC "FOREGROUND COLOR:",0f@ FCC "BORDER COLOR:",0n@ FCC "COLOR/MONOCHROME:",0o@ FCC "SONG POSN POINTER:",0q@ FCC "MULTIPAK SLOT #:",0g@ FDB 3,3,h@,*+4,0 input strings FDB 21,4,i@,*+4,*-18 FDB 21,5,j@,*+4,*-18 FDB 21,6,k@,*+4,*-18 FDB 21,7,l@,*+4,*-18 FDB 21,8,m@,*+4,*-18 FDB 21,9,p@,*+4,*-18 FDB 21,10,t@,0,*-18h@ FCC "B0 7B 40 B0 79 00 FF",0i@ FCC "Y",0j@ FCC "63",0k@ FCC "0 ",0l@ FCC "63",0m@ FCC "C",0p@ FCC "N  ",0t@ FCC "3",0* IFNE DEMO *** CONDITIONALr@ FDB 5,5,22,5,*+4,0 FDB 2,2,*+4,0 FCC "SAVE THESE VALUES?",0*s@ FCC "CONFIG/DAT:0",0 ENDC  *** END CONDITIONAL*CnvCnfig PSHS X LEAX h@,PCR notes off CALL HexSBin,REGX,#ALLOFFDT,#10 LDA i@,PCR drive size STA DR40TRK CMPA #'Y BNE D@ CLR DR40TRKD@ LEAX j@,PCR foreground color LBSR atoi STB $FFBD LEAX k@,PCR background color LBSR atoi STB $FFBC LEAX l@,PCR border color LBSR atoi STB $FFB8 LDA m@,PCR monochrome on/off CMPA #'M BNE C@ LDA #$16 set monochrome STA $FF98C@ LEAX p@,PCR set SPP_FL LDA ,X check for "no" CMPA #'N BNE E@ LDD #$FFFF BRA F@E@ LDA ,X check for digit CMPA #'0 BLO G@ CMPA #'9 BHI G@ LBSR atoiF@ STD SPP_FLG@ LDA t@,PCR get MPI slot # SUBA #'1 BMI H@ CMPA #3 BHI H@ PSHS A LSLA LSLA LSLA LSLA ORA ,S+ STA MPI_SLOTH@ PULS X,PC*LoadCnfg PSHS X IFNE DEMO *** CONDITIONAL IFNE TAPE LEAX s@,PCR LBSR Open LBSR LOF CMPD #0 BNE A@ LBSR Close LBSR Kill LBSR SndErr BRA B@A@ LEAX h@,PCR CALL Read,REGX,#40 LBSR Close LBSR CnvCnfig ENDC  *** END CONDITIONAL ENDCB@ PULS X,PC* set the MIDI clock (assumes use of HSYNC timing)* there are 96 system "ticks" per beat, which* means there are 4 ticks per MIDI clock* Formula used:*     clock period = 60/(48(tempo)(63.5xE-6))* the clock period is the number decremented by* the IRQ routine; tempo is beats per minute.*SetClock PROC LEAX i@,PCR LDA CLOKFLAG BEQ C@ LDD #'ON STD ,X++ LDA #32 STA ,X BRA D@C@ LDD #'OF STD ,X++ LDA #'F STA ,XD@ CALL Divide,#9840,CPERIOD LEAX e@,PCR LBSR BINDEC CALL StrPad,REGX,#3 LEAX a@,PCR CALL SetBox,REGX CALL BoxInp,REGX LBSR ClrBox CMPB #BREAK BEQ Z@ LEAX e@,PCR LBSR atoi STD ARG2 CALL Divide,#9840,ARG2 STD CPERIOD LDD i@,PCR set clock flag CMPD #'ON BEQ G@ CLRA BRA B@G@ LDA #1B@ STA CLOKFLAG LEAX FIRQmast,PCR LDA k@,PCR set slave flag CMPA #'S BNE E@ LEAX FIRQslav,PCR CLR CLOKFLAG LDA #1 BRA F@E@ CLRAF@ STA SLAVE STX $0110 set FIRQ vectorZ@ CLRA CLRB ENDP*a@ FDB 6,4,21,7,b@,c@b@ FDB 2,2,d@,*+2 text FDB 2,3,h@,*+2 FDB 2,4,j@,0c@ FDB 13,2,e@,*+4,0 input FDB 14,3,i@,*+4,*-18 FDB 16,4,k@,0,*-18d@ FCC "METRONOME:",0e@ FCC "100",0h@ FCC "MIDI CLOCK:",0i@ FCC "ON ",0j@ FCC "MASTER/SLAVE:",0k@ FCC "M",0* calculate CPERIOD given value in D* returns value in D (does not modify CPERIOD!)*CPCalc PSHS X STD ARG2 CALL Divide,#9840,ARG2 PULS X,PC* Clear all music and comments*ClearAll LBSR Sure CMPD #0 BNE Z@ LDD BUFFER1 ADDD #EVNSIZE STD BUF1END ADDD #EVNSIZE STD BUFFER2 LDD #$FFFF STD [BUFFER1] STD [BUFFER2] LDX #COMMENTS clear out the LDB #130 commentsA@ LDA ,X+ BEQ B@ LDA #32 STA -1,XB@ DECB BNE A@ LDX #TFLAGS set the status LDB #10 flags to PLAY LDA #$80C@ STA ,X+ DECB BNE C@ LDD #$FFFF STD BLK_STRT STD BLK_END LBSR SndOKZ@ LDA #1 ask for screen update RTS* Delete a track* LOCAL L_B2KILL PROC LBSR Sure CMPD #0 BNE Z@ LDX BUFFER1 TFR X,YA@ LDD 0,X check for end CMPD #$FFFF BEQ D@ LDA 7,X check track # CMPA TRACK BEQ C@ LDB #EVNSIZEB@ LDA ,X+ STA ,Y+ DECB BNE B@ BRA A@C@ LEAX EVNSIZE,X BRA A@D@ LDD ,X transfer the end mark STD ,Y CALL FindEnd,BUFFER1 ADDD #EVNSIZE STD BUF1END SUBD BUFFER2 BEQ Z@ CALL FindEnd,BUFFER2 STD ARG2 LDD BUF1END ADDD #EVNSIZE STD ARG3 CALL MoveDown,BUFFER2,ARG2,ARG3 STD BUFFER2 LBSR SndOK LDA #1 ask for screen updateZ@ ENDPEXIT LBSR Sure CMPD #0 BNE Z@ CLRB CLRA  restore disk drive STD $EA head to track 0 STA SLOW IFNE TAPE LBSR DSKCON LBSR DiskOff ENDC CLRA TFR A,DP CLR $71 STA ROM_ON JMP [$FFFE]Z@ CLRA CLRB RTSEDIT LBSR CLS CALL Edit,BUFFER1 BRA Y@X@ CLRA CLRB BRA Z@Y@ LDA #1 ask for screen updateZ@ RTSSndOK CALL Bell,#60 RTSSndErr CALL Bell,#255 RTS* Ask whether the user is sure* Returns 0 if Yes, else $FFFF* LOCAL L_KEYSure PROC LEAX a@,PCR CALL SetBox,REGX LBSR SndErrA@ LBSR getchar CMPA #'Y BNE X@ CLRA CLRB STD L_KEY,S BRA Z@X@ LDD #$FFFF STD L_KEY,SZ@ LBSR ClrBox LDD L_KEY,S ENDPa@ FDB 7,5,17,5,b@,0b@ FDB 2,2,c@,0c@ FCC "ARE YOU SURE?",0* perform general setup chores*SETUP PSHS X,Y LDD $C000 check for disk ROM CMPD #'DK BEQ C@C@ LDA #$0E TFR A,DP CLR $987 disable verify CLR $71 enable cold start* set new interrupt vectors LEAX Error,PCR set new error vector STX $18F ORCC #INT_OFF disable interrupts LEAX NEWIRQ,PCR set new IRQ vector STX $010D LEAX FIRQmast,PCR set new FIRQ vector STX $0110 LEAX NEWNMI,PCR set new NMI vector STX $10A* initialize PIA for FIRQ LDA $FF23 ORA #1 to enable FIRQ ANDA #$FD set flag on falling edge STA $FF23 LDA $FF21 disable CD interrupt ANDA #$FE STA $FF21* check for Colorchestra LDD #$FF6E set default--CoCo MIDI STD MSTAT INCB STD MDATA LDX #$FF66 LDD ,X CMPD #$FFFF BEQ F@ TSTA BNE F@ STX MSTAT LEAX 1,X STX MDATA* initialize the hardware MIDI interfaceF@ LDA #3 STA [MSTAT] LDA #$15 STA [MSTAT]* set up misc variables LDD STARTUP CMPD #$5AF0 BEQ B@ LDX #TFLAGS enable all tracks LDA #$80 (turn off mute) LDB #10A@ STA ,X+ DECB BNE A@ LDD #$FFFF clear buffers STD [BUFFER1] STD [BUFFER2] LBSR LoadCnfg LDD #$5AF0 STD STARTUP LBSR getcharB@ LBSR TVON STA ROM_OFF ANDCC #$EF enable IRQ LBSR SetSpd PULS X,Y,PC* display BUFFER1 in raw hex format* LOCAL L_CNT CHAR L_PTR,3RAW PROC LDY BUFFER1 LBSR CLSE@ CLR XPOS CLR YPOS LBSR MOVEA@ CLR TINVERT CMPY BUFFER2 BEQ G@ CMPY BUFFER1 BLO F@ CMPY BUF1END BHI F@G@ COM TINVERTF@ TFR Y,D print address PSHS B LEAX L_PTR,S LBSR BINHEX LBSR PUTS PULS A LEAX L_PTR,S LBSR BINHEX LBSR PUTS LDA #32 LBSR ChrOut LDA #EVNSIZE STA L_CNT,SB@ LDA ,Y+ LEAX L_PTR,S LBSR BINHEX LBSR PUTS LDA #32 LBSR ChrOut DEC L_CNT,S BNE B@ LDA YPOS,PCR INCA CMPA #16 BEQ C@ STA YPOS,PCR CLR XPOS,PCR LBSR MOVE BRA A@C@ LBSR getchar CMPA #UP BNE D@ LEAY -$100,Y BRA E@D@ CMPA #DOWN BNE Z@ BRA E@Z@ LDA #1 request screen update CLR TINVERT ENDPNEWIRQ LDA $FF00 clear int. flag STA KEYINP TST $FF02 RTINEWNMI LDA $982 identical to NMI BEQ Z@ routine in ROM LDX $983 STX 10,S CLR $982Z@ RTI* set the MIDI filter* LOCAL L_BITSetFiltr PROC* set up the box to show current filter state LEAX q@,PCR LDA MFILTER LSRAC@ LSRA BCS D@ LDB #32 BRA E@D@ LDB #'XE@ STB [4,X] LDX 6,X BNE C@* get user input LEAX a@,PCR CALL SetBox,REGX CALL BoxInp,REGX CMPD #BREAK BEQ Z@ LDA #2 STA L_BIT,S LDA #'X LDB #1 set note off filter on LEAX q@,PCR point to first inputA@ CMPA [4,X] BNE B@ ORB L_BIT,SB@ LSL L_BIT,S LDX 6,X BNE A@ STB MFILTER,PCRZ@ LBSR ClrBox CLRA CLRB ENDPa@ FDB 4,2,24,13,b@,q@b@ FDB 6,2,c@,*+2 text strings FDB 2,4,d@,*+2 FDB 2,5,e@,*+2 FDB 2,6,f@,*+2 FDB 2,7,g@,*+2 FDB 2,8,h@,*+2 FDB 2,9,i@,*+2 FDB 2,10,j@,0c@ FCC "MIDI FILTER",0d@ FCC "[ ] NOTE ON/OFF",0e@ FCC "[ ] KEY PRESSURE",0f@ FCC "[ ] CONTROL CHANGE",0g@ FCC "[ ] PROGRAM CHANGE",0h@ FCC "[ ] CHANNEL PRESSURE",0i@ FCC "[ ] PITCH WHEEL",0j@ FCC "[ ] SYSTEM 'EVENT'",0q@ FDB 3,4,r@,*+4,0 input strings FDB 3,5,s@,*+4,*-18 FDB 3,6,t@,*+4,*-18 FDB 3,7,u@,*+4,*-18 FDB 3,8,v@,*+4,*-18 FDB 3,9,w@,*+4,*-18 FDB 3,10,x@,0,*-18r@ FCC " ",0s@ FCC " ",0t@ FCC " ",0u@ FCC " ",0v@ FCC " ",0w@ FCC " ",0x@ FCC " ",0* ask for number of beats/measure*SetMeasr PROC LEAX a@,PCR CALL SetBox,REGX CALL BoxInp,REGX LBSR ClrBox CMPB #BREAK BEQ Z@* convert beats/measure to ticks LEAX d@,PCR LBSR atoi STB BAR STD ARG1 CALL Mult,ARG1,TIMEBASE STD MEASURE CLRA CLRBZ@ ENDP*a@ FDB 6,5,20,5,*+4,b@ FDB 2,2,c@,0b@ FDB 16,2,d@,0,0 input stringc@ FCC "BEATS/MEASURE=",0d@ FCC "4 ",0SetKey PROC LEAX a@,PCR CALL SetBox,REGX CALL BoxInp,REGX LBSR ClrBox CMPB #BREAK BEQ Z@ LDA c@,PCR CMPA #'S BEQ A@ CMPA #'F BEQ A@ LBSR SndErr LDA #'SA@ STA KEYZ@ CLRA CLRB ENDP*a@ FDB 6,5,20,5,*+4,b@ FDB 2,2,*+4,0 FCC "FLAT OR SHARP?",0b@ FDB 17,2,c@,0,0c@ FCC "S",0MarkAll PROC LDX BUFFER1,PCR LDD 0,X get start time STD BLK_STRT CALL FindEnd,BUFFER1 CMPD BUFFER1 BNE A@ LDD [BUFFER1] BRA B@A@ TFR D,X LDD -EVNSIZE,XB@ STD BLK_END LBSR SndOK LDD #$FFFF ENDPAbout PSHS X LEAX a@,PCR CALL SetBox,REGX LBSR getchar LBSR ClrBox CLRA CLRB PULS X,PCa@ FDB 0,3,32,10,b@,0b@ FDB 2,2,c@,*+2 FDB 2,3,d@,*+2 FDB 2,4,e@,*+2 FDB 4,5,f@,*+2 FDB 4,6,g@,*+2 FDB 4,7,h@,0c@ FCC "THIS PROGRAM IS UNDERGOING",0d@ FCC "FREQUENT IMPROVEMENTS. GET",0e@ FCC "THE LATEST VERSION FROM:",0f@ FCC "LESTER HANDS",0g@ FCC "HAMLET RT. BOX 1261",0h@ FCC "SEASIDE, OR 97138",0 INCL BOX INCL MIDI INCL EDIT INCL BLOCK INCL BR INCL UTILITY IFNE TAPE INCL DISK ELSE INCL TAPE ENDC MSG "END OF PROGRAM=",* RMB 256STACK EQU *BUF1ADR RMB EVNSIZE*2BUF2ADR EQU * IFEQ DEBUGTOPMEM EQU $7F00 ELSETOPMEM EQU $FDF0 ENDC INCL TITLE END START* end of file: CM3/TXT