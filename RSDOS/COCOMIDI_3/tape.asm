* TAPE/TXT - part of CoCoMIDI 3* (C) 1989 by Lester Hands*DBUFFER EQU $989 buffer for direct diskDBUFPTR FDB DBUFFER ptr to position in bfrDBUFEND FDB DBUFFER+$100 end of disk buffer* save current music to tape*Save PSHS X,Y,U LBSR GetTSpd CMPA #3 check for BREAK LBEQ Z@ LBSR PosTape CMPA #3 LBEQ Z@ LBSR TOpenW* write the headers first to the disk fileB@ CALL FindEnd,>BUFFER1 SUBD >BUFFER1 ADDD #2 STD j@+2,PCR LEAX FHEADR,PCR main header ADDD #438 STD 6,X CALL Write,REGX,#8 LEAX 8,X tempo header PSHS X CALL Divide,#9840,CPERIOD PULS X STD 8,X CALL Write,REGX,#10 LEAX 10,X status header CALL Write,REGX,#8 CALL Write,#TFLAGS,#10 LEAX 8,X comment header CALL Write,REGX,#8 CALL Write,#COMMENTS,#130 LEAX 8,X events header CALL Write,REGX,#8 LDD j@+2,PCR STD ARG2 CALL Write,BUFFER1,ARG2 LEAX 8,X messages header CALL Write,REGX,#8 LEAX MESSAGES,PCR CALL Write,REGX,#264 LBSR TCloseWZ@ LBSR DiskOff turn drive motor off LBSR SetSpd LBSR TVON CLRA CLRB PULS X,Y,U,PC*FHEADR FCC "CM30" first header in file FDB 0,0  length of remaining file FCC "TMPO" tempo header (BPM) FDB 0,2  # bytes in data FDB 100  the actual tempo FCC "STAT" status header FDB 0,10  status bytes for 10 FCC "CMNT" comment header FDB 0,130  13 bytes/comment FCC "EVNT" event headerj@ FDB 0,0  # bytes to follow FCC "MSGS" messages header FDB 0,256* write the last block to tape*TCloseW LDD DBUFPTR,PCR SUBD #DBUFFER STB >$7D BLKLEN LDD #DBUFFER STD >$7E CBUFAD LDA #$FF STA >$7C BLKTYP=end LBSR BlkOut LDA $FF01 turn tape sound off ANDA #$F7 STA $FF01 LDA #32 *** STA $400 *** LBSR SetSpd RTS* write a tape header*TOpenW PSHS X,DP,CC CLRA TFR A,DP STA $FFDE JSR [$A00C] LEAX a@,PCR STX >$7E CBUFAD CLR >$7C BLKTYP LDA #8 STA >$7D BLKLEN LBSR BlkOut LDA #'0 *** STA $400 *** LDD #DBUFFER zero the direct access STD DBUFPTR disk buffer ADDD #$FF STD DBUFEND PULS X,DP,CC,PC*a@ FCC "CM30    "* Write S_CNT number of bytes to tape from* memory pointed to by S_PTR.*Write PROC S_PTR,S_CNT LDY S_CNT,S BEQ Z@ LDX S_PTR,S LDU DBUFPTR,PCRA@ LDA ,X+ STA ,U+ CMPU DBUFEND,PCRD@ BNE B@ LBSR WriteRaw LDU #DBUFFERB@ LEAY -1,Y BNE A@ STU DBUFPTR,PCRZ@ ENDP* write a block to tape*WriteRaw LDD #DBUFFER STD >$7E CBUFAD LDA #1 STA >$7C BLKTYP LDA #$FF STA >$7D BLKLEN BRA BlkOutBlkOut PSHS DP,CC,X,Y,U INC $400 CLRA TFR A,DPB@ STA ROM_ON*        JSR     [$A00C]       start up tape JSR [$A008] write a block STA ROM_OFF CLRAA@ NOP DECA BNE A@ PULS DP,CC,X,Y,U,PCLoadLink RTS* ask user to position tape*PosTape PSHS X LDA $FF21 turn tape motor on ORA #8 STA $FF21 LBSR TVON LDA $FF01 enable tape sound ORA #8 STA $FF01 LEAX a@,PCR CALL SetBox,REGX LBSR getchar LBSR ClrBox PULS X,PC*a@ FDB 1,5,30,5,b@,0b@ FDB 2,2,c@,0c@ FCC "POSITION TAPE, PRESS A KEY",0* ask user for tape speed*GetTSpd PSHS X LEAX a@,PCR CALL SetBox,REGX CALL BoxInp,REGX LBSR ClrBox CMPB #BREAK BEQ Z@ LDA d@,PCR CMPA #'Y BEQ A@ CMPA #'y BNE B@A@ STA FAST BRA Z@B@ STA SLOWZ@ PULS X,PC*a@ FDB 4,5,24,5,b@,c@b@ FDB 2,2,*+4,0 FCC "DOUBLE SPEED TAPE?",0c@ FDB 21,2,d@,0,0d@ FCC "N",0* read in an entire tape file*Load LBSR GetTSpd CMPA #3 check for BREAK BEQ Z@ LBSR TVON LDA $FF01 enable tape sound ORA #8 STA $FF01 PSHS DP,CC CLRA TFR A,DPC@ STA ROM_ON JSR [$A004] turn tape on LDD #DBUFFER STD >$7E set buffer address* look for a header blockE@ JSR [$A006] BLKIN TST >$7C BLKTYP BNE E@ header block? LDA #'0 *** STA $400 **** read each block in until the last block is read LDY >BUFFER1A@ STY >ARG1 STA ROM_ON JSR [$A006] BLKIN STA ROM_OFF INC $400 *** TSTA  check for errors BNE D@ LDX #DBUFFER LDY >ARG1 LDB #$FFB@ LDA ,X+ STA ,Y+ DECB BNE B@ LDA >$7C BLKTYP CMPA #$FF BNE A@ PULS CC,DP LBSR GetDMem BRA Z@D@ PULS CC,DP CLRB LDA #$FF error exit pointF@ STA ,Y+ CMPY #TOPMEM-8 BHS G@ DECB BNE F@G@ LBSR SndErrZ@ LBSR TVON LBSR DiskOff LBSR SetSpd RTS* verify a tape file (but don't check contents)*TVerify LBSR GetTSpd CMPA #3 check for BREAK BEQ Z@ LBSR TVON LDA $FF01 enable tape sound ORA #8 STA $FF01 PSHS DP,CC CLRA TFR A,DPC@ STA ROM_ON JSR [$A004] turn tape on LDD #DBUFFER STD >$7E set buffer address* look for a header blockE@ JSR [$A006] BLKIN TST >$7C BLKTYP BNE E@ header block? LDA #'0 *** STA $400 **** read each block in until the last block is readA@ STA ROM_ON JSR [$A006] BLKIN STA ROM_OFF INC $400 *** TSTA  check for errors BNE D@ LDA >$7C BLKTYP CMPA #$FF BNE A@ PULS CC,DP BRA Z@D@ PULS CC,DP LBSR SndErr error exit pointZ@ LBSR TVON LBSR DiskOff LBSR SetSpd RTS* get the disk memory--move data to correct positions* LOCAL L_END,L_STGetDMem PROC* check for valid file LEAX FHEADR,PCR look for required LDY BUFFER1 file header LDD ,X++ CMPD ,Y++ BNE A@ LDD ,X++ CMPD ,Y++ BEQ C@A@ LDD #$FFFF not a valid header, STD [BUFFER1] so clear buffer LBSR SndErr BRA D@* this section ignores data structures just so we* we can get the stuff into memory quickly!C@ LDX BUFFER1 LDD 16,X get tempo LBSR CPCalc STD CPERIOD LEAY 26,X get status bytes LDU #TFLAGS LDB #10G@ LDA ,Y+ STA ,U+ DECB BNE G@ LEAY 44,X get comments LDU #COMMENTS LDB #130E@ LDA ,Y+ STA ,U+ DECB BNE E@ LEAX 182,XD@ CALL FindEnd,REGX STD L_END,S STX L_ST,S TFR D,X LEAX 2,X check for messages LDD ,X++ CMPD #'MS BNE B@ LDD ,X++ CMPD #'GS BNE B@ LEAX 4,X skip block length CLRB LEAY MESSAGES,PCRF@ LDA ,X+ STA ,Y+ DECB BNE F@B@ LBSR ClrBlock LDD L_END,S STD ARG2 LDX L_ST,S CALL MoveDown,REGX,ARG2,BUFFER1 CALL FindEnd,BUFFER1 ADDD #EVNSIZE STD BUF1END ADDD #EVNSIZE STD BUFFER2 LDD #$FFFF STD [BUFFER2]Z@ ENDPFKILL RTSKill RTS* turn the tape drive motor off*DiskOff LDA $FF21 turn tape motor off ANDA #$F7 STA $FF21Z@ RTSError RTS* end of file: TAPE/TXT